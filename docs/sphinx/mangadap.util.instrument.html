

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.util.instrument module &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="index.html"/>
        <link rel="up" title="mangadap.util package" href="mangadap.util.html"/>
        <link rel="next" title="mangadap.util.lineprofiles module" href="mangadap.util.lineprofiles.html"/>
        <link rel="prev" title="mangadap.util.geometry module" href="mangadap.util.geometry.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="mangadap.html">mangadap package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="mangadap.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="mangadap.config.html">mangadap.config package</a></li>
<li class="toctree-l3"><a class="reference internal" href="mangadap.contrib.html">mangadap.contrib package</a></li>
<li class="toctree-l3"><a class="reference internal" href="mangadap.par.html">mangadap.par package</a></li>
<li class="toctree-l3"><a class="reference internal" href="mangadap.proc.html">mangadap.proc package</a></li>
<li class="toctree-l3"><a class="reference internal" href="mangadap.survey.html">mangadap.survey package</a></li>
<li class="toctree-l3"><a class="reference internal" href="mangadap.test.html">mangadap.test package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="mangadap.util.html">mangadap.util package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="mangadap.util.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="mangadap.util.html#module-mangadap.util">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mangadap.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="mangadap.html#module-mangadap">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="mangadap.html">mangadap package</a> &raquo;</li>
        
          <li><a href="mangadap.util.html">mangadap.util package</a> &raquo;</li>
        
      <li>mangadap.util.instrument module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mangadap.util.instrument.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-mangadap.util.instrument">
<span id="mangadap-util-instrument-module"></span><h1>mangadap.util.instrument module<a class="headerlink" href="#module-mangadap.util.instrument" title="Permalink to this headline">¶</a></h1>
<p>Provides a set of functions to handle instrumental sampling and
resolution effects.</p>
<dl class="docutils">
<dt><em>License</em>:</dt>
<dd><dl class="first last docutils">
<dt>Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</dt>
<dd>Licensed under BSD 3-clause license - see LICENSE.rst</dd>
</dl>
</dd>
<dt><em>Source location</em>:</dt>
<dd>$MANGADAP_DIR/python/mangadap/util/instrument.py</dd>
<dt><em>Imports and python version compliance</em>:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">.constants</span> <span class="k">import</span> <span class="n">constants</span>
</pre></div>
</div>
</dd>
<dt><em>Revision history</em>:</dt>
<dd><div class="first last line-block">
<div class="line"><strong>27 May 2015</strong>: Original implementation by K. Westfall (KBW)
based on downgrader_MANGA.f provided by D.  Thomas, O. Steele,
D.  Wilkinson, D. Goddard.</div>
<div class="line"><strong>13 Jun 2015</strong>: D.Wilkinson edit to not calculate unimportant
convolution terms -&gt; runs 5x faster.</div>
<div class="line"><strong>03 Feb 2016</strong>: (KBW) Generalized M. Cappellari’s
<code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code> to <a class="reference internal" href="#mangadap.util.instrument.resample_vector" title="mangadap.util.instrument.resample_vector"><code class="xref py py-func docutils literal"><span class="pre">resample_vector()</span></code></a> to allow for linear
interpolation of flux density across the pixel.</div>
<div class="line"><strong>04 Feb 2016</strong>: (KBW) Further fixes to <a class="reference internal" href="#mangadap.util.instrument.resample_vector" title="mangadap.util.instrument.resample_vector"><code class="xref py py-func docutils literal"><span class="pre">resample_vector()</span></code></a>.
Added <a class="reference internal" href="#mangadap.util.instrument.spectral_coordinate_step" title="mangadap.util.instrument.spectral_coordinate_step"><code class="xref py py-func docutils literal"><span class="pre">spectral_coordinate_step()</span></code></a>, and propagated change to
<a class="reference internal" href="#mangadap.util.instrument.spectrum_velocity_scale" title="mangadap.util.instrument.spectrum_velocity_scale"><code class="xref py py-func docutils literal"><span class="pre">spectrum_velocity_scale()</span></code></a></div>
<div class="line"><strong>21 Apr 2016</strong>: (KBW) It’s the Queen’s 90th birthday!  Removed
log10 keyword from <a class="reference internal" href="#mangadap.util.instrument.spectrum_velocity_scale" title="mangadap.util.instrument.spectrum_velocity_scale"><code class="xref py py-func docutils literal"><span class="pre">spectrum_velocity_scale()</span></code></a>.</div>
<div class="line"><strong>20 May 2016</strong>: (KBW) Corrected match between number of pixels
and output range computed in <a class="reference internal" href="#mangadap.util.instrument.resample_vector_npix" title="mangadap.util.instrument.resample_vector_npix"><code class="xref py py-func docutils literal"><span class="pre">resample_vector_npix()</span></code></a>; now
returns an adjusted range to make sure that the sampling and
range results in an exact integer number of pixels.</div>
<div class="line"><strong>05 Jul 2016</strong>: (KBW) To avoid confusion, commented out
log_rebin.</div>
<div class="line"><strong>25 Oct 2016</strong>: (KBW) Modified <a class="reference internal" href="#mangadap.util.instrument.spectral_coordinate_step" title="mangadap.util.instrument.spectral_coordinate_step"><code class="xref py py-func docutils literal"><span class="pre">spectral_coordinate_step()</span></code></a>
to be a mean over the full spectrum to avoid numerical precision
errors.</div>
<div class="line"><strong>06 Apr 2017</strong>: (KBW) Add <a class="reference internal" href="#mangadap.util.instrument.angstroms_per_pixel" title="mangadap.util.instrument.angstroms_per_pixel"><code class="xref py py-func docutils literal"><span class="pre">angstroms_per_pixel()</span></code></a>.</div>
<div class="line"><strong>30 Aug 2017</strong>: (KBW) Add <a class="reference internal" href="#mangadap.util.instrument.resample1d" title="mangadap.util.instrument.resample1d"><code class="xref py py-func docutils literal"><span class="pre">resample1d()</span></code></a>;
<a class="reference internal" href="#mangadap.util.instrument.resample_vector" title="mangadap.util.instrument.resample_vector"><code class="xref py py-func docutils literal"><span class="pre">resample_vector()</span></code></a> should be deprecated.</div>
<div class="line"><strong>27 Sep 2017</strong>: (KBW) Added <cite>integral</cite> keyword to
<a class="reference internal" href="#mangadap.util.instrument.match_spectral_resolution" title="mangadap.util.instrument.match_spectral_resolution"><code class="xref py py-func docutils literal"><span class="pre">match_spectral_resolution()</span></code></a> so that it can be passed to
<a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</div>
</div>
</dd>
</dl>
<dl class="class">
<dt id="mangadap.util.instrument.SpectralResolution">
<em class="property">class </em><code class="descclassname">mangadap.util.instrument.</code><code class="descname">SpectralResolution</code><span class="sig-paren">(</span><em>wave</em>, <em>sres</em>, <em>log10=False</em>, <em>interp_ext='extrapolate'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Container class for the resolution, <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, of a spectrum.  The primary functionality is
to determine the parameters necessary to match the resolution of one
spectrum to another.  It can also be used as a function to
interpolate the spectral resolution at a given wavelenth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wave</strong> (<em>numpy.ndarray</em>) – A 1D vector with the wavelength in
angstroms.  The sampling may be either in linear steps of
wavelength or <span class="math">\(\log_{10}\)</span> steps.</li>
<li><strong>sres</strong> (<em>numpy.ndarray</em>) – A 1D vector with the spectral resolution,
<span class="math">\(R\)</span>, sampled at the positions of the provided
wavelength vector.</li>
<li><strong>log10</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag that the spectrum has been
binned logarithmically (base 10) in wavelength</li>
<li><strong>interp_ext</strong> (<em>int</em><em> or </em><em>str</em>) – (<strong>Optional</strong>) The value to pass as
<em>ext</em> to the interpolator, which defines its behavior when
attempting to sample the spectral resolution beyond where it
is defined.  See
<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.  Default
is to extrapolate.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if <em>wave</em> is not a 1D vector or if <em>wave</em> and
<em>sres</em> do not have the same shape.</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.interpolator">
<code class="descname">interpolator</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>): An
object used to interpolate the spectral resolution at any
given wavelength.  The interpolation is hard-wired to be
<strong>linear</strong> and its extrapolation behavior is defined by
<em>interp_ext</em>.  The wavelength and resolution vectors are
held by this object for later reference if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.log10">
<code class="descname">log10</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.log10" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bool</em> – Flag that the spectrum has been binned
logarithmically (base 10) in wavelength</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.c">
<code class="descname">c</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.c" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – The speed of light; provided by <a class="reference external" href="http://docs.astropy.org/en/stable/constants/index.html">astropy.constants</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.dv">
<code class="descname">dv</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.dv" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – The velocity step per pixel in km/s.  Defined using
<a class="reference internal" href="#mangadap.util.instrument.spectrum_velocity_scale" title="mangadap.util.instrument.spectrum_velocity_scale"><code class="xref py py-func docutils literal"><span class="pre">spectrum_velocity_scale()</span></code></a> if <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.log10" title="mangadap.util.instrument.SpectralResolution.log10"><code class="xref py py-attr docutils literal"><span class="pre">log10</span></code></a> is True;
otherwise set to None.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.dw">
<code class="descname">dw</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.dw" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – The wavelength step per pixel in angstroms.  Defined
as the wavelength step between the first two pixels if
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.log10" title="mangadap.util.instrument.SpectralResolution.log10"><code class="xref py py-attr docutils literal"><span class="pre">log10</span></code></a> is False; otherwise set to None.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.min_sig">
<code class="descname">min_sig</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.min_sig" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – Minimum standard deviation allowed for the
kernel used to match two spectral resolutions.  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.sig_pd">
<code class="descname">sig_pd</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – The standard deviation in pixels
required to match the spectral resolution of this object to
the resolution defined by a different
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution" title="mangadap.util.instrument.SpectralResolution"><code class="xref py py-class docutils literal"><span class="pre">SpectralResolution</span></code></a> object.  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.sig_mask">
<code class="descname">sig_mask</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.sig_mask" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – A <em>uint</em> vector used to identify
measurements of <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a> that should <strong>not</strong> be used
to match the spectral resolution of this object to the
resolution defined by a different
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution" title="mangadap.util.instrument.SpectralResolution"><code class="xref py py-class docutils literal"><span class="pre">SpectralResolution</span></code></a> object.  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.SpectralResolution.sig_vo">
<code class="descname">sig_vo</code><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.sig_vo" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – A constant offset of the kernal standard
deviation <strong>in km/s</strong> that has been applied to
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a>.  See <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Allow it to determine if the binning is linear or geometric,
then use the <em>log10</em> keyword to distinguish between natural
log and <span class="math">\(log_{10}\)</span> binning.</li>
<li>Allow for more than one type of line-spread function?</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The default behavior of the interpolator is to extrapolate the
input spectral resolution vector when trying to sample from
regions beyond where it is sampled.  Use <em>interp_ext</em> change
this; see <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.</p>
</div>
<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference">
<code class="descname">GaussianKernelDifference</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the parameters of a Gaussian kernel required to
convert the resolution of this object to the resolution of a
different the <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution" title="mangadap.util.instrument.SpectralResolution"><code class="xref py py-class docutils literal"><span class="pre">SpectralResolution</span></code></a> object, <em>new_sres</em>.</p>
<p>The spectral resolution is defined as <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, where <span class="math">\(\Delta\lambda\)</span> is the FWHM
of the spectral resolution element.  The standard deviation of
the resolution element in angstroms is then</p>
<div class="math">
\[\sigma_\lambda = \frac{\lambda}{f R}, \ \ {\rm where} \ \  f
= \frac{{\rm FWHM_\lambda}}{\sigma_\lambda} = \sqrt{8\ln 2}.\]</div>
<p>Assuming a Gaussian (in angstroms) line-spread function:</p>
<div class="math">
\[\sigma^2_{\lambda,2} = \sigma^2_{\lambda,1} +
\sigma^2_{\lambda,d}\]</div>
<p>such that</p>
<div class="math">
\[\sigma^2_{\lambda,d} = \left(\frac{\lambda}{f}\right)^2
(R^{-2}_2 - R^{-2}_1)\]</div>
<p>is the defining parameter of the Gaussian kernel needed to take
a spectrum of resolution <span class="math">\(R_1\)</span> to one with a resolution of
<span class="math">\(R_2\)</span>.</p>
<p>For input to <a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>, the
<em>wavelength-dependent</em> parameter of the Gaussian kernel is
converted to pixels.  This function allows for the input spectra
to be linearly sampled in angstroms or log10(angstroms).  For
the former (<em>log10=False</em>),</p>
<div class="math">
\[\sigma^2_{p,d} = \left(\frac{\lambda}{f\
\delta\lambda}\right)^2 (R^{-2}_2 - R^{-2}_1)\]</div>
<p>where <span class="math">\(\delta\lambda\)</span> is the size of the pixel in
angstroms.  If the units are log10(angstrom) (<em>log10=True</em>), we
approximate the velocity width of each pixel to be <span class="math">\(\delta
v = c \ln(10.0) (\log\lambda[1]-\log\lambda[0])\)</span>, such that</p>
<div class="math">
\[\begin{split}\sigma^2_{p,d} &amp;= \left(\frac{c}{ \delta v \lambda}\right)^2
\sigma^2_{\lambda,d} \\ &amp;= \left(\frac{c}{ f\ \delta
v}\right)^2 (R^{-2}_2 - R^{-2}_1)\ ;\end{split}\]</div>
<p><span class="math">\(c\)</span> is the speed of light in km/s.</p>
<p>The nominal use of this algorithm assumes <span class="math">\(R_1 \geq R_2\)</span>.
However, in practice, <a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> only
uses a Gaussian kernel up to some minimum value of
<span class="math">\(\epsilon_\sigma\)</span>; below this, the kernel is assumed to be
a Delta function.  Therefore, as long as</p>
<div class="math">
\[\sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}
\geq -\epsilon_\sigma\ ,\]</div>
<p>the behavior of <a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> should not be
affected.  However, in regions with</p>
<div class="math">
\[\sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}
\leq \epsilon_\sigma\ ,\]</div>
<p>the behavior of <a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> does <em>not</em>
produce an accurate convolution!</p>
<p>To deal with spectral regions that do not have
<span class="math">\(\sigma_{p,d} \geq \epsilon_\sigma\)</span>, there are three
choices:</p>
<blockquote>
<div><p>(<strong>Option 1</strong>) trim the spectral range to only those
spectral regions where the existing resolution is better
than the target resolution up to this limit,</p>
<p>(<strong>Option 2</strong>) match the existing resolution to the target
resolution up to some constant offset that must be accounted
for in subsequent analyses, or</p>
<p>(<strong>Option 3</strong>) allow for a wavelength dependent difference
in the spectral resolution that must be accounted for in
subsequent analyses.</p>
</div></blockquote>
<p>The choice of either Option 1 or 2 is selected by setting
<em>no_offset</em> to, respectively, True or False; Option 1 is the
default behavior.  Currently, Option 3 is not allowed.</p>
<p>For Option 1, pixels with <span class="math">\(\sigma_{p,d} &lt;
\epsilon_\sigma\)</span> are masked (<em>sigma_mask = 1</em>); however, the
returned values of <span class="math">\(\sigma_{p,d}\)</span> are left unchanged.</p>
<p>For Option 2, we define</p>
<div class="math">
\[\sigma^2_{v,o} = | {\rm min}(0.0, {\rm min}(\sigma^2_{v,d})
- {\rm max}(\epsilon_\sigma \delta v)^2) |\]</div>
<p>where <span class="math">\(\delta v\)</span> is constant for the logarithmically
binned spectrum and is wavelength dependent for the linearly
binned spectra; in the latter case, the velocity step is
determined for each pixel:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
<span class="n">dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>If <span class="math">\(\sigma^2_{v,o} &gt; 0.0\)</span>, it must be that <span class="math">\({\rm
min}(\sigma^2_{v,d}) &lt; {\rm max}(\epsilon_\sigma \delta v)^2\)</span>,
such that an offset should be applied.  In that case, the
returned kernel parameters are</p>
<div class="math">
\[\sigma^\prime_{v,d} = \sqrt{\sigma^2_{v,d} +
\sigma^2_{v,o}}\ .\]</div>
<p>with the units converted to pixels using the equations above, no
pixels are masked, and <span class="math">\(\sqrt{\sigma^2_{v,o}}\)</span> is returned
for the offset.  Otherwise, the offset is set to 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_sres</strong> (<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution" title="mangadap.util.instrument.SpectralResolution"><code class="xref py py-class docutils literal"><span class="pre">SpectralResolution</span></code></a>) – Spectral resolution
to match to.</li>
<li><strong>no_offset</strong> (<em>bool</em>) – (<strong>Optional</strong>) Force <span class="math">\(\sigma^2_{v,o}
= 0\)</span> by masking regions with <span class="math">\(\sigma_{p,d} &lt;
\epsilon_\sigma\)</span>; i.e., the value of this arguments
selects Option 1 (True) or Option 2 (False).</li>
<li><strong>min_sig_pix</strong> (<em>float</em>) – (<strong>Optional</strong>) Minimum value of the
standard deviation allowed before assuming the kernel is
a Delta function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution._convert_pd2vd">
<code class="descname">_convert_pd2vd</code><span class="sig-paren">(</span><em>sig2_pd</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution._convert_pd2vd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution._convert_pd2vd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from <span class="math">\(\sigma^2_{p,d}\)</span> to <span class="math">\(\sigma^2_{v,d}\)</span>.
See <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution._convert_vd2pd">
<code class="descname">_convert_vd2pd</code><span class="sig-paren">(</span><em>sig2_vd</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution._convert_vd2pd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution._convert_vd2pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from <span class="math">\(\sigma^2_{v,d}\)</span> to <span class="math">\(\sigma^2_{p,d}\)</span>.
See <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution._finalize_GaussianKernelDifference">
<code class="descname">_finalize_GaussianKernelDifference</code><span class="sig-paren">(</span><em>sig2_pd</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution._finalize_GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution._finalize_GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the calculated <span class="math">\(\sigma^2_{p,d}\)</span>, calculate and save
the attributes <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a> and <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_mask" title="mangadap.util.instrument.SpectralResolution.sig_mask"><code class="xref py py-attr docutils literal"><span class="pre">sig_mask</span></code></a>.  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.adjusted_resolution">
<code class="descname">adjusted_resolution</code><span class="sig-paren">(</span><em>indx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.adjusted_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.adjusted_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution that should result from applying
<a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> to the spectrum associated
with this spectral resolution object using <code class="xref py py-attr docutils literal"><span class="pre">sigma_pd</span></code>.
I.e., calculate:</p>
<div class="math">
\[R_2 = \left[ \left(\frac{f}{c}\right)^2 \sigma^2_{v,d} +
R^{-2}_1\right]^{-1/2}\ .\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indx</strong> (<em>tuple</em>) – (<strong>Optional</strong>) Selection tuple used to return
a subset of the full resolution vector.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The (full or selected) vector with the
adjusted resolution.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Allow to reset the resolution of this object to the adjusted
resolution and reset the kernel variables to None.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.instrumental_dispersion">
<code class="descname">instrumental_dispersion</code><span class="sig-paren">(</span><em>w=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.instrumental_dispersion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.instrumental_dispersion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the instrumental dispersion by converting from <span class="math">\(R\)</span>
to <span class="math">\(\sigma_{v,inst}\)</span> according to:</p>
<div class="math">
\[\sigma_{v,inst} = \frac{c}{\sqrt{8\ln 2}\ R}.\]</div>
<p>If w is None, just convert the internal interpolator values.
Otherwise, return the values sampled at w.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently only an alias for <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.offset_GaussianKernelDifference">
<code class="descname">offset_GaussianKernelDifference</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.offset_GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.offset_GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>If the properties required to match the resolution of one
spectrum to another has already been calculated (see
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>), this allows for one to apply
an additional offset.  The additional offset <strong>must</strong> be in km/s
(not pixels).</p>
<p>The offset is applied in quadrature; however, the offset can be
negative such that one can reduce <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a>.  Once
converted to km/s, the offset is applied by calculating:</p>
<div class="math">
\[\sigma^{\prime\ 2}_{v,d} = \sigma^{2}_{v,d} +
\sigma_{off}|\sigma_{off}|\ .\]</div>
<p><a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_vo" title="mangadap.util.instrument.SpectralResolution.sig_vo"><code class="xref py py-attr docutils literal"><span class="pre">sig_vo</span></code></a> is adjusted in the same way, and the change in
<span class="math">\(\sigma^{\prime\ 2}_{v,d}\)</span> is then propagated to
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a> and <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_mask" title="mangadap.util.instrument.SpectralResolution.sig_mask"><code class="xref py py-attr docutils literal"><span class="pre">sig_mask</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>offset</strong> (<em>float</em>) – Value of the standard deviation in km/s to
add in quadrature to a previously calculated
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.sig_pd" title="mangadap.util.instrument.SpectralResolution.sig_pd"><code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if the kernel properties have not yet
been defined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.sres">
<code class="descname">sres</code><span class="sig-paren">(</span><em>copy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.sres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.sres" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution vector; held by <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.interpolator" title="mangadap.util.instrument.SpectralResolution.interpolator"><code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.SpectralResolution.wave">
<code class="descname">wave</code><span class="sig-paren">(</span><em>copy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#SpectralResolution.wave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.SpectralResolution.wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavelength vector; held by <a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.interpolator" title="mangadap.util.instrument.SpectralResolution.interpolator"><code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mangadap.util.instrument.VariableGaussianKernel">
<em class="property">class </em><code class="descclassname">mangadap.util.instrument.</code><code class="descname">VariableGaussianKernel</code><span class="sig-paren">(</span><em>sigma</em>, <em>minsig=0.01</em>, <em>nsig=3.0</em>, <em>integral=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#VariableGaussianKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Support class for variable sigma convolution.  See
<a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</p>
<p>Stolen from M. Cappellari’s gaussian_filter1d function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.ndarray</em>) – Vector to convolve</li>
<li><strong>sigma</strong> (<em>numpy.ndarray</em>) – Coordinate-dependent standard deviation of the
Gaussian kernel</li>
<li><strong>ye</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) Error in the vector to
convolve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if <em>y</em> is not a 1D vector, or if the shape of
<em>y</em> and <em>sigma</em> (and <em>ye</em> if provided) are different.</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="mangadap.util.instrument.VariableGaussianKernel.x">
<code class="descname">x</code><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.x" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Pixel coordinate vector</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.VariableGaussianKernel.y">
<code class="descname">y</code><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.y" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Vector to convolve</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.VariableGaussianKernel.ye">
<code class="descname">ye</code><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.ye" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Error in the vector to convolve</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.VariableGaussianKernel.sigma">
<code class="descname">sigma</code><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Coordinate-dependent standard deviation of the
Gaussian kernel</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.VariableGaussianKernel.norm">
<code class="descname">norm</code><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.norm" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Gaussian normalization; calculated once for
efficiency</p>
</dd></dl>

<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Allow to switch to pixel sampled Gaussian kernel?</li>
</ul>
</div>
<dl class="method">
<dt id="mangadap.util.instrument.VariableGaussianKernel._check_shape">
<code class="descname">_check_shape</code><span class="sig-paren">(</span><em>y</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#VariableGaussianKernel._check_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel._check_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that the shapes are appropriate for the defined kernel.</p>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.VariableGaussianKernel._create_a">
<code class="descname">_create_a</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#VariableGaussianKernel._create_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel._create_a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.VariableGaussianKernel.convolve">
<code class="descname">convolve</code><span class="sig-paren">(</span><em>y</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#VariableGaussianKernel.convolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.VariableGaussianKernel.convolve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument._pixel_borders">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">_pixel_borders</code><span class="sig-paren">(</span><em>xlim</em>, <em>npix</em>, <em>log=False</em>, <em>base=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#_pixel_borders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument._pixel_borders" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the borders of the pixels in a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xlim</strong> (<em>numpy.ndarray</em>) – (Geometric) Centers of the first and last
pixel in the vector.</li>
<li><strong>npix</strong> (<em>int</em>) – Number of pixels in the vector.</li>
<li><strong>log</strong> (<em>bool</em>) – (<strong>Optional</strong>) The input range is (to be)
logarithmically sampled.</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) The base of the logarithmic
sampling.  The default is 10.0; use numpy.exp(1.) for the
natural logarithm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A vector with the (npix+1) borders of the
pixels and the sampling rate.  If logarithmically binned, the
sampling is the step in :math`log x`.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray, float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument._pixel_centers">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">_pixel_centers</code><span class="sig-paren">(</span><em>xlim</em>, <em>npix</em>, <em>log=False</em>, <em>base=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#_pixel_centers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument._pixel_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the centers of pixels in a linearly or geometrically
sampled vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xlim</strong> (<em>numpy.ndarray</em>) – (Geometric) Centers of the first and last
pixel in the vector.</li>
<li><strong>npix</strong> (<em>int</em>) – Number of pixels in the vector.</li>
<li><strong>log</strong> (<em>bool</em>) – (<strong>Optional</strong>) The input range is (to be)
logarithmically sampled.</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) The base of the logarithmic
sampling.  The default is 10.0; use numpy.exp(1.) for the
natural logarithm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A vector with the (npix+1) borders of the
pixels and the sampling rate.  If logarithmically binned, the
sampling is the step in :math`log x`.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray, float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.angstroms_per_pixel">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">angstroms_per_pixel</code><span class="sig-paren">(</span><em>wave</em>, <em>log=False</em>, <em>base=10.0</em>, <em>regular=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#angstroms_per_pixel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.angstroms_per_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector with the angstroms per pixel at each channel.</p>
<p>When <cite>regular=True</cite>, the function assumes that the wavelengths are
either sampled linearly or geometrically.  Otherwise, it calculates
the size of each pixel as the difference between the wavelength
coordinates.  The first and last pixels are assumed to have a width
as determined by assuming the coordinate is at it’s center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wave</strong> (<em>numpy.ndarray</em>) – (Geometric) centers of the spectrum pixels
in angstroms.</li>
<li><strong>log</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) The vector is geometrically
sampled.</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) Base of the logarithm used in the
geometric sampling.</li>
<li><strong>regular</strong> (<em>bool</em>) – (<strong>Optional</strong>) The vector is regularly sampled.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The angstroms per pixel.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="mangadap.util.instrument.convolution_integral_element">
<em class="property">class </em><code class="descclassname">mangadap.util.instrument.</code><code class="descname">convolution_integral_element</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#convolution_integral_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Support class for variable sigma convolution.  See
<a class="reference internal" href="#mangadap.util.instrument.convolution_variable_sigma" title="mangadap.util.instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</p>
<p>OUT OF DATE; DO NOT USE</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.ndarray</em>) – Vector to convolve</li>
<li><strong>sigma</strong> (<em>numpy.ndarray</em>) – Coordinate-dependent standard deviation of the
Gaussian kernel</li>
<li><strong>ye</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) Error in the vector to
convolve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if <em>y</em> is not a 1D vector, or if the shape of
<em>y</em> and <em>sigma</em> (and <em>ye</em> if provided) are different.</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="mangadap.util.instrument.convolution_integral_element.x">
<code class="descname">x</code><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.x" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Pixel coordinate vector</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.convolution_integral_element.y">
<code class="descname">y</code><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.y" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Vector to convolve</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.convolution_integral_element.ye">
<code class="descname">ye</code><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.ye" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Error in the vector to convolve</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.convolution_integral_element.sigma">
<code class="descname">sigma</code><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Coordinate-dependent standard deviation of the
Gaussian kernel</p>
</dd></dl>

<dl class="attribute">
<dt id="mangadap.util.instrument.convolution_integral_element.norm">
<code class="descname">norm</code><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.norm" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – Gaussian normalization; calculated once for
efficiency</p>
</dd></dl>

<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Allow to switch to pixel sampled Gaussian kernel?</li>
</ul>
</div>
<dl class="method">
<dt id="mangadap.util.instrument.convolution_integral_element._get_kernel">
<code class="descname">_get_kernel</code><span class="sig-paren">(</span><em>xc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#convolution_integral_element._get_kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element._get_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the kernel vector when centered at <em>xc</em>.</p>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Function is about 30% slower when using erf() as opposed
to exp().  erf() needed when sigma is small, but may be
efficient to include some decision on when it’s safe to
use the quick way.</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="mangadap.util.instrument.convolution_integral_element.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>xc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#convolution_integral_element.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.convolution_integral_element.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the error in the weighted mean of <a class="reference internal" href="#mangadap.util.instrument.convolution_integral_element.y" title="mangadap.util.instrument.convolution_integral_element.y"><code class="xref py py-attr docutils literal"><span class="pre">y</span></code></a> using
nominal error propagation.  The weights are defined by a
Gaussian with standard deviation <a class="reference internal" href="#mangadap.util.instrument.convolution_integral_element.sigma" title="mangadap.util.instrument.convolution_integral_element.sigma"><code class="xref py py-attr docutils literal"><span class="pre">sigma</span></code></a> and centered at
xc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xc</strong> (<em>float</em>) – Center for the Gaussian weighting function</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The error in the weighted mean of <a class="reference internal" href="#mangadap.util.instrument.convolution_integral_element.y" title="mangadap.util.instrument.convolution_integral_element.y"><code class="xref py py-attr docutils literal"><span class="pre">y</span></code></a></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.convolution_variable_sigma">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">convolution_variable_sigma</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em>, <em>integral=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#convolution_variable_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.convolution_variable_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve a discretely sampled function <span class="math">\(y(x)\)</span> with a Gaussian
kernel, <span class="math">\(g\)</span>, where the standard deviation of the kernel is a
function of <span class="math">\(x\)</span>, <span class="math">\(\sigma(x)\)</span>.  Nominal calculations can
be performed to propagate the error in the result; these
calculations <strong>do not</strong> include the covariance between the pixels,
which will mean that the calculations likely have significant error!</p>
<p>The convolution is defined as:</p>
<div class="math">
\[\begin{split}(y\ast g)(x) &amp;= \int_{-\infty}^{\infty} y(X)\ g(\sigma,x-X)\ dX \\
             &amp;= \int_{-\infty}^{\infty} \frac{y(X)}{\sqrt{2\pi}\
                \sigma(X)}\ \exp\left(-\frac{(x-X)^2}{2\
                \sigma(X)^2}\right) dX .\end{split}\]</div>
<p>To minimize edge effects and account for the censoring of the data
(finite range in <span class="math">\(x\)</span>), the convolution is actually calculated
as a definite integral and normalized as follows:</p>
<div class="math">
\[(y\ast g)(x) \sim\frac{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)} y(X)\
g(\sigma,x-X)\ dX}{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)}
g(\sigma,x-X)\ dX} .\]</div>
<p>The above is identical to getting the weighted mean of <span class="math">\(y\)</span> at
each position <span class="math">\(x\)</span>, where the weights are defined by a Gaussian
kernel centered at <span class="math">\(x\)</span> with a variable dispersion.</p>
<dl class="docutils">
<dt>Use of this function requires:</dt>
<dd><ul class="first last simple">
<li><em>y</em> and <em>sigma</em> must be 1D vectors</li>
<li><em>y</em> and <em>sigma</em> must be uniformly sampled on the same grid</li>
<li><em>sigma</em> must be in pixel units.</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.ndarray</em>) – A uniformly sampled function to convolve.</li>
<li><strong>sigma</strong> (<em>numpy.ndarray</em>) – The standard deviation of the Gaussian
kernel sampled at the same positions as <em>y</em>.  The units of
<em>sigma</em> <strong>must</strong> be in pixels.</li>
<li><strong>ye</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) Errors in the function
<span class="math">\(y(x)\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Arrays with the convolved function <span class="math">\((y\ast
g)(x)\)</span> sampled at the same positions as the input <span class="math">\(x\)</span>
vector and its error.  The second array will be returned as None
if the error vector is not provided.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.match_spectral_resolution">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">match_spectral_resolution</code><span class="sig-paren">(</span><em>wave</em>, <em>flux</em>, <em>sres</em>, <em>new_sres_wave</em>, <em>new_sres</em>, <em>ivar=None</em>, <em>mask=None</em>, <em>min_sig_pix=0.0</em>, <em>no_offset=True</em>, <em>variable_offset=False</em>, <em>log10=False</em>, <em>new_log10=False</em>, <em>integral=True</em>, <em>quiet=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#match_spectral_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.match_spectral_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the existing spectral resolution of a spectrum to a <strong>lower</strong>
resolution as best as possible.  The primary functionality is in
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution" title="mangadap.util.instrument.SpectralResolution"><code class="xref py py-class docutils literal"><span class="pre">SpectralResolution</span></code></a>, which determines the Gaussian kernel
parameters needed to match the resolution, and
<code class="xref py py-func docutils literal"><span class="pre">convolve_variable_sigma()</span></code>, which actually performs the
convolution to match the resolution.</p>
<p>In particular, see
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">SpectralResolution.GaussianKernelDifference()</span></code></a> for a
description of how the kernel parameters are determined and how
regions where the target resolution is <strong>higher</strong> than the existing
resolution.  In this case, one of the options is to adopt an offset
of the resolution (in km/s) that could be corrected for in
subsequent analysis.  In this case, setting <em>variable_offset</em> to
True allows the offset to be different for all input spectra.  If
one expects to combine the spectra, the default behavior should be
used, forcing all the spectra to have a constant offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wave</strong> (<em>numpy.ndarray</em>) – A 1D or 2D (<span class="math">\(N_{\rm spec}\times
N_{\rm pix}\)</span>) array with the wavelength in angstroms for a
set of spectra.  The sampling may be either in linear steps
of wavelength or <span class="math">\(\log_{10}\)</span> steps, as set using
<em>log10</em>.</li>
<li><strong>flux</strong> (<em>numpy.ndarray</em>) – A 1D or 2D (<span class="math">\(N_{\rm spec}\times
N_{\rm pix}\)</span>) array with the flux sampled at the provided
wavelengths.</li>
<li><strong>sres</strong> (<em>numpy.ndarray</em>) – A 1D or 2D (<span class="math">\(N_{\rm spec}\times
N_{\rm pix}\)</span>) array with the spectral resolution, <span class="math">\(R\)</span>,
at the provided wavelengths.</li>
<li><strong>new_sres_wave</strong> (<em>numpy.ndarray</em>) – A 1D vector with the wavelength
in angstroms at which the new resolution of the input
spectra has been sampled.  The sampling may be either in
linear steps of wavelength or <span class="math">\(\log_{10}\)</span> steps, as
set using <em>new_log10</em>.</li>
<li><strong>new_sres</strong> (<em>numpy.ndarray</em>) – A 1D vector with the new resolution
for the input spectra.</li>
<li><strong>ivar</strong> (<em>numpy.ndarray</em>) – <p>(<strong>Optional</strong>) A 1D or 2D (<span class="math">\(N_{\rm
spec}\times N_{\rm pix}\)</span>) array with the inverse variance of
the flux sampled at the provided wavelengths.  This vector
is used to estimate the noise in the resolution-matched
spectra.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The accuracy of the errors still remain untested!</p>
</div>
</li>
<li><strong>mask</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) A 1D or 2D (<span class="math">\(N_{\rm
spec}\times N_{\rm pix}\)</span>) array with a <em>uint</em> mask for the
flux sampled at the provided wavelengths.</li>
<li><strong>no_offset</strong> (<em>bool</em>) – (<strong>Optional</strong>) Force <span class="math">\(\sigma^2_{v,o} =
0\)</span> by masking regions with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span>; i.e., the value of this arguments selects
Option 1 (True) or Option 2 (False).  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">SpectralResolution.GaussianKernelDifference()</span></code></a>.</li>
<li><strong>min_sig_pix</strong> (<em>float</em>) – (<strong>Optional</strong>) Minimum value of the
standard deviation in pixels allowed before assuming the
kernel is a Delta function.</li>
<li><strong>variable_offset</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag to allow the offset
applied to each spectrum (when the input contains more than
one spectraum) to be tailored to each spectrum.  Otherwise
(<em>variable_offset=False</em>) the offset is forced to be the
same for all spectra.</li>
<li><strong>log10</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag that the spectrum has been
binned logarithmically (base 10) in wavelength</li>
<li><strong>new_log10</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag that the coordinates of
the new spectral resolution are  spectrum as been binned
logarithmically (base 10) in wavelength.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>Five objects are returned:</p>
<blockquote>
<div><ul class="simple">
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the resolution-matched flux sampled at the input
wavelengths.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the spectral resolution, <span class="math">\(R\)</span>, of the
resolution-matched spectra at the provided wavelengths.</li>
<li>A 1D vector with any constant offset in resolution <strong>in
km/s</strong> between the targetted value and the result.  See
<a class="reference internal" href="#mangadap.util.instrument.SpectralResolution.GaussianKernelDifference" title="mangadap.util.instrument.SpectralResolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">SpectralResolution.GaussianKernelDifference()</span></code></a>.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with a <em>uint</em> mask for the resolution-matched flux sampled
at the input wavelengths.  This is returned regardless of
whether an input mask was provided.  Any pixel that had a
resolution that was lower than the target resolution (up
to some tolerance defined by <em>min_sig_pix</em>) is returned as
masked.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the inverse variance of the resolution-matched flux
sampled at the input wavelengths.  If <em>ivar</em>
is not provided, a ‘None’ returned as the last element</li>
</ul>
</div></blockquote>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">numpy.ndarray</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if:</p>
<ul class="last simple">
<li>the input <em>wave</em> array is 2D and the <em>sres</em> array is not;
a 1D wavelength array is allowed for a 2D <em>sres</em> array but
not vice versa</li>
<li>the number of spectral pixels in <em>wave</em>, <em>flux</em>, and
<em>sres</em> is not the same</li>
<li>the shape of the <em>flux</em>, <em>mask</em> (if provided), and <em>ivar</em>
(if provided) are not the same</li>
<li>the shape of the <em>new_sres_wave</em> and <em>new_sres</em> arrays
are not the same and/or not 1D</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-5">
<p class="first admonition-title">Todo</p>
<ul class="last simple">
<li>Add interp_ext != ‘extrapolate’ option?</li>
<li>Better way to use warnings?</li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.resample1d">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">resample1d</code><span class="sig-paren">(</span><em>y</em>, <em>x=None</em>, <em>xRange=None</em>, <em>inLog=False</em>, <em>newRange=None</em>, <em>newpix=None</em>, <em>newLog=True</em>, <em>newdx=None</em>, <em>base=10.0</em>, <em>ext_value=0.0</em>, <em>conserve=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#resample1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.resample1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample regularly or irregularly sampled, 1-dimensional data to a
new grid using integration.</p>
<p>This is basically a generalization of the routine <code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code>
provided by Michele Cappellari in the pPXF package.</p>
<p>The abscissa coordinates (<cite>x</cite>) for the data (<cite>y</cite>) should be provided
for irregularly sampled data.  If the input data is linearly or
geometrically sampled (<cite>inLog=True</cite>), the abscissa coordinates can
can be generated using the input range for the (geometric) center of
each grid point.  If neither <cite>x</cite> nor <cite>xRange</cite> are provided, the
function assumes grid coordinates of <cite>x=numpy.arange(y.size)</cite>.</p>
<p>The function resamples the data by constructing the borders of the
output grid using the <cite>new*</cite> keywords and integrating the input
function between those borders.  The output data will be set to
<cite>ext_value</cite> for any data beyond the abscissa limits of the input
data.</p>
<p>The <cite>conserve</cite> keyword sets how the units of the input data should
be treated.  If <cite>conserve=False</cite>, the input data are expected to be
in units such that the integral over <span class="math">\(dx\)</span> is independent of
the units of <span class="math">\(x\)</span> (i.e., flux per unit angstrom, or flux
density).  If <cite>conserve=True</cite>, the value of the data is assumed to
have been integrated over the size of each pixel (i.e., units of
flux).  If <cite>conserve=True</cite>, <span class="math">\(y\)</span> is converted to units of per
step in <span class="math">\(x\)</span> such that the integral before and after the
resample is the same.  For example, if <span class="math">\(y\)</span> is a spectrum in
units of flux, the function first converts the units to flux density
and then computes the integral over each new pixel to produce the
new spectra with units of flux.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.ndarray</em>) – Data values to resample.  Must be 1-D.</li>
<li><strong>x</strong> (<em>numpy.ndarray</em>) – (<strong>Optional</strong>) Abcissa coordinates for the
data, which do not need to be regularly sampled.  If not
provided, the <cite>xRange</cite>, which is <cite>[0,y.size-1]</cite> by default.</li>
<li><strong>xRange</strong> (<em>array</em>) – (<strong>Optional</strong>) A two-element array with the
starting and ending value for the coordinates of the centers
of the first and last pixels in y.  Default is
<cite>[0,y.size-1]</cite>.</li>
<li><strong>inLog</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag that the input vector is
logarithmically spaced within xRange.  Cannot be used if
xRange is not provided!</li>
<li><strong>newRange</strong> (<em>array</em>) – (<strong>Optional</strong>) Coordinates for the (geometric)
centers of the first and last pixel in the output vector.
If not provided, assumed to be the same as the input range.</li>
<li><strong>newpix</strong> (<em>int</em>) – (<strong>Optional</strong>) Number of pixels for the output
vector.  If not provided, assumed to be the same as the
input vector.</li>
<li><strong>newLog</strong> (<em>bool</em>) – (<strong>Optional</strong>) The output vector should be
logarithmically binned.</li>
<li><strong>newdx</strong> (<em>float</em>) – (<strong>Optional</strong>) The sampling step for the output
vector.  If <cite>newLog=True</cite>, this has to be the change in
the logarithm of x for the output vector!  If not provided,
the sampling is set by the output range (see <em>newRange</em>
above) and number of pixels (see <em>newpix</em> above).</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) When logarithmically binning the
output vector, use this as the base.  The default is 10;
use <cite>numpy.exp(1)</cite> for natural logarithm.</li>
<li><strong>ext_value</strong> (<em>float</em>) – (<strong>Optional</strong>) Set extrapolated values to the
provided float.  By default, extrapolated values are set to
0.  If set to None, values are just set to the linear
exatrapolation of the data beyond the provided limits; use
<cite>ext_value=None</cite> with caution!</li>
<li><strong>conserve</strong> (<em>bool</em>) – (<strong>Optional</strong>) Conserve the integral of the
input vector.  For example, if the input vector is a
spectrum in flux units, you should conserve the flux in the
resampling; if the spectrum is in units of flux density, you
do not want to conserve the integral.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two numpy arrays with the new x and y values for
the resampled data.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">numpy.ndarray</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if <em>y</em> is not of type numpy.ndarray, if <em>y</em>
is not one-dimensional, or if <em>xRange</em> is not provided and
the input vector is logarithmically binned (see <em>inLog</em>
above).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.resample_vector">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">resample_vector</code><span class="sig-paren">(</span><em>y</em>, <em>xRange=None</em>, <em>inLog=False</em>, <em>newRange=None</em>, <em>newpix=None</em>, <em>newLog=True</em>, <em>dx=None</em>, <em>base=10.0</em>, <em>ext_value=0.0</em>, <em>conserve=False</em>, <em>flat=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#resample_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.resample_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the provided vector to a new grid using integration.</p>
<p>This is a generalization of the routine <code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code> provided
by Michele Cappellari in the pPXF package.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>numpy.ndarray</em>) – Vector to resample.  Must be 1-D.</li>
<li><strong>xRange</strong> (<em>array</em>) – (<strong>Optional</strong>) A two-element array with the
starting and ending value for the coordinates of the centers
of the first and last pixels in y.  If not provided, the
pixel coordinates are used; i.e., xRange = [0,y.size-1].</li>
<li><strong>inLog</strong> (<em>bool</em>) – (<strong>Optional</strong>) Flag that the input vector is
logarithmically spaced within xRange.  Cannot be used if
xRange is not provided!</li>
<li><strong>newRange</strong> (<em>array</em>) – (<strong>Optional</strong>) Coordinates for the centers of
the first and last pixel in the output vector.  If not
provided, assumed to be the same as the input range.</li>
<li><strong>newpix</strong> (<em>int</em>) – (<strong>Optional</strong>) Number of pixels for the output
vector.  If not provided, assumed to be the same as the
input vector.</li>
<li><strong>newLog</strong> (<em>bool</em>) – (<strong>Optional</strong>) The output vector should be
logarithmically binned in the x-coordinates.</li>
<li><strong>dx</strong> (<em>float</em>) – (<strong>Optional</strong>) The sampling step for the output
vector.  If <em>newLog</em> is True, this has to be the change in
the logarithm of x for the output vector!  If not provided,
the sampling is set by the output range (see <em>newRange</em>
above) and number of pixels (see <em>newpix</em> above).</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) When logarithmically binning the
output vector, use this as the base.  The default is 10.0;
use numpy.exp(1) for natural logarithm.</li>
<li><strong>ext_value</strong> (<em>float</em>) – (<strong>Optional</strong>) Set extrapolated values to the
provided float.</li>
<li><strong>conserve</strong> (<em>bool</em>) – (<strong>Optional</strong>) Conserve the integral of the
input vector.  For example, if the input vector is a
spectrum in flux units, you should conserve the flux in the
resampling; if the spectrum is in units of flux density, you
do not want to conserve the integral.</li>
<li><strong>flat</strong> (<em>bool</em>) – (<strong>Optional</strong>) Assume the ‘true’ y function is flat
across a pixel, as is done in M. Cappellari’s log_rebin
routine; this is the default behavior.  If set to False, the
integration follows a basic linear interpolation across the
pixel.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two numpy arrays with the new x coordinates and
new y values for the resampled vector.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">numpy.ndarray</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if <em>y</em> is not of type numpy.ndarray, if <em>y</em>
is not one-dimensional, or if <em>xRange</em> is not provided and
the input vector is logarithmically binned (see <em>inLog</em>
above).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.resample_vector_npix">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">resample_vector_npix</code><span class="sig-paren">(</span><em>outRange=None</em>, <em>dx=None</em>, <em>log=False</em>, <em>base=10.0</em>, <em>default=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#resample_vector_npix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.resample_vector_npix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the number of pixels needed to resample the vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outRange</strong> (<em>list</em><em> or </em><em>numpy.ndarray</em>) – Two-element array with the
starting and ending x coordinate of the pixel centers to
divide into pixels of a given width.  If <em>log</em> is True, this
must still be the linear value of the x coordinate, not
log(x)!.</li>
<li><strong>dx</strong> (<em>float</em>) – Linear or logarithmic pixel width.</li>
<li><strong>log</strong> (<em>bool</em>) – Flag that the range should be logarithmically
binned.</li>
<li><strong>base</strong> (<em>float</em>) – Base for the logarithm</li>
<li><strong>default</strong> (<em>int</em>) – Default number of pixels to use.  The default is
returned if either <em>outRange</em> or <em>dx</em> are not provided.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns two objects: The number of pixels to
cover <em>outRange</em> with pixels of width <em>dx</em> and the adjusted
range such that number of pixels of size dx is the exact integer.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">int, numpy.ndarray</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> – Raised if the range is not a two-element vector</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.spectral_coordinate_step">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">spectral_coordinate_step</code><span class="sig-paren">(</span><em>wave</em>, <em>log=False</em>, <em>base=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#spectral_coordinate_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.spectral_coordinate_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sampling step for the input wavelength vector.</p>
<p>If the sampling is logarithmic, return the change in the logarithm
of the wavelength; otherwise, return the linear step in angstroms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wave</strong> (<em>numpy.ndarray</em>) – Wavelength coordinates of each spectral
channel in angstroms.</li>
<li><strong>log</strong> (<em>bool</em>) – (<strong>Optional</strong>) Input spectrum has been sampled
geometrically.</li>
<li><strong>base</strong> (<em>float</em>) – (<strong>Optional</strong>) If sampled geometrically, the
sampling is done using a logarithm with this base.  For
natural logarithm, use numpy.exp(1).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Spectral sampling step in either angstroms (log=False) or
the step in log(angstroms).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mangadap.util.instrument.spectrum_velocity_scale">
<code class="descclassname">mangadap.util.instrument.</code><code class="descname">spectrum_velocity_scale</code><span class="sig-paren">(</span><em>wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mangadap/util/instrument.html#spectrum_velocity_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mangadap.util.instrument.spectrum_velocity_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the velocity sampling of an input wavelength coordinate
vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The wavelength vector is assumed to be geometrically sampled!
However, the input units expected to be in angstroms, not, e.g.,
log(angstrom).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wave</strong> (<em>numpy.ndarray</em>) – Wavelength coordinates of each spectral
channel in angstroms.  It is expected that the spectrum has
been sampled geometrically</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Velocity scale of the spectrum in km/s.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mangadap.util.lineprofiles.html" class="btn btn-neutral float-right" title="mangadap.util.lineprofiles module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mangadap.util.geometry.html" class="btn btn-neutral" title="mangadap.util.geometry module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>