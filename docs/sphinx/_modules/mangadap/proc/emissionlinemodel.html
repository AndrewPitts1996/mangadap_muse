

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.emissionlinemodel &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.emissionlinemodel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.emissionlinemodel</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A class hierarchy that fits the emission lines.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/emissionlinefits.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>
<span class="sd">        </span>
<span class="sd">        import glob</span>
<span class="sd">        import os</span>
<span class="sd">        import logging</span>
<span class="sd">        </span>
<span class="sd">        import numpy</span>
<span class="sd">        from astropy.io import fits</span>
<span class="sd">        </span>
<span class="sd">        from ..drpfits import DRPFits</span>
<span class="sd">        from ..par.parset import ParSet</span>
<span class="sd">        from ..par.artifactdb import ArtifactDB</span>
<span class="sd">        from ..par.emissionlinedb import EmissionLineDB</span>
<span class="sd">        from ..config.defaults import default_dap_source, default_dap_file_name</span>
<span class="sd">        from ..config.defaults import default_dap_method, default_dap_method_path</span>
<span class="sd">        from ..util.fitsutil import DAPFitsUtil</span>
<span class="sd">        from ..util.fileio import init_record_array, rec_to_fits_type, rec_to_fits_col_dim</span>
<span class="sd">        from ..util.bitmask import BitMask</span>
<span class="sd">        from ..util.pixelmask import SpectralPixelMask</span>
<span class="sd">        from ..util.log import log_output</span>
<span class="sd">        from .spatiallybinnedspectra import SpatiallyBinnedSpectra</span>
<span class="sd">        from .stellarcontinuummodel import StellarContinuumModel</span>
<span class="sd">        from .elric import Elric, ElricPar, GaussianLineProfile</span>
<span class="sd">        from .util import select_proc_method</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">    Add examples!</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **26 Apr 2016**: Implementation begun by K. Westfall (KBW)</span>
<span class="sd">    | **28 Jul 2016**: (KBW) Fixed error in initialization of guess</span>
<span class="sd">        redshift when stellar continuum is provided.</span>
<span class="sd">    | **23 Feb 2017**: (KBW) Use DAPFitsUtil read and write functions.</span>
<span class="sd">    | **31 May 2017**: (KBW) Revert to using</span>
<span class="sd">        :class:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel`</span>
<span class="sd">        on input</span>
<span class="sd">    | **08 Sep 2017**: (KBW) Add `deconstruct_bins` flag to parameters.</span>
<span class="sd">    | **02 Feb 2018**: (KBW) Use</span>
<span class="sd">        :func:`mangadap.proc.spectralfitting.EmissionLineFit.select_binned_spectra_to_fit`.</span>
<span class="sd">    | **15 Feb 2018**: (KBW) No longer imports</span>
<span class="sd">        :class:`mangadap.proc.emissionlinemoments.EmissionLineMoments`</span>
<span class="sd">        to avoid circular imports (this should be coded better...)</span>
<span class="sd">    | **24 Feb 2018**: (KBW) Added keyword for a new template library</span>
<span class="sd">        that can be used instead of the same templates used during the</span>
<span class="sd">        stellar-continuum fit.</span>
<span class="sd">    </span>
<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _logging.Logger: https://docs.python.org/3/library/logging.html</span>
<span class="sd">.. _numpy.ma.MaskedArray: http://docs.scipy.org/doc/numpy-1.10.1/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>

<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">..drpfits</span> <span class="k">import</span> <span class="n">DRPFits</span>
<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..par.artifactdb</span> <span class="k">import</span> <span class="n">ArtifactDB</span>
<span class="kn">from</span> <span class="nn">..par.emissionlinedb</span> <span class="k">import</span> <span class="n">EmissionLineDB</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_source</span><span class="p">,</span> <span class="n">default_dap_file_name</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_method</span><span class="p">,</span> <span class="n">default_dap_method_path</span>
<span class="kn">from</span> <span class="nn">..util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span><span class="p">,</span> <span class="n">rec_to_fits_type</span><span class="p">,</span> <span class="n">rec_to_fits_col_dim</span>
<span class="kn">from</span> <span class="nn">..util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.parser</span> <span class="k">import</span> <span class="n">DefaultConfig</span>
<span class="kn">from</span> <span class="nn">.spatiallybinnedspectra</span> <span class="k">import</span> <span class="n">SpatiallyBinnedSpectra</span>
<span class="kn">from</span> <span class="nn">.stellarcontinuummodel</span> <span class="k">import</span> <span class="n">StellarContinuumModel</span>
<span class="c1">#from .emissionlinemoments import EmissionLineMoments</span>
<span class="kn">from</span> <span class="nn">.bandpassfilter</span> <span class="k">import</span> <span class="n">emission_line_equivalent_width</span>
<span class="kn">from</span> <span class="nn">.elric</span> <span class="k">import</span> <span class="n">Elric</span><span class="p">,</span> <span class="n">ElricPar</span>
<span class="kn">from</span> <span class="nn">.sasuke</span> <span class="k">import</span> <span class="n">Sasuke</span><span class="p">,</span> <span class="n">SasukePar</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">select_proc_method</span><span class="p">,</span> <span class="n">replace_with_data_from_nearest_coo</span>
<span class="kn">from</span> <span class="nn">.spectralfitting</span> <span class="k">import</span> <span class="n">EmissionLineFit</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<div class="viewcode-block" id="EmissionLineModelDef"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModelDef">[docs]</a><span class="k">class</span> <span class="nc">EmissionLineModelDef</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that holds the parameters necessary to perform the</span>
<span class="sd">    emission-line profile fits.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Include waverange?</span>

<span class="sd">    Args:</span>
<span class="sd">        key (str): Keyword used to distinguish between different</span>
<span class="sd">            emission-line moment databases.</span>
<span class="sd">        minimum_snr (bool): Minimum S/N of spectrum to fit</span>
<span class="sd">        artifacts (str): String identifying the artifact database to use</span>
<span class="sd">        emission_lines (str): String identifying the emission-line</span>
<span class="sd">            database to use</span>
<span class="sd">        continuum_tpl_key (str): String identifying the continuum</span>
<span class="sd">            templates to use</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">deconstruct_bins</span><span class="p">,</span> <span class="n">mom_vel_name</span><span class="p">,</span> <span class="n">mom_disp_name</span><span class="p">,</span>
                 <span class="n">artifacts</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">continuum_tpl_key</span><span class="p">,</span> <span class="n">fitpar</span><span class="p">,</span> <span class="n">fitclass</span><span class="p">,</span> <span class="n">fitfunc</span><span class="p">):</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        <span class="n">par_opt</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ParSet</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">,</span> <span class="s1">&#39;mom_vel_name&#39;</span><span class="p">,</span> <span class="s1">&#39;mom_disp_name&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;emission_lines&#39;</span><span class="p">,</span> <span class="s1">&#39;continuum_tpl_key&#39;</span><span class="p">,</span> <span class="s1">&#39;fitpar&#39;</span><span class="p">,</span> <span class="s1">&#39;fitclass&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;fitfunc&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">key</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">deconstruct_bins</span><span class="p">,</span> <span class="n">mom_vel_name</span><span class="p">,</span> <span class="n">mom_disp_name</span><span class="p">,</span> <span class="n">artifacts</span><span class="p">,</span>
                     <span class="n">emission_lines</span><span class="p">,</span> <span class="n">continuum_tpl_key</span><span class="p">,</span> <span class="n">fitpar</span><span class="p">,</span> <span class="n">fitclass</span><span class="p">,</span> <span class="n">fitfunc</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">par_opt</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
        <span class="n">can_call</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span></div>


<div class="viewcode-block" id="validate_emission_line_modeling_method_config"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.validate_emission_line_modeling_method_config">[docs]</a><span class="k">def</span> <span class="nf">validate_emission_line_modeling_method_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Validate the :class:`mangadap.util.parser.DefaultConfig` with the</span>
<span class="sd">    emission-line modeling method parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        cnfg (:class:`mangadap.util.parser.DefaultConfig`): Object meant</span>
<span class="sd">            to contain defining parameters of the emission-line modeling</span>
<span class="sd">            method needed by :class:`EmissionLineModelDef`</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: Raised if any required keywords do not exist.</span>
<span class="sd">        ValueError: Raised if keys have unacceptable values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for required keywords</span>
    <span class="k">if</span> <span class="s1">&#39;key&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cnfg</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keyword </span><span class="se">\&#39;</span><span class="s1">key</span><span class="se">\&#39;</span><span class="s1"> must be provided.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="available_emission_line_modeling_methods"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.available_emission_line_modeling_methods">[docs]</a><span class="k">def</span> <span class="nf">available_emission_line_modeling_methods</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the list of available emission-line modeling methods.</span>

<span class="sd">    Available methods are:</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Fill in</span>

<span class="sd">    Args:</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_source`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of :func:`EmissionLineModelDef` objects, each</span>
<span class="sd">        defining an emission-line modeling method.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotADirectoryError: Raised if the provided or default</span>
<span class="sd">            *dapsrc* is not a directory.</span>
<span class="sd">        OSError/IOError: Raised if no emission-line moment configuration</span>
<span class="sd">            files could be found.</span>
<span class="sd">        KeyError: Raised if the emission-line modeling method keywords</span>
<span class="sd">            are not all unique.</span>
<span class="sd">        NotImplementedError: Raised if the method requests the</span>
<span class="sd">            deconstruction of the bins into spaxls for using the Elric</span>
<span class="sd">            fitter.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Possible to add a python call that reads the databases and</span>
<span class="sd">        constructs the table for presentation in sphinx so that the text</span>
<span class="sd">        above doesn&#39;t have to be edited with changes in the available</span>
<span class="sd">        databases?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the source directory exists</span>
    <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotADirectoryError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> does not exist!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">))</span>

    <span class="c1"># Check the configuration files exist</span>
    <span class="n">search_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python/mangadap/config/emission_line_modeling&#39;</span><span class="p">)</span>
    <span class="n">ini_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">search_dir</span><span class="p">,</span> <span class="s1">&#39;*.ini&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ini_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Could not find any configuration files in </span><span class="si">{0}</span><span class="s1"> !&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">search_dir</span><span class="p">))</span>

    <span class="c1"># Build the list of method definitions</span>
    <span class="n">method_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ini_files</span><span class="p">:</span>
        <span class="c1"># Read the config file</span>
        <span class="n">cnfg</span> <span class="o">=</span> <span class="n">DefaultConfig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># Ensure it has the necessary elements to define the template</span>
        <span class="c1"># library</span>
        <span class="n">validate_emission_line_modeling_method_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">)</span>
        <span class="n">deconstruct_bins</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">minimum_snr</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">continuum_tpl_key</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;fit_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;elric&#39;</span><span class="p">:</span>
            <span class="c1"># Chose to use Elric: Parameter set has defaults to handle</span>
            <span class="c1"># missing or None values for baseline_order, window_buffer,</span>
            <span class="c1"># and minimum_snr</span>
            <span class="k">if</span> <span class="n">deconstruct_bins</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;When using Elric, cannot deconstruct bins into spaxels.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">continuum_tpl_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;When using Elric, cannot change continuum templates.&#39;</span><span class="p">)</span>

            <span class="n">fitpar</span> <span class="o">=</span> <span class="n">ElricPar</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;baseline_order&#39;</span><span class="p">),</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;window_buffer&#39;</span><span class="p">),</span>
                              <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="n">minimum_snr</span><span class="p">)</span>
            <span class="n">fitclass</span> <span class="o">=</span> <span class="n">Elric</span><span class="p">(</span><span class="n">EmissionLineModelBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">))</span>
            <span class="n">fitfunc</span> <span class="o">=</span> <span class="n">fitclass</span><span class="o">.</span><span class="n">fit_SpatiallyBinnedSpectra</span>

        <span class="k">elif</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;fit_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sasuke&#39;</span><span class="p">:</span>
            <span class="c1"># Chose to use Sasuke: Parameter set has defaults to handle</span>
            <span class="c1"># missing or None values for reject_boxcar, bias, moments,</span>
            <span class="c1"># degree, mdegree; if provided new continuum templates are</span>
            <span class="c1"># constructed during the _fill_method_par call.</span>
            <span class="n">fitpar</span> <span class="o">=</span> <span class="n">SasukePar</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">continuum_templates</span><span class="o">=</span><span class="n">continuum_tpl_key</span><span class="p">,</span>
                               <span class="n">etpl_line_sigma_mode</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;etpl_line_sigma_mode&#39;</span><span class="p">),</span>
                               <span class="n">etpl_line_sigma_min</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;etpl_line_sigma_min&#39;</span><span class="p">),</span>
                               <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;velscale_ratio&#39;</span><span class="p">),</span>
                               <span class="n">guess_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="n">minimum_snr</span><span class="p">,</span>
                               <span class="n">deconstruct_bins</span><span class="o">=</span><span class="n">deconstruct_bins</span><span class="p">,</span> <span class="n">pixelmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">),</span>
                               <span class="n">bias</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;bias&#39;</span><span class="p">),</span> <span class="n">moments</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;moments&#39;</span><span class="p">),</span>
                               <span class="n">degree</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;degree&#39;</span><span class="p">),</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;mdegree&#39;</span><span class="p">),</span>
                               <span class="n">reddening</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;internal_reddening&#39;</span><span class="p">))</span>
            <span class="n">fitclass</span> <span class="o">=</span> <span class="n">Sasuke</span><span class="p">(</span><span class="n">EmissionLineModelBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">))</span>
            <span class="n">fitfunc</span> <span class="o">=</span> <span class="n">fitclass</span><span class="o">.</span><span class="n">fit_SpatiallyBinnedSpectra</span>

        <span class="n">method_list</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">EmissionLineModelDef</span><span class="p">(</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">deconstruct_bins</span><span class="p">,</span>
                                              <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">),</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">),</span>
                                              <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;artifact_mask&#39;</span><span class="p">),</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span>
                                              <span class="n">continuum_tpl_key</span><span class="p">,</span> <span class="n">fitpar</span><span class="p">,</span> <span class="n">fitclass</span><span class="p">,</span> <span class="n">fitfunc</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Check the keywords of the libraries are all unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">method_list</span><span class="p">])))</span> \
                <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Emission-line fitting method keywords are not all unique!&#39;</span><span class="p">)</span>

    <span class="c1"># Return the default list of fitting methods</span>
    <span class="k">return</span> <span class="n">method_list</span></div>


<div class="viewcode-block" id="EmissionLineModelBitMask"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModelBitMask">[docs]</a><span class="k">class</span> <span class="nc">EmissionLineModelBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Derived class that specifies the mask bits for the emission-line</span>
<span class="sd">    modeling.  See :class:`mangadap.util.bitmask.BitMask` for</span>
<span class="sd">    attributes.</span>

<span class="sd">    A list of the bits and meanings are provided by the base class</span>
<span class="sd">    function :func:`mangadap.util.bitmask.BitMask.info`; i.e.,::</span>

<span class="sd">        from mangadap.proc.emissionlinemodel import EmissionLineModelBitMask</span>
<span class="sd">        bm = EmissionLineModelBitMask()</span>
<span class="sd">        bm.info()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;mangadap&#39;</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">,</span>
                                                     <span class="s1">&#39;bitmasks&#39;</span><span class="p">,</span> <span class="s1">&#39;emission_line_model_bits.ini&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="EmissionLineModel"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel">[docs]</a><span class="k">class</span> <span class="nc">EmissionLineModel</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that holds the emission-line model fits.</span>

<span class="sd">    Args:</span>
<span class="sd">        loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">            to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">            using :func:`mangadap.util.log.log_output`.  Default is no</span>
<span class="sd">            logging.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress all terminal and logging</span>
<span class="sd">            output.  Default is False.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        loggers (list): List of `logging.Logger`_ objects to log</span>
<span class="sd">            progress; ignored if quiet=True.  Logging is done using</span>
<span class="sd">            :func:`mangadap.util.log.log_output`.</span>
<span class="sd">        quiet (bool): Suppress all terminal and logging output.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    @profile</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_key</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">emission_line_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">method_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">artifact_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emission_line_db_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Define the database properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artdb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_define_method</span><span class="p">(</span><span class="n">method_key</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="n">method_list</span><span class="p">,</span> <span class="n">artifact_list</span><span class="o">=</span><span class="n">artifact_list</span><span class="p">,</span>
                            <span class="n">emission_line_db_list</span><span class="o">=</span><span class="n">emission_line_db_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Define the output directory and file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># Set in _set_paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize the objects used in the assessments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">EmissionLineModelBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#       nspec is never used and it won&#39;t be correct if the bins are</span>
<span class="c1">#       deconstructed.</span>
<span class="c1">#        self.nspec = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_spectral_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_image_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Fit the binned spectra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="n">stellar_continuum</span><span class="p">,</span>
                 <span class="n">emission_line_moments</span><span class="o">=</span><span class="n">emission_line_moments</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                 <span class="n">dispersion</span><span class="o">=</span><span class="n">dispersion</span><span class="p">,</span> <span class="n">minimum_error</span><span class="o">=</span><span class="n">minimum_error</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                 <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="n">directory_path</span><span class="p">,</span>
                 <span class="n">output_file</span><span class="o">=</span><span class="n">output_file</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="n">hardcopy</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span>
                 <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


<span class="c1">#    def __del__(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Deconstruct the data object by ensuring that the fits file is</span>
<span class="c1">#        properly closed.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if self.hdu is None:</span>
<span class="c1">#            return</span>
<span class="c1">#        self.hdu.close()</span>
<span class="c1">#        self.hdu = None</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<div class="viewcode-block" id="EmissionLineModel._define_method"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._define_method">[docs]</a>    <span class="k">def</span> <span class="nf">_define_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_key</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">artifact_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">emission_line_db_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the modeling method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab the specific method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">select_proc_method</span><span class="p">(</span><span class="n">method_key</span><span class="p">,</span> <span class="n">EmissionLineModelDef</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="n">method_list</span><span class="p">,</span>
                                         <span class="n">available_func</span><span class="o">=</span><span class="n">available_emission_line_modeling_methods</span><span class="p">,</span>
                                         <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="c1"># Instantiate the artifact and emission-line databases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artdb</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="n">ArtifactDB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">],</span> <span class="n">artdb_list</span><span class="o">=</span><span class="n">artifact_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span> <span class="o">=</span> <span class="n">SpectralPixelMask</span><span class="p">(</span><span class="n">artdb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">artdb</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                        <span class="n">EmissionLineDB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span>
                                       <span class="n">emldb_list</span><span class="o">=</span><span class="n">emission_line_db_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel._set_paths"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the :attr:`directory_path` and :attr:`output_file`.  If not</span>
<span class="sd">        provided, the defaults are set using, respectively,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_method_path` and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_file_name`.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory_path (str): The exact path to the DAP</span>
<span class="sd">                emission-line moments file.  See :attr:`directory_path`.</span>
<span class="sd">            dapver (str): DAP version.</span>
<span class="sd">            analysis_path (str): The path to the top-level directory</span>
<span class="sd">                containing the DAP output files for a given DRP and DAP</span>
<span class="sd">                version.</span>
<span class="sd">            output_file (str): The name of the file with emission-line</span>
<span class="sd">                moment measurements.  See :func:`measure`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the output directory path</span>
        <span class="n">continuum_method</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="kc">None</span> \
                                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">default_dap_method</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                    <span class="n">continuum_method</span><span class="o">=</span><span class="n">continuum_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="n">default_dap_method_path</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">plate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span>
                                                      <span class="n">ifudesign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span>
                                                      <span class="n">ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span>
                                                      <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">directory_path</span><span class="p">)</span>

        <span class="c1"># Set the output file</span>
        <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">continuum_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_method</span><span class="p">,</span> <span class="n">continuum_method</span><span class="p">)</span>
        <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">default_dap_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="n">ref_method</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel._initialize_primary_header"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._initialize_primary_header">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_primary_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Initialize the header.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy the from the DRP and clean it</span>
        <span class="k">if</span> <span class="n">hdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">clean_dap_primary_header</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;AUTHOR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Kyle B. Westfall &lt;westfall@ucolick.org&gt;&#39;</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELFKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Emission-line modeling method keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELFMINSN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span> <span class="s1">&#39;Minimum S/N of spectrum to include&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ARTDB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">],</span> <span class="s1">&#39;Artifact database keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;EMLDB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="s1">&#39;Emission-line database keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SCKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Stellar-continuum model keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;NELMOD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">,</span> <span class="s1">&#39;Number of unique emission-line models&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="EmissionLineModel._emission_line_database_dtype"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._emission_line_database_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">_emission_line_database_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">mode_len</span><span class="p">,</span> <span class="n">prof_len</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the record array data type for the output fits</span>
<span class="sd">        extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NAME&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;U</span><span class="si">{0:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_len</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;RESTWAVE&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ACTION&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U1&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;FLUXRATIO&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MODE&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;U</span><span class="si">{0:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode_len</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;PROFILE&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U</span><span class="si">{0:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prof_len</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;NCOMP&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
               <span class="p">]</span></div>


<div class="viewcode-block" id="EmissionLineModel._compile_database"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._compile_database">[docs]</a>    <span class="k">def</span> <span class="nf">_compile_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the database with the specifications of each index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to use member functions of the fitting class to</span>
                <span class="c1"># set at least the NAME and RESTWAVE of the line for use</span>
                <span class="c1"># in dapfits.py</span>
                <span class="n">line_database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">line_database</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Emission-line fit did not use an EmissionLineDB object, and &#39;</span>
                                  <span class="s1">&#39;does not have a line_database() method.  Will not be able to &#39;</span>
                                  <span class="s1">&#39;use output to identify which lines were fit.&#39;</span><span class="p">)</span>
                <span class="n">line_database</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">line_database</span>

        <span class="n">name_len</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">])</span>
        <span class="n">mode_len</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="p">])</span>
        <span class="n">prof_len</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">]</span> <span class="p">])</span>

        <span class="c1"># Instatiate the table data that will be saved defining the set</span>
        <span class="c1"># of emission-line moments measured</span>
        <span class="n">line_database</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_emission_line_database_dtype</span><span class="p">(</span><span class="n">name_len</span><span class="p">,</span> <span class="n">mode_len</span><span class="p">,</span> <span class="n">prof_len</span><span class="p">))</span>

        <span class="n">hk</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="s1">&#39;NAME&#39;</span><span class="p">,</span> <span class="s1">&#39;RESTWAVE&#39;</span><span class="p">,</span> <span class="s1">&#39;ACTION&#39;</span><span class="p">,</span> <span class="s1">&#39;FLUXRATIO&#39;</span><span class="p">,</span> <span class="s1">&#39;MODE&#39;</span><span class="p">,</span> <span class="s1">&#39;PROFILE&#39;</span><span class="p">,</span> <span class="s1">&#39;NCOMP&#39;</span> <span class="p">]</span>
        <span class="n">mk</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;restwave&#39;</span><span class="p">,</span> <span class="s1">&#39;action&#39;</span><span class="p">,</span> <span class="s1">&#39;flux&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="s1">&#39;ncomp&#39;</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">_hk</span><span class="p">,</span> <span class="n">_mk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span><span class="n">mk</span><span class="p">):</span>
            <span class="n">line_database</span><span class="p">[</span><span class="n">_hk</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="n">_mk</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">line_database</span></div>


<div class="viewcode-block" id="EmissionLineModel._assign_input_kinematics"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._assign_input_kinematics">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_input_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emission_line_moments</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">,</span>
                                 <span class="n">default_dispersion</span><span class="o">=</span><span class="mf">100.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the initial redshift and velocity dispersion for each</span>
<span class="sd">        spectrum.</span>
<span class="sd">        </span>
<span class="sd">        In terms of precedence, directly provided redshifts and</span>
<span class="sd">        dispersions override those in the EmissionLineMoments model,</span>
<span class="sd">        which overrides those in the StellarContinuumModel object.  The</span>
<span class="sd">        default_dispersion does *not* take precedence over *any*</span>
<span class="sd">        provided disperison.</span>

<span class="sd">        If emission_line_moments, redshift, and</span>
<span class="sd">        :attr:`stellar_continuum` are all None, the redshift is set to</span>
<span class="sd">        0.0.  If dispersion is also None, the dispersion is set to</span>
<span class="sd">        default_dispersion.</span>

<span class="sd">        To get the stellar kinematics, the function calls</span>
<span class="sd">        :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.matched_kinematics`.</span>
<span class="sd">        In this function, the provided redshift and dispersion must be a</span>
<span class="sd">        single value or None; therefore, the means of any vectors</span>
<span class="sd">        provided as redshift or disperison are passsed to this function</span>
<span class="sd">        instead of the full vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            emission_line_moments</span>
<span class="sd">                (:class:`mangadap.proc.emissionlinemoments.EmissionLineMoments`):</span>
<span class="sd">                Object with the results of the emission-line-moment</span>
<span class="sd">                measurements</span>
<span class="sd">            redshift (float, numpy.ndarray): Redshifts (:math:`z`) to</span>
<span class="sd">                use for each spectrum.</span>
<span class="sd">            dispersion (float, numpy.ndarray): Velocity dispersion</span>
<span class="sd">                (km/s) to use for each spectrum.</span>
<span class="sd">            default_dispersion (float, numpy.ndarray): (**Optional**)</span>
<span class="sd">                Default velocity dispersion to use (km/s), if relevant.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the redshift and dispersion measured for the stars or</span>
        <span class="c1"># based on the moments if the relevant objects are provided</span>
        <span class="n">obj_redshift</span><span class="p">,</span> <span class="n">obj_dispersion</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">emission_line_moments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">emission_line_moments</span><span class="o">.</span><span class="n">channel_names</span><span class="p">()</span>
            <span class="n">vel_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))[</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">]</span>
                                                                <span class="o">==</span> <span class="n">names</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vel_channel</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">obj_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
                <span class="n">mom1_masked</span> <span class="o">=</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># - Use the 1st moment of the named line</span>
                <span class="n">obj_redshift</span><span class="p">[</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="p">]</span> \
                        <span class="o">=</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MOM1&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">]</span> \
                                <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

                <span class="c1"># - For missing bins in the moment measurements and bad</span>
                <span class="c1"># line moment measurements, use the value for the</span>
                <span class="c1"># nearest good bin</span>
                <span class="n">bad_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emission_line_moments</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">,</span>
                                        <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span>\
                                            <span class="p">[</span><span class="n">mom1_masked</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">:</span>
                    <span class="n">nearest_good_bin_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">find_nearest_bin</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">,</span>
                                                                                  <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">bad_bin_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">get_bin_indices</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span>
                    <span class="n">obj_redshift</span><span class="p">[</span><span class="n">bad_bin_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_redshift</span><span class="p">[</span><span class="n">nearest_good_bin_index</span><span class="p">]</span>

            <span class="n">disp_channel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">names</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">disp_channel</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">obj_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">default_dispersion</span><span class="p">,</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
                <span class="n">mom2_masked</span> <span class="o">=</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">disp_channel</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="c1"># - Use the 2nd moment of the named line</span>
                <span class="n">obj_dispersion</span><span class="p">[</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="p">]</span> \
                                <span class="o">=</span> <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MOM2&#39;</span><span class="p">][:,</span><span class="n">disp_channel</span><span class="p">]</span>

                <span class="c1"># - For missing bins in the moment measurements and bad</span>
                <span class="c1"># line moment measurements, use the value for the</span>
                <span class="c1"># nearest good bin</span>
                <span class="n">bad_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">emission_line_moments</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">,</span>
                                        <span class="n">emission_line_moments</span><span class="p">[</span><span class="s1">&#39;ELMMNTS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span>\
                                            <span class="p">[</span><span class="n">mom2_masked</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">:</span>
                    <span class="n">nearest_good_bin_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">find_nearest_bin</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">,</span>
                                                                                  <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">bad_bin_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">get_bin_indices</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span>
                    <span class="n">obj_dispersion</span><span class="p">[</span><span class="n">bad_bin_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_dispersion</span><span class="p">[</span><span class="n">nearest_good_bin_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obj_redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obj_dispersion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">sc_redshift</span><span class="p">,</span> <span class="n">sc_dispersion</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">matched_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">redshift</span><span class="p">),</span>
                                <span class="n">dispersion</span><span class="o">=</span><span class="n">default_dispersion</span> <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span> 
                                                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dispersion</span><span class="p">),</span>
                                <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nearest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">missing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj_redshift</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj_redshift</span> <span class="o">=</span> <span class="n">sc_redshift</span>
            <span class="k">if</span> <span class="n">obj_dispersion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj_dispersion</span> <span class="o">=</span> <span class="n">sc_dispersion</span>
        <span class="c1">#---------------------------------------------------------------</span>

        <span class="c1"># Redshift: use the stellar continuum values if present,</span>
        <span class="c1"># otherwise set the default to 0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">obj_redshift</span> <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                            <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span> <span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided redshift must be either a single value or match the &#39;</span> \
                                 <span class="s1">&#39;number of binned spectra.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">_redshift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Same for dispersion</span>
        <span class="c1"># Redshift: use the stellar continuum values if present,</span>
        <span class="c1"># otherwise set the default to 0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span> <span class="o">=</span> <span class="n">obj_dispersion</span> <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                            <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">default_dispersion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">dispersion</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_dispersion</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span> <span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided dispersion must be either a single value or match the &#39;</span> \
                                 <span class="s1">&#39;number of binned spectra.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_dispersion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">_dispersion</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="EmissionLineModel._fill_method_par"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._fill_method_par">[docs]</a>    <span class="k">def</span> <span class="nf">_fill_method_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Fill in any remaining modeling parameters.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Construct the replacement template library here instead of</span>
<span class="sd">              in Sasuke?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Fit parameters not defined so continue</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Fill the guess kinematics</span>
        <span class="k">if</span> <span class="s1">&#39;guess_redshift&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span>
        <span class="k">if</span> <span class="s1">&#39;guess_dispersion&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;guess_dispersion&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span>
        <span class="k">if</span> <span class="s1">&#39;emission_lines&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span>
        <span class="k">if</span> <span class="s1">&#39;pixelmask&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="s1">&#39;stellar_continuum&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span></div>


<div class="viewcode-block" id="EmissionLineModel._add_method_header"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._add_method_header">[docs]</a>    <span class="k">def</span> <span class="nf">_add_method_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">model_binid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add fitting method information to the header.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELTYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_type</span>
                <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELMETH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_method</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Fit class object does not have fit_type and/or fit_method &#39;</span> \
                                  <span class="s1">&#39;attributes.  No parameters written to header.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toheader</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Fit parameter class has no toheader() function.  No &#39;</span> \
                                  <span class="s1">&#39;parameters written to header.&#39;</span><span class="p">)</span>

        <span class="c1"># If the model bin IDs are provided, assume the data was</span>
        <span class="c1"># rebinned, meaning that the bin ID of this object is not</span>
        <span class="c1"># directly tied to the bin ID for the spatially binned spectra</span>
        <span class="c1"># object (self.binned_spectra)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELREBIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_binid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Bin IDs disconnected from SC binning&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="EmissionLineModel._finalize_cube_mask"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._finalize_cube_mask">[docs]</a>    <span class="k">def</span> <span class="nf">_finalize_cube_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalize the mask by setting the DIDNOTUSE, FORESTAR, and LOW_SNR masks</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : Bitmask array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Turn on the flag stating that the pixel wasn&#39;t used</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">do_not_fit_flags</span><span class="p">())</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that the pixel has a foreground star</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that an individual bin/spaxel was not</span>
        <span class="c1"># used, anything without a non-negative binid, in the fit</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that an individual bin/spaxel was not</span>
        <span class="c1"># used because the S/N was too low</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:],</span> <span class="s1">&#39;LOW_SNR&#39;</span><span class="p">)</span>

<span class="c1">#        # Turn on the flag stating that the S/N in the spectrum was</span>
<span class="c1">#        # below the requested limit</span>
<span class="c1">#        low_snr = numpy.invert(self.binned_spectra[&#39;BINID&#39;].data == self.hdu[&#39;BINID&#39;].data)</span>
<span class="c1">#        indx = numpy.array([low_snr]*self.nwave).transpose(1,2,0)</span>
<span class="c1">#        mask[indx] = self.bitmask.turn_on(mask[indx], flag=&#39;LOW_SNR&#39;)</span>

        <span class="k">return</span> <span class="n">mask</span></div>

    
<div class="viewcode-block" id="EmissionLineModel._assign_spectral_arrays"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._assign_spectral_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_spectral_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="s1">&#39;BASE&#39;</span><span class="p">,</span> <span class="s1">&#39;MASK&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="EmissionLineModel._assign_image_arrays"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._assign_image_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_image_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set :attr:`image_arrays`, which contains the list of extensions</span>
<span class="sd">        in :attr:`hdu` that are on-sky image data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;BINID&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="EmissionLineModel._get_missing_models"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._get_missing_models">[docs]</a>    <span class="k">def</span> <span class="nf">_get_missing_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unique_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">above_snr_limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">+</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">SpatiallyBinnedSpectra</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel._get_line_fit_metrics"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._get_line_fit_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">_get_line_fit_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span>
                              <span class="n">model_binid</span><span class="p">,</span> <span class="n">metric_window</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute some line fit metrics.</span>

<span class="sd">        Fills in the LINE_PIXC, AMP, ANR, LINE_NSTAT, LINE_RMS,</span>
<span class="sd">        LINE_FRMS, and LINE_CHI2 elements of model_eml_par.</span>

<span class="sd">        metric_window sets the size in pixels to use for the metrics</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Try to construct the line database</span>
        <span class="n">line_database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_database</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line_database</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cannot construct line metrics.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">model_eml_par</span>
        <span class="n">neml</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_database</span><span class="p">)</span>

<span class="c1">#        print(neml)</span>
<span class="c1">#        print(line_database[&#39;RESTWAVE&#39;])</span>

        <span class="c1"># Construct the bin ID map</span>
        <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">downselect_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="n">model_binid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">model_binid</span>

<span class="c1">#        pyplot.imshow(bin_indx.T, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.colorbar()</span>
<span class="c1">#        pyplot.show()</span>

        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Get the baseline continuum</span>
        <span class="n">continuum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_base</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span> \
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">fill_to_match</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">continuum</span> <span class="o">=</span> <span class="n">continuum</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">model_base</span>

        <span class="c1"># Allow the fitting function to return a boolean model mask</span>
        <span class="k">if</span> <span class="n">model_mask</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">):</span>
            <span class="n">_model_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
            <span class="n">_model_mask</span><span class="p">[</span><span class="n">model_mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">_model_mask</span><span class="p">[</span><span class="n">model_mask</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_model_mask</span> <span class="o">=</span> <span class="n">model_mask</span>

        <span class="c1"># Get the fitted spectra and errors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]:</span>
            <span class="c1"># Get the individual spaxels</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">get_spectra_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                                               <span class="n">pixelmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span><span class="p">,</span>
                                                               <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Apply the Galactic extinction</span>
            <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">ferr</span><span class="p">,</span> <span class="n">deredden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">spaxel_to_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">check_fgoodpix</span><span class="p">()</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:]</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="n">ferr</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the binned spectra</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">get_spectra_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                               <span class="n">pixelmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span><span class="p">,</span>
                                                               <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bins_to_fit</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">select_binned_spectra_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                        <span class="n">minimum_snr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span>
                                                        <span class="n">stellar_continuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:]</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="n">ferr</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:]</span>

        <span class="c1"># Get the continuum-subtracted flux</span>
        <span class="n">flux_nc</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">-</span> <span class="n">continuum</span>

        <span class="c1"># Mask the model flux</span>
        <span class="n">_model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">model_flux</span><span class="o">+</span><span class="n">continuum</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_model_mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">nspec</span> <span class="o">=</span> <span class="n">continuum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#        print(nspec, flux.shape[0])</span>
<span class="c1">#        pyplot.plot(wave, flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, _model_flux[nspec//2,:], color=&#39;C3&#39;)</span>
<span class="c1">#        pyplot.plot(wave, flux_nc[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, _model_flux[nspec//2,:]-continuum[nspec//2,:], color=&#39;C0&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Get the data for the metrics</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">flux</span><span class="o">-</span><span class="n">_model_flux</span><span class="p">)</span>
        <span class="n">fresid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">flux</span><span class="o">-</span><span class="n">_model_flux</span><span class="p">,</span> <span class="n">_model_flux</span><span class="p">))</span>
        <span class="n">chisqr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">flux</span><span class="o">-</span><span class="n">_model_flux</span><span class="p">,</span> <span class="n">ferr</span><span class="p">))</span>
        <span class="n">spec_mask</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">mask</span> <span class="o">|</span> <span class="n">fresid</span><span class="o">.</span><span class="n">mask</span> <span class="o">|</span> <span class="n">chisqr</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">resid</span><span class="p">[</span><span class="n">spec_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">fresid</span><span class="p">[</span><span class="n">spec_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">chisqr</span><span class="p">[</span><span class="n">spec_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

<span class="c1">#        pyplot.plot(wave, flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, resid[nspec//2,:], color=&#39;0.5&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        pyplot.plot(wave, flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, fresid[nspec//2,:], color=&#39;0.5&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        pyplot.plot(wave, flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, chisqr[nspec//2,:], color=&#39;0.5&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Get the pixel at which to center the metric calculations</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">,</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">,</span> <span class="s1">&#39;UNDEFINED_COVAR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEAR_BOUND&#39;</span> <span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                 <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="n">flags</span><span class="p">))</span>
        <span class="n">sample_wave</span> <span class="o">=</span> <span class="n">line_database</span><span class="p">[</span><span class="s1">&#39;RESTWAVE&#39;</span><span class="p">][</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">)</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">interp</span><span class="p">(</span><span class="n">sample_wave</span><span class="o">.</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">sample_wave</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">wave</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="c1">#        print(sample_wave.shape)</span>
<span class="c1">#        print(sample_wave[nspec//2,:])</span>
<span class="c1">#        print(interp(sample_wave.data[nspec//2,:]))</span>
<span class="c1">#</span>
<span class="c1">#        print(len(wave), flux.shape[1])</span>
<span class="c1">#        print(model_eml_par[&#39;LINE_PIXC&#39;].shape)</span>
<span class="c1">#        print(model_eml_par[&#39;LINE_PIXC&#39;][nspec//2,:])</span>

<span class="c1">#        pyplot.plot(wave, flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(wave, _model_flux[nspec//2,:], color=&#39;C3&#39;)</span>
<span class="c1">#        pyplot.scatter(sample_wave[nspec//2,:], [numpy.amax(flux[nspec//2,:])]*neml, marker=&#39;.&#39;,</span>
<span class="c1">#                       s=50, color=&#39;C0&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.plot(numpy.arange(len(wave)), flux[nspec//2,:], color=&#39;k&#39;, lw=1.5)</span>
<span class="c1">#        pyplot.plot(numpy.arange(len(wave)), _model_flux[nspec//2,:], color=&#39;C3&#39;)</span>
<span class="c1">#        pyplot.scatter(model_eml_par[&#39;LINE_PIXC&#39;][nspec//2,:],</span>
<span class="c1">#                       [numpy.amax(flux[nspec//2,:])]*neml, marker=&#39;.&#39;, s=50, color=&#39;C0&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Iterate over the number of lines</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neml</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Getting fit metrics for line: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">neml</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">metric_window</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">metric_window</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="n">end</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="n">masked_pixel</span> <span class="o">=</span> <span class="n">flux_nc</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span> \
                                <span class="o">|</span> <span class="n">ferr</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">masked_pixel</span><span class="p">:</span>
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;AMP&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> 
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;ANR&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>     
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;AMP&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_nc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;ANR&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_nc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span> \
                                                    <span class="o">/</span> <span class="n">ferr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_PIXC&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">m</span><span class="p">[</span><span class="n">spec_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_NSTAT&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_RMS&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">resid</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                                           <span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_FRMS&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">fresid</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                                            <span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;LINE_CHI2&#39;</span><span class="p">][:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">chisqr</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Getting fit metrics for line: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neml</span><span class="p">))</span>
<span class="c1">#        print(model_eml_par[&#39;LINE_RMS&#39;][nspec//2,:])</span>
        <span class="k">return</span> <span class="n">model_eml_par</span></div>


<div class="viewcode-block" id="EmissionLineModel._construct_2d_hdu"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel._construct_2d_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">_construct_2d_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span>
                          <span class="n">model_fit_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_binid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct :attr:`hdu` that is held in memory for manipulation of</span>
<span class="sd">        the object.  See :func:`construct_3d_hdu` if you want to convert</span>
<span class="sd">        the object into a DRP-like datacube.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing hdu ...&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the headers</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_primary_header</span><span class="p">()</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_header</span><span class="p">(</span><span class="n">pri_hdr</span><span class="p">,</span> <span class="n">model_binid</span><span class="o">=</span><span class="n">model_binid</span><span class="p">)</span>
        <span class="n">map_hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">build_map_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                               <span class="s1">&#39;K Westfall &lt;westfall@ucolick.org&gt;&#39;</span><span class="p">)</span>

        <span class="c1"># Get the spatial map mask</span>
        <span class="n">map_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>

        <span class="c1"># Allow the fitting function to redefine the bin IDs associated</span>
        <span class="c1"># with each model</span>
        <span class="k">if</span> <span class="n">model_binid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add any spaxel not used because it was flagged by the</span>
            <span class="c1"># binning step</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
            <span class="c1"># Isolate any spaxels with foreground stars</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                       <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
            <span class="c1"># Get the bins that were below the S/N limit</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                    <span class="n">good_snr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;LOW_SNR&#39;</span><span class="p">)</span>

            <span class="c1"># Get the bin ids with fitted models</span>
            <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">downselect_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume any model with a binid less than zero is from a</span>
            <span class="c1"># spaxel that was not used</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">model_binid</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

            <span class="c1"># The number of valid bins MUST match the number of</span>
            <span class="c1"># measurements</span>
            <span class="n">nvalid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">indx</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">nvalid</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided model id does not match the number of measurements.&#39;</span><span class="p">)</span>

            <span class="c1"># Get the bin ids with fitted models</span>
            <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">model_binid</span>

        <span class="c1"># Allow the fitting function to return a boolean model mask</span>
        <span class="k">if</span> <span class="n">model_mask</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">):</span>
            <span class="n">_model_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
            <span class="n">_model_mask</span><span class="p">[</span><span class="n">model_mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">_model_mask</span><span class="p">[</span><span class="n">model_mask</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_model_mask</span> <span class="o">=</span> <span class="n">model_mask</span>

        <span class="c1"># Compile the information on the suite of measured indices</span>
        <span class="n">line_database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_database</span><span class="p">()</span>

        <span class="c1"># Save the data to the hdu attribute</span>
        <span class="n">par_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PAR&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">line_database</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                        <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                        <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">line_database</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                                        <span class="n">array</span><span class="o">=</span><span class="n">line_database</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                                                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line_database</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">],</span>
                                                      <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PAR&#39;</span><span class="p">)</span>

        <span class="n">fit_hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FIT&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">model_fit_par</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                        <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                        <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                                        <span class="n">dim</span><span class="o">=</span><span class="n">rec_to_fits_col_dim</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                                        <span class="n">array</span><span class="o">=</span><span class="n">model_fit_par</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                                                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">model_fit_par</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">],</span>
                                                      <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FIT&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model_flux</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model_base</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BASE&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">_model_mask</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINID&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">map_mask</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">),</span>
                                  <span class="n">par_hdu</span><span class="p">,</span> <span class="n">fit_hdu</span><span class="p">,</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">([</span><span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                        <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                                        <span class="n">dim</span><span class="o">=</span><span class="n">rec_to_fits_col_dim</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                        <span class="n">array</span><span class="o">=</span><span class="n">model_eml_par</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">model_eml_par</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">],</span>
                                                                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">)</span>
                                <span class="p">])</span></div>


<div class="viewcode-block" id="EmissionLineModel.file_name"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.file_name">[docs]</a>    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the output file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span></div>


<div class="viewcode-block" id="EmissionLineModel.file_path"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.file_path">[docs]</a>    <span class="k">def</span> <span class="nf">file_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full path to the output file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel.fit"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emission_line_moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the emission lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># SpatiallyBinnedSpectra object always needed</span>
        <span class="k">if</span> <span class="n">binned_spectra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide spectra object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectra</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid SpatiallyBinnedSpectra object!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided SpatiallyBinnedSpectra object is undefined!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span> <span class="o">=</span> <span class="n">binned_spectra</span>

        <span class="c1"># Continuum accounts for underlying absorption</span>
        <span class="k">if</span> <span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stellar_continuum</span><span class="p">,</span> <span class="n">StellarContinuumModel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid StellarContinuumModel object.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="o">=</span> <span class="n">stellar_continuum</span>

        <span class="c1"># Emission-line moments can be used to set the initial guess</span>
        <span class="c1"># kinematics</span>
        <span class="k">if</span> <span class="n">emission_line_moments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No longer checks for this; errors will be raised</span>
            <span class="c1"># just by trying to use the object...</span>
<span class="c1">#            if not isinstance(emission_line_moments, EmissionLineMoments):</span>
<span class="c1">#                raise TypeError(&#39;Must provide a valid EmissionLineMoments object.&#39;)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">emission_line_moments</span><span class="o">.</span><span class="n">channel_names</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_vel_name&#39;</span><span class="p">])</span> <span class="o">+</span>
                                 <span class="s1">&#39; is not a valid name in the EmissionLineMoments object.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;mom_disp_name&#39;</span><span class="p">])</span> <span class="o">+</span>
                                 <span class="s1">&#39; is not a valid name in the EmissionLineMoments object.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_shape</span>
<span class="c1">#       nspec is never used and it won&#39;t be correct if the bins are</span>
<span class="c1">#       deconstructed.</span>
<span class="c1">#        self.nspec = self.binned_spectra.nspec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">dispaxis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nwave</span>
        
        <span class="c1"># Get the guess kinematics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_input_kinematics</span><span class="p">(</span><span class="n">emission_line_moments</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the good spectra</span>
        <span class="c1"># TODO: Put this in a function that can be used by Sasuke...</span>
        <span class="n">good_snr</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">select_binned_spectra_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                        <span class="n">minimum_snr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span>
                                                        <span class="n">stellar_continuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0:^50}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;EMISSION-LINE PROFILE FITTING&#39;</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of binned spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Missing bins: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;With good S/N and to fit: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Bins deconstructed in fitting: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">])))</span>
            
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No good spectra to fit!&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fill in any remaining binning parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_method_par</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">)</span>

        <span class="c1"># (Re)Set the output paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check that the file path is defined</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ofile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File path for output file is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Output path: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Output file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># If the file already exists, and not clobbering, just read the</span>
        <span class="c1"># file</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">clobber</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Using existing file&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fit the spectra</span>
        <span class="c1"># Mask should be fully defined within the fitting function</span>
        <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span> <span class="n">model_binid</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitfunc&#39;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">],</span>
                                       <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Impose a minimum error because of the conversion to inverse</span>
        <span class="c1"># variance when constructing a MAPS file; applied to the error</span>
        <span class="c1"># quantities from spectralfitting.EmissionLineFit dtype</span>
        <span class="c1"># parameters: FLUXERR, KINERR, EWERR</span>
        <span class="c1"># TODO: Add a maskbit as well?  Yes, but in MAPS construction</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> \
                                            <span class="k">if</span> <span class="n">minimum_error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">minimum_error</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> \
                                            <span class="k">if</span> <span class="n">minimum_error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">minimum_error</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EWERR&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> \
                                            <span class="k">if</span> <span class="n">minimum_error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">minimum_error</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EWERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># TODO: Test if, when deconstruct_bins is true, the model_binid</span>
        <span class="c1"># spaxels (with fits) all have unique bin IDs.</span>

        <span class="c1"># The emission-line fitting can proceed without knowing which</span>
        <span class="c1"># lines are fit; this sets the number of lines</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">#        pyplot.step(model_wave, model_flux[0,:], where=&#39;mid&#39;)</span>
<span class="c1">#        pyplot.show()</span>
       
        <span class="c1"># The number of models returned should be the number of &quot;good&quot; binned</span>
        <span class="c1"># spectra if the fitter does *not* deconstruct the bins.</span>
        <span class="c1"># TODO: This may now cause problems with Elric...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected returned shape of fitted emission-line models.&#39;</span><span class="p">)</span>
       
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Set the number of models and the missing models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span> <span class="o">=</span> <span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unique_bins</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">model_binid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">model_binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_missing_models</span><span class="p">(</span><span class="n">unique_bins</span><span class="o">=</span><span class="n">unique_bins</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Fitted models: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Missing models: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Calculating fit metrics&#39;</span><span class="p">)</span>

        <span class="c1"># Compute the line-fit metrics</span>
        <span class="n">model_eml_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_line_fit_metrics</span><span class="p">(</span><span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span>
                                                   <span class="n">model_eml_par</span><span class="p">,</span> <span class="n">model_binid</span><span class="p">)</span>

        <span class="c1"># Construct the 2d hdu list that only contains the fitted models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="n">hardcopy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_2d_hdu</span><span class="p">(</span><span class="n">good_snr</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span>
                               <span class="n">model_fit_par</span><span class="o">=</span><span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_binid</span><span class="o">=</span><span class="n">model_binid</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Write the data, if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel.construct_3d_hdu"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.construct_3d_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">construct_3d_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reformat the model spectra into a cube matching the shape of</span>
<span class="sd">        the DRP fits file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Constructing emission-line model datacube ...&#39;</span><span class="p">)</span>

        <span class="n">bin_indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BASE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">flux</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                        <span class="p">[</span><span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">])</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_cube_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Primary header is identical regardless of the shape of the</span>
        <span class="c1"># extensions</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cube_hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">build_cube_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                                 <span class="s1">&#39;K Westfall &lt;westfall@ucolick.org&gt;&#39;</span><span class="p">)</span>

        <span class="n">par_hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span> \
                        <span class="k">else</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PAR&#39;</span><span class="p">)</span>
        <span class="n">fit_hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span> \
                        <span class="k">else</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FIT&#39;</span><span class="p">)</span>

        <span class="c1"># Return the converted hdu without altering the internal hdu</span>
        <span class="k">return</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">hdr</span><span class="p">),</span>
                              <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">),</span>
                              <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BASE&#39;</span><span class="p">),</span>
                              <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="n">par_hdu</span><span class="p">,</span>
                              <span class="n">fit_hdu</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="p">])</span></div>


    <span class="c1"># Exact same function as used by SpatiallyBinnedSpectra</span>
<div class="viewcode-block" id="EmissionLineModel.write"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_DRP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the hdu object to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert the spectral arrays in the HDU to a 3D cube and write</span>
        <span class="c1"># it</span>
        <span class="k">if</span> <span class="n">match_DRP</span><span class="p">:</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_3d_hdu</span><span class="p">()</span>
            <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Just write the unique (2D) data</span>
        <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span> </div>


<div class="viewcode-block" id="EmissionLineModel.read"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read an existing file with an existing set of emission-line</span>
<span class="sd">        models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ifile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ifile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;File does not exist!: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ifile</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#        self.hdu = fits.open(ifile, checksum=checksum)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>

        <span class="c1"># Force load the PAR and FIT extensions because it may be</span>
        <span class="c1"># checked by self.construct_3d_hdu() or construct_maps_file in</span>
        <span class="c1"># dapfits.py</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not load emission-line parameter data.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not load emission-line fit data.&#39;</span><span class="p">)</span>

        <span class="c1"># Make sure that the number of emission-lines is set</span>
        <span class="n">_neml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_neml</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Num. of emission lines read does not match emission-line database.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="n">_neml</span>

        <span class="c1"># Confirm that the internal method is the same as the method</span>
        <span class="c1"># that was used in writing the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ELFKEY&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Keywords in header do not match specified method keywords!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Keywords in header do not match specified method keywords!&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: &quot;strict&quot; should also check other aspects of the file to</span>
        <span class="c1"># make sure that the details of the method are also the same,</span>
        <span class="c1"># not just the keyword</span>

<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO, &#39;Reverting to python-native structure.&#39;)</span>
<span class="c1">#        DAPFitsUtil.restructure_rss(self.hdu, ext=self.spectral_arrays)</span>
<span class="c1">#        DAPFitsUtil.restructure_map(self.hdu, ext=self.image_arrays)</span>

        <span class="c1"># Attempt to read the modeling parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fromheader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Fit parameter object does not have a fromheader &#39;</span> \
                                  <span class="s1">&#39;attribute.  No parameters head from header.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unique_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> \
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ELREBIN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_missing_models</span><span class="p">(</span><span class="n">unique_bins</span><span class="o">=</span><span class="n">unique_bins</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineModel.copy_to_array"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.copy_to_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Wrapper for :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_array`</span>
<span class="sd">        specific for :class:`EmissionLineModel`.</span>

<span class="sd">        Return a copy of the selected data array.  The array size is</span>
<span class="sd">        always :math:`N_{\rm models} \times N_{\rm wavelength}`; i.e., the</span>
<span class="sd">        data is always flattened to two dimensions and the unique</span>
<span class="sd">        spectra are selected.</span>

<span class="sd">        Args:</span>
<span class="sd">            ext (str) : (**Optional**) Name of the extension from which</span>
<span class="sd">                to draw the data.  Must be allowed for the current</span>
<span class="sd">                :attr:`mode`; see :attr:`data_arrays`.  Default is</span>
<span class="sd">                ``&#39;FLUX&#39;``.</span>
<span class="sd">            waverange (array-like) : (**Optional**) Two-element array</span>
<span class="sd">                with the first and last wavelength to include in the</span>
<span class="sd">                computation.  Default is to use the full wavelength</span>
<span class="sd">                range.</span>
<span class="sd">            include_missing (bool) : (**Optional**) Create an array with</span>
<span class="sd">                a size that accommodates the missing models.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A 2D array with a copy of the data from the</span>
<span class="sd">            selected extension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                         <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span>
                                    <span class="n">missing_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span> <span class="k">if</span> <span class="n">include_missing</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">,</span>
                                        <span class="n">unique_bins</span><span class="o">=</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">unique_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>


<div class="viewcode-block" id="EmissionLineModel.copy_to_masked_array"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.copy_to_masked_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for</span>
<span class="sd">        :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_masked_array`</span>
<span class="sd">        specific for :class:`EmissionLineModel`.</span>

<span class="sd">        Return a copy of the selected data array as a masked array.</span>
<span class="sd">        This is functionally identical to :func:`copy_to_array`,</span>
<span class="sd">        except the output format is a `numpy.ma.MaskedArray`_.  The</span>
<span class="sd">        pixels that are considered to be masked can be specified using</span>
<span class="sd">        `flag`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            ext (str) : (**Optional**) Name of the extension from which</span>
<span class="sd">                to draw the data.  Must be allowed for the current</span>
<span class="sd">                :attr:`mode`; see :attr:`data_arrays`.  Default is</span>
<span class="sd">                `&#39;FLUX&#39;`.</span>
<span class="sd">            flag (str or list): (**Optional**) (List of) Flag names that</span>
<span class="sd">                are considered when deciding if a pixel should be</span>
<span class="sd">                masked.  The names *must* be a valid bit name as defined</span>
<span class="sd">                by :attr:`bitmask`.  If not provided, *ANY* non-zero</span>
<span class="sd">                mask bit is omitted.</span>
<span class="sd">            waverange (array-like) : (**Optional**) Two-element array</span>
<span class="sd">                with the first and last wavelength to include in the</span>
<span class="sd">                computation.  Default is to use the full wavelength</span>
<span class="sd">                range.</span>
<span class="sd">            include_missing (bool) : (**Optional**) Create an array with</span>
<span class="sd">                a size that accommodates the missing models.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A 2D array with a copy of the data from the</span>
<span class="sd">            selected extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">mask_ext</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
                                                <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                                <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span>
                                    <span class="n">missing_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_models</span> <span class="k">if</span> <span class="n">include_missing</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">,</span>
                                        <span class="n">unique_bins</span><span class="o">=</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">unique_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>


<span class="c1">#    def fill_to_match(self, binned_spectra, include_base=False):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Get the emission-line models that match the shape of the</span>
<span class="c1">#        provided binned_spectra.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if binned_spectra is self.binned_spectra:</span>
<span class="c1">#            emission_lines = self.copy_to_array()</span>
<span class="c1">#            if include_base:</span>
<span class="c1">#                emission_lines += self.copy_to_array(ext=&#39;BASE&#39;)</span>
<span class="c1">#            emission_lines = numpy.ma.MaskedArray(emission_lines)</span>
<span class="c1">#</span>
<span class="c1">#            # Number of models matches the numbers of bins</span>
<span class="c1">#            if binned_spectra.nbins == self.nmodels:</span>
<span class="c1">#                return emission_lines</span>
<span class="c1">#    </span>
<span class="c1">#            # Fill in bins with no models with masked zeros</span>
<span class="c1">#            _emission_lines = numpy.ma.zeros(binned_spectra[&#39;FLUX&#39;].data.shape, dtype=float)</span>
<span class="c1">#            _emission_lines[:,:] = numpy.ma.masked</span>
<span class="c1">#            for i,j in enumerate(self.hdu[&#39;EMLDATA&#39;].data[&#39;BINID_INDEX&#39;]):</span>
<span class="c1">#                _emission_lines[j,:] = emission_lines[i,:]</span>
<span class="c1">#            return _emission_lines</span>
<span class="c1">#</span>
<span class="c1">#        raise NotImplementedError(&#39;Can only match to internal binned_spectra.&#39;)</span>


<div class="viewcode-block" id="EmissionLineModel.fill_to_match"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.fill_to_match">[docs]</a>    <span class="k">def</span> <span class="nf">fill_to_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binid</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the emission-line model that matches the input bin ID</span>
<span class="sd">        matrix.  The output is a 2D matrix ordered by the bin ID; any</span>
<span class="sd">        skipped index numbers in the maximum of the union of the unique</span>
<span class="sd">        numbers in the `binid` and `missing` input are masked.</span>

<span class="sd">        Use `include_base` to include the baseline in the output</span>
<span class="sd">        emission-line models.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The input bin id array must have the same shape as self</span>
        <span class="k">if</span> <span class="n">binid</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input bin ID matrix has incorrect shape.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct the best-fitting models</span>
        <span class="n">best_fit_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_base</span><span class="p">:</span>
            <span class="n">best_fit_model</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;BASE&#39;</span><span class="p">)</span>

        <span class="c1"># Get the number of output models</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">binid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">missing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">missing</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># Map the BINID to the spectrum index, assuming bins are sorted</span>
        <span class="c1"># and that the BINID map has -1 BINID values</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">reconstruct</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">u_bin_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">_bin_indx</span> <span class="o">=</span> <span class="n">u_bin_indx</span><span class="p">[</span><span class="n">reconstruct</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>

        <span class="c1"># Fill in bins with no models with masked zeros</span>
        <span class="n">emission_lines</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbins</span><span class="p">,</span><span class="n">best_fit_model</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">emission_lines</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">_bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">emission_lines</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">best_fit_model</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>

        <span class="k">return</span> <span class="n">emission_lines</span></div>


<div class="viewcode-block" id="EmissionLineModel.matched_kinematics"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.matched_kinematics">[docs]</a>    <span class="k">def</span> <span class="nf">matched_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binid</span><span class="p">,</span> <span class="n">line_name</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dispersion</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">cz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nearest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">missing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the redshift and velocity dispersion for all the</span>
<span class="sd">        spectra based on the emission-line model fit to a single line.</span>

<span class="sd">        For spectra the were not fit, use the median (unmasked)</span>
<span class="sd">        kinematic measurement if no default value is provided as an</span>
<span class="sd">        argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            binid (numpy.ndarray): 2D array with the bin ID associate</span>
<span class="sd">                with each spaxel in the datacube.</span>
<span class="sd">            line (str): Line to use for the kinematics.  Must match one</span>
<span class="sd">                of the lines created by :func:`channel_names`.  Function</span>
<span class="sd">                will raise an exception if the line_name is None or if</span>
<span class="sd">                the channel names cannot be constructed.</span>
<span class="sd">            redshift (float): (**Optional**) The default redshift to use</span>
<span class="sd">                for spectra without an emission-line fit.  Default is to</span>
<span class="sd">                use the median of the unmasked measurements.</span>
<span class="sd">            dispersion (float): (**Optional**) The default velocity</span>
<span class="sd">                dispersion to use for spectra without an emission-line</span>
<span class="sd">                fit.  Default is 100 km/s.</span>
<span class="sd">            constant (bool): (**Optional**) Force the function to return</span>
<span class="sd">                a constant redshift and dispersion for each spectrum,</span>
<span class="sd">                regardless of any fitted kinematics.</span>
<span class="sd">            cz (bool): (**Optional**) Return the redshift as cz in km/s,</span>
<span class="sd">                as opposed to unitless z.</span>
<span class="sd">            corrected (bool): (**Optional**) By default, the returned</span>
<span class="sd">                velocity dispersions are the measured values, which will</span>
<span class="sd">                include the instrumental resolution.  Setting corrected</span>
<span class="sd">                to True will return the corrected dispersions.</span>
<span class="sd">            min_dispersion (float): (**Optional**) Impose a minimum</span>
<span class="sd">                dispersion.</span>
<span class="sd">            nearest (bool): (**Optional**) Instead of the median of the</span>
<span class="sd">                results for the spectra that were not fit, use the value</span>
<span class="sd">                from the nearest bin.</span>
<span class="sd">            missing (list): (**Optional**) Any bin ID numbers missing</span>
<span class="sd">                from the input `binid` image needed for constructing the</span>
<span class="sd">                output matched data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Returns arrays with a redshift (or cz) and</span>
<span class="sd">            dispersion for each spectrum.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: Raised if the input redshift or dispersion values</span>
<span class="sd">                are not single numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check input</span>
        <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Redshift must be a single number or None.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dispersion</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dispersion must be a single number or None.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binid</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input bin ID map must match the spatial shape of the DRP cube.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the channel names</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Line </span><span class="si">{0}</span><span class="s1"> not present in channel list.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line_name</span><span class="p">))</span>
        <span class="n">vel_channel</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))[</span><span class="n">names</span> <span class="o">==</span> <span class="n">line_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the number of output kinematics</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">binid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">missing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">missing</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># Mask bad values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                    <span class="p">[</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">,</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">,</span> <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">,</span> <span class="s1">&#39;NEAR_BOUND&#39;</span> <span class="p">])</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># Unlike StellarContinuumModel.matched_kinematics, the input</span>
            <span class="c1"># guesses here always are based on the number of binned</span>
            <span class="c1"># spectra.  So if the class is meant to deconstruct these</span>
            <span class="c1"># bins, we can&#39;t just use the guess kinematics when all the</span>
            <span class="c1"># output is masked.  So we&#39;ll just use the defaults.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;All emission line models have been masked!  Using defaults.&#39;</span><span class="p">)</span>
            <span class="n">eml_z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">,</span>
                                                    <span class="p">(</span><span class="mf">0.0</span> <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">redshift</span><span class="p">),</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">eml_d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodels</span><span class="p">,</span>
                                    <span class="p">(</span><span class="mf">100.0</span> <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dispersion</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pull out the data</span>
            <span class="n">eml_z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">eml_d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

            <span class="c1"># Apply the sigma corrections if requested.  Values with the</span>
            <span class="c1"># correction larger than the measured value will be masked!</span>
            <span class="k">if</span> <span class="n">corrected</span><span class="p">:</span>
                <span class="n">sigma_corr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;EMLDATA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">][:,</span><span class="n">vel_channel</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">eml_d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">eml_d</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma_corr</span><span class="p">))</span>

        <span class="c1"># Set the default values to use when necessary</span>
        <span class="n">_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">eml_z</span><span class="p">)</span> <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">redshift</span>
        <span class="n">_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">eml_d</span><span class="p">)</span> <span class="k">if</span> <span class="n">dispersion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dispersion</span>
        <span class="k">if</span> <span class="n">min_dispersion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_dispersion</span> <span class="o">&lt;</span> <span class="n">min_dispersion</span><span class="p">:</span>
            <span class="n">_dispersion</span> <span class="o">=</span> <span class="n">min_dispersion</span>

        <span class="c1"># Just return the single value</span>
        <span class="k">if</span> <span class="n">constant</span><span class="p">:</span>
            <span class="n">eml_z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">_redshift</span> <span class="o">*</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                                        <span class="k">if</span> <span class="n">cz</span> <span class="k">else</span> <span class="n">_redshift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">eml_d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">_dispersion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">eml_z</span><span class="p">,</span> <span class="n">eml_d</span>

        <span class="k">if</span> <span class="n">nearest</span><span class="p">:</span>
            <span class="c1"># Fill masked values with the nearest datum</span>
            <span class="n">best_fit_kinematics</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">eml_z</span><span class="p">],</span> <span class="p">[</span><span class="n">eml_d</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]:</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">,:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">valid_bins</span><span class="p">,:]</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="n">eml_z</span><span class="o">.</span><span class="n">mask</span> <span class="o">|</span> <span class="n">eml_d</span><span class="o">.</span><span class="n">mask</span>
            <span class="n">kinematics</span> <span class="o">=</span> <span class="n">replace_with_data_from_nearest_coo</span><span class="p">(</span><span class="n">coo</span><span class="p">,</span> <span class="n">best_fit_kinematics</span><span class="p">,</span> <span class="n">replace</span><span class="p">)</span>
            <span class="n">eml_z</span> <span class="o">=</span> <span class="n">kinematics</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">eml_d</span> <span class="o">=</span> <span class="n">kinematics</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fill any masked values with the single estimate</span>
            <span class="n">eml_z</span> <span class="o">=</span> <span class="n">eml_z</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span>
            <span class="n">eml_d</span> <span class="o">=</span> <span class="n">eml_d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">_dispersion</span><span class="p">)</span>

        <span class="c1"># Map the BINID to the spectrum index, assuming bins are sorted</span>
        <span class="c1"># and that the BINID map has -1 BINID values</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">reconstruct</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">u_bin_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">_bin_indx</span> <span class="o">=</span> <span class="n">u_bin_indx</span><span class="p">[</span><span class="n">reconstruct</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>

        <span class="c1"># Match the kinematics to the output bin ID map</span>
        <span class="n">_eml_z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">_eml_d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">_bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">_eml_z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eml_z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">_eml_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eml_d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="n">eml_z</span> <span class="o">=</span> <span class="n">_eml_z</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span>
        <span class="n">eml_d</span> <span class="o">=</span> <span class="n">_eml_d</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">_dispersion</span><span class="p">)</span>
        <span class="c1"># Convert to cz velocities (km/s)</span>
        <span class="k">if</span> <span class="n">cz</span><span class="p">:</span>
            <span class="n">eml_z</span> <span class="o">*=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">eml_z</span><span class="p">,</span> <span class="n">eml_d</span></div>


<div class="viewcode-block" id="EmissionLineModel.fill_continuum_to_match"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.fill_continuum_to_match">[docs]</a>    <span class="k">def</span> <span class="nf">fill_continuum_to_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binid</span><span class="p">,</span> <span class="n">replacement_templates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">deredshift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">corrected_dispersion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the emission-line continuum model, if possible, that matches</span>
<span class="sd">        the input bin ID matrix.  The output is a 2D matrix ordered by</span>
<span class="sd">        the bin ID; any skipped index numbers in the maximum of the</span>
<span class="sd">        union of the unique numbers in the `binid` and `missing` input</span>
<span class="sd">        are masked.</span>

<span class="sd">        Use `replacement_templates` only if the number of templates is</span>
<span class="sd">        identical to the number used during the fitting procedure.  Use</span>
<span class="sd">        `redshift_only` to produce the best-fitting model without and</span>
<span class="sd">        velocity dispersion.  Use `corrected_dispersion` to produce the</span>
<span class="sd">        model using the corrected velocity dispersion.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;EmissionLineModel object has no associated StellarContinuumModel.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No class object available for constructing the model!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construct_continuum_models</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Provided fit class object has no callable &#39;</span> \
                                 <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">construct_continuum_models</span><span class="se">\&#39;</span><span class="s1"> attribute!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corrected_dispersion</span> <span class="ow">and</span> <span class="s1">&#39;NEAREST_BIN&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Nearest stellar continuum bin not set in fit parameters.  Cannot &#39;</span>
                           <span class="s1">&#39;apply dispersion corrections.&#39;</span><span class="p">)</span>

        <span class="c1"># The input bin id array must have the same shape as self</span>
        <span class="k">if</span> <span class="n">binid</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input bin ID matrix has incorrect shape.&#39;</span><span class="p">)</span>

        <span class="c1"># Pull out the dispersion corrections, if requested</span>
        <span class="n">dispersion_corrections</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">corrected_dispersion</span><span class="p">:</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsc</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nb</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">]</span> <span class="p">]</span>
            <span class="n">dispersion_corrections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SIGMACORR_EMP&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span>

        <span class="c1"># Get the continuum models</span>
        <span class="n">best_fit_continuum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_continuum_models</span><span class="p">(</span>
                                            <span class="n">replacement_templates</span><span class="o">=</span><span class="n">replacement_templates</span><span class="p">,</span>
                                            <span class="n">deredshift</span><span class="o">=</span><span class="n">deredshift</span><span class="p">,</span> <span class="n">redshift_only</span><span class="o">=</span><span class="n">redshift_only</span><span class="p">,</span>
                                            <span class="n">dispersion_corrections</span><span class="o">=</span><span class="n">dispersion_corrections</span><span class="p">)</span>

        <span class="c1"># Get the number of output continuua</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">binid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">missing</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">missing</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># Map the BINID to the spectrum index, assuming bins are sorted</span>
        <span class="c1"># and that the BINID map has -1 BINID values</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">reconstruct</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">u_bin_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">_bin_indx</span> <span class="o">=</span> <span class="n">u_bin_indx</span><span class="p">[</span><span class="n">reconstruct</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>

        <span class="c1"># Fill in bins with no models with masked zeros</span>
        <span class="n">continuum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbins</span><span class="p">,</span><span class="n">best_fit_continuum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">continuum</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">_bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">continuum</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">best_fit_continuum</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>

        <span class="k">return</span> <span class="n">continuum</span></div>


<div class="viewcode-block" id="EmissionLineModel.construct_continuum_models"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.construct_continuum_models">[docs]</a>    <span class="k">def</span> <span class="nf">construct_continuum_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replacement_templates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">deredshift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dispersion_corrections</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;EmissionLineModel object has no associated StellarContinuumModel.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No class object available for constructing the model!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construct_continuum_models</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Provided fit class object has no callable &#39;</span> \
                                 <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">construct_continuum_models</span><span class="se">\&#39;</span><span class="s1"> attribute!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">replacement_templates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement_templates</span><span class="p">,</span> <span class="n">TemplateLibrary</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Provided template replacements must have type TemplateLibrary.&#39;</span><span class="p">)</span>

        <span class="c1"># Only the selected models are constructed, others are masked</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span>
                                            <span class="n">flag</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;NO_FIT&#39;</span><span class="p">,</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">,</span> <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">]))</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span> \
                            <span class="k">if</span> <span class="n">replacement_templates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">replacement_templates</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construct_continuum_models</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">,</span> <span class="n">templates</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">templates</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FIT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span>
                                        <span class="n">redshift_only</span><span class="o">=</span><span class="n">redshift_only</span><span class="p">,</span> <span class="n">deredshift</span><span class="o">=</span><span class="n">deredshift</span><span class="p">,</span>
                                        <span class="n">dispersion_corrections</span><span class="o">=</span><span class="n">dispersion_corrections</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span></div>

    <span class="c1"># TODO: Use the EmissionMomentsDB.channel_names function!</span>
<div class="viewcode-block" id="EmissionLineModel.channel_names"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinemodel.html#mangadap.proc.emissionlinemodel.EmissionLineModel.channel_names">[docs]</a>    <span class="k">def</span> <span class="nf">channel_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">line_database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_database</span><span class="p">(</span><span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line_database</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel names undefined because line database is not available.&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> \
                        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;RESTWAVE&#39;</span><span class="p">])</span> <span class="p">])</span></div></div>


</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>