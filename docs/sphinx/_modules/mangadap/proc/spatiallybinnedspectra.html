

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.spatiallybinnedspectra &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.spatiallybinnedspectra</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.spatiallybinnedspectra</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A class hierarchy that perform that spatially bins a set of</span>
<span class="sd">two-dimensional data.</span>

<span class="sd">The base class allows for user-defined definitions of binning</span>
<span class="sd">procedures.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/spatiallybinnedspectra.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>
<span class="sd">        </span>
<span class="sd">        import glob</span>
<span class="sd">        import os.path</span>
<span class="sd">        from os import remove, environ</span>
<span class="sd">        from scipy import sparse</span>
<span class="sd">        from astropy.io import fits</span>
<span class="sd">        import time</span>
<span class="sd">        import numpy</span>

<span class="sd">        from ..par.parset import ParSet</span>
<span class="sd">        from ..config.defaults import default_dap_source, default_dap_common_path</span>
<span class="sd">        from ..config.defaults import default_dap_file_name</span>
<span class="sd">        from ..util.geometry import SemiMajorAxisCoo</span>
<span class="sd">        from ..util.fileio import init_record_array</span>
<span class="sd">        from ..util.parser import DefaultConfig</span>
<span class="sd">        from ..drpfits import DRPFits</span>

<span class="sd">*Class usage examples*:</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Add examples</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **01 Apr 2016**: Implementation begun by K. Westfall (KBW)</span>
<span class="sd">    | **19 May 2016**: (KBW) Include SPECRES and SPECRESD extensions</span>
<span class="sd">        from DRP file in output. Added loggers and quiet keyword</span>
<span class="sd">        arguments to :class:`SpatiallyBinnedSpectra`, removed verbose </span>
<span class="sd">    | **06 Jul 2016**: (KBW) Make the application of a reddening</span>
<span class="sd">        correction an input parameter.</span>
<span class="sd">    | **25 Aug 2016**: (KBW) Fixed error in bin area when calling</span>
<span class="sd">        :func:`SpatiallyBinnedSpetra._unbinned_data_table`</span>
<span class="sd">    | **01 Dec 2016**: (KBW) Include keyword that describes how to</span>
<span class="sd">        handle the spectral resolution.</span>
<span class="sd">    | **02 Dec 2016**: (KBW) Incorporate</span>
<span class="sd">        :class:`mangadap.util.extinction.GalacticExtinction`.  Revert</span>
<span class="sd">        main file structure to be bin-based instead of cube-based;</span>
<span class="sd">        include convenience functions that construct the cube for each</span>
<span class="sd">        extension as requested.</span>
<span class="sd">    | **06 Dec 2016**: (KBW) Significantly restructured.</span>
<span class="sd">    | **23 Feb 2017**: (KBW) Use DAPFitsUtil read and write functions.</span>
<span class="sd">    | **21 Aug 2017**: (KBW) Use the new PRE-pixelized assessments of</span>
<span class="sd">        the LSF.</span>
<span class="sd">        </span>
<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _logging.Logger: https://docs.python.org/3/library/logging.html</span>
<span class="sd">.. _numpy.ma.MaskedArray: http://docs.scipy.org/doc/numpy-1.10.1/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray</span>

<span class="sd">.. todo::</span>
<span class="sd">    - Check binning an RSS file</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">spatial</span><span class="p">,</span> <span class="n">interpolate</span>

<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="k">import</span> <span class="n">WCS</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>

<span class="kn">from</span> <span class="nn">..drpfits</span> <span class="k">import</span> <span class="n">DRPFits</span>
<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span><span class="p">,</span> <span class="n">rec_to_fits_type</span><span class="p">,</span> <span class="n">create_symlink</span>
<span class="kn">from</span> <span class="nn">..util.parser</span> <span class="k">import</span> <span class="n">DefaultConfig</span>
<span class="kn">from</span> <span class="nn">..util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">spectral_coordinate_step</span>
<span class="kn">from</span> <span class="nn">..util.covariance</span> <span class="k">import</span> <span class="n">Covariance</span>
<span class="kn">from</span> <span class="nn">..util.geometry</span> <span class="k">import</span> <span class="n">SemiMajorAxisCoo</span>
<span class="kn">from</span> <span class="nn">..util.extinction</span> <span class="k">import</span> <span class="n">GalacticExtinction</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_source</span><span class="p">,</span> <span class="n">default_dap_common_path</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_file_name</span><span class="p">,</span> <span class="n">default_cube_pixelscale</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">spatialbinning</span>
<span class="kn">from</span> <span class="nn">.reductionassessments</span> <span class="k">import</span> <span class="n">ReductionAssessment</span>
<span class="kn">from</span> <span class="nn">.spectralstack</span> <span class="k">import</span> <span class="n">SpectralStackPar</span><span class="p">,</span> <span class="n">SpectralStack</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">select_proc_method</span><span class="p">,</span> <span class="n">replace_with_data_from_nearest_coo</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>
<span class="c1">#from memory_profiler import profile</span>

<span class="c1"># Add strict versioning</span>
<span class="c1"># from distutils.version import StrictVersion</span>


<div class="viewcode-block" id="SpatiallyBinnedSpectraDef"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectraDef">[docs]</a><span class="k">class</span> <span class="nc">SpatiallyBinnedSpectraDef</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that holds the two parameter sets and the key designator for</span>
<span class="sd">    the binning scheme.</span>

<span class="sd">    binfunc must be able to function properly with the following call:</span>
<span class="sd">        </span>
<span class="sd">        id = bin(x, y, par=par)</span>

<span class="sd">    where ``x`` and ``y`` are the on-sky Cartesian coordiantes provided</span>
<span class="sd">    by::</span>
<span class="sd">        </span>
<span class="sd">        x = ReductionAssessment.hdu[&#39;SPECTRUM&#39;].data[&#39;SKY_COO&#39;][:,0]</span>
<span class="sd">        y = ReductionAssessment.hdu[&#39;SPECTRUM&#39;].data[&#39;SKY_COO&#39;][:,1]</span>

<span class="sd">    id is the index of the bin to place each spectrum.</span>

<span class="sd">    stackfunc must be able to function properly with the following</span>
<span class="sd">    call::</span>
<span class="sd">        </span>
<span class="sd">        stack_wave, stack_flux, stack_sdev, stack_npix, stack_ivar, \</span>
<span class="sd">                stack_sres, stack_covar = stack(drpf, id, par=par)</span>

<span class="sd">    where `drpf` is a :class:`mangadap.drpfits.DRPFits` object.  Note</span>
<span class="sd">    that the input and output wavelength ranges are expected to be the</span>
<span class="sd">    same!  This is why the wavelengths are not returned!</span>

<span class="sd">    As long as they are mutable, the values in par can change, meaning</span>
<span class="sd">    that some products of the bin algorithm can be passed to the stack</span>
<span class="sd">    algorithm.  For example, if you want to weight the inclusion of the</span>
<span class="sd">    spectrum in the bin, you&#39;d have to provide both the binning and</span>
<span class="sd">    stacking routines.  Actually, if that&#39;s the case, you&#39;re better off</span>
<span class="sd">    providing a class object that will both bin and stack the spectra!</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Impose a set of options of the form for the Galactic</span>
<span class="sd">          reddening.</span>

<span class="sd">    Args:</span>
<span class="sd">        key (str): Keyword used to distinguish between different spatial</span>
<span class="sd">            binning schemes.</span>
<span class="sd">        binpar (:class:`mangadap.par.parset.ParSet` or dict): The</span>
<span class="sd">            parameter set defining how to place each spectrum in a bin.</span>
<span class="sd">        binclass (object): Instance of class object to use for the</span>
<span class="sd">            binning.  Needed in case binfunc is a non-static member</span>
<span class="sd">            function of the class.</span>
<span class="sd">        binfunc (callable): The function that determines which spectra</span>
<span class="sd">            go into each bin.</span>
<span class="sd">        stackpar (:class:`mangadap.par.parset.ParSet` or dict): The parameter</span>
<span class="sd">            set defining how to stack the spectra in each bin.</span>
<span class="sd">        stackclass (object): Instance of class object to used to stack</span>
<span class="sd">            the spectra.  Needed in case stackfunc is a non-static</span>
<span class="sd">            member function of the class.</span>
<span class="sd">        stackfunc (callable): The function that stacks the spectra in a</span>
<span class="sd">            given bin.</span>
<span class="sd">        spec_res (str): Keyword defining the treatment of the spectral</span>
<span class="sd">            resolution.  See</span>
<span class="sd">            :func:`SpatiallyBinnedSpectra.spectral_resolution_options`</span>
<span class="sd">            for a list of the options.</span>
<span class="sd">        prepixel_sres (bool): Use the prepixelized version of the LSF</span>
<span class="sd">            measurements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">galactic_reddening</span><span class="p">,</span> <span class="n">galactic_rv</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">binpar</span><span class="p">,</span> <span class="n">binclass</span><span class="p">,</span>
                 <span class="n">binfunc</span><span class="p">,</span> <span class="n">stackpar</span><span class="p">,</span> <span class="n">stackclass</span><span class="p">,</span> <span class="n">stackfunc</span><span class="p">,</span> <span class="n">spec_res</span><span class="p">,</span> <span class="n">prepixel_sres</span><span class="p">):</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        <span class="n">res_opt</span> <span class="o">=</span> <span class="n">SpatiallyBinnedSpectra</span><span class="o">.</span><span class="n">spectral_resolution_options</span><span class="p">()</span>
<span class="c1">#        bincls_opt = [ spatialbinning.SpatialBinning ]</span>
<span class="c1">#        stackcls_opt = [ SpectralStack ]</span>
        <span class="n">par_opt</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ParSet</span><span class="p">,</span> <span class="nb">dict</span> <span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;galactic_reddening&#39;</span><span class="p">,</span> <span class="s1">&#39;galactic_rv&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;binpar&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;binclass&#39;</span><span class="p">,</span> <span class="s1">&#39;binfunc&#39;</span><span class="p">,</span> <span class="s1">&#39;stackpar&#39;</span><span class="p">,</span> <span class="s1">&#39;stackclass&#39;</span><span class="p">,</span> <span class="s1">&#39;stackfunc&#39;</span><span class="p">,</span> <span class="s1">&#39;spec_res&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;prepixel_sres&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">key</span><span class="p">,</span> <span class="n">galactic_reddening</span><span class="p">,</span> <span class="n">galactic_rv</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">binpar</span><span class="p">,</span> <span class="n">binclass</span><span class="p">,</span> <span class="n">binfunc</span><span class="p">,</span>
                     <span class="n">stackpar</span><span class="p">,</span> <span class="n">stackclass</span><span class="p">,</span> <span class="n">stackfunc</span><span class="p">,</span> <span class="n">spec_res</span><span class="p">,</span> <span class="n">prepixel_sres</span> <span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span>  <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">res_opt</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="n">par_opt</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">par_opt</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span> <span class="p">]</span>
        <span class="n">can_call</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="kc">False</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                        <span class="n">can_call</span><span class="o">=</span><span class="n">can_call</span><span class="p">)</span></div>


<div class="viewcode-block" id="validate_spatial_binning_scheme_config"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.validate_spatial_binning_scheme_config">[docs]</a><span class="k">def</span> <span class="nf">validate_spatial_binning_scheme_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Validate the :class:`mangadap.util.parser.DefaultConfig` object with</span>
<span class="sd">    spatial-binning scheme parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        cnfg (:class:`mangadap.util.parser.DefaultConfig`): Object with</span>
<span class="sd">            the spatial-binning method parameters as needed by</span>
<span class="sd">            :class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectraDef`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: Raised if any required keywords do not exist.</span>
<span class="sd">        ValueError: Raised if keys have unacceptable values.</span>
<span class="sd">        FileNotFoundError: Raised if a file is specified but could not</span>
<span class="sd">            be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for required keywords</span>

    <span class="n">required_keywords</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;spec_res&#39;</span> <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">all_required</span><span class="p">(</span><span class="n">required_keywords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keywords </span><span class="si">{0}</span><span class="s1"> must all have valid values.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_keywords</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span> <span class="s1">&#39;voronoi&#39;</span><span class="p">,</span> <span class="s1">&#39;radial&#39;</span> <span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown binning method: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]))</span>

    <span class="n">covar_par_needed_modes</span> <span class="o">=</span> <span class="n">SpectralStack</span><span class="o">.</span><span class="n">covariance_mode_options</span><span class="p">(</span><span class="n">par_needed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;stack_covariance_mode&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">covar_par_needed_modes</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;stack_covariance_par&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must provide a parameter for covariance mode </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                         <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;stack_covariance_mode&#39;</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span> <span class="p">]:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;voronoi&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;target_snr&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keyword </span><span class="se">\&#39;</span><span class="s1">target_snr</span><span class="se">\&#39;</span><span class="s1"> must be provided for Voronoi binning.&#39;</span><span class="p">)</span>

    <span class="n">required_keywords</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;pa&#39;</span><span class="p">,</span> <span class="s1">&#39;ell&#39;</span><span class="p">,</span> <span class="s1">&#39;radii&#39;</span> <span class="p">]</span>
    <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;radial&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">all_required</span><span class="p">(</span><span class="n">required_keywords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keywords </span><span class="si">{0}</span><span class="s1"> must all have valid values for radial binning.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">required_keywords</span><span class="p">))</span></div>



<div class="viewcode-block" id="available_spatial_binning_methods"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.available_spatial_binning_methods">[docs]</a><span class="k">def</span> <span class="nf">available_spatial_binning_methods</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the list of available binning schemes.</span>
<span class="sd">    </span>
<span class="sd">    The list of available binning schemes is defined by the set of</span>
<span class="sd">    configuration files at::</span>

<span class="sd">        config_path = os.path.join(dapsrc, &#39;python&#39;, &#39;mangadap&#39;, &#39;config&#39;, &#39;spatial_binning&#39;)</span>
<span class="sd">        ini_files = glob.glob(os.path.join(config_path, &#39;/*.ini&#39;))</span>

<span class="sd">    Args:</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_source`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of</span>
<span class="sd">        :func:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectraDef`</span>
<span class="sd">        objects, each defining a separate binning method.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotADirectoryError: Raised if the provided or default</span>
<span class="sd">            *dapsrc* is not a directory.</span>
<span class="sd">        OSError/IOError: Raised if no binning scheme configuration files</span>
<span class="sd">            could be found.</span>
<span class="sd">        KeyError: Raised if the binning method keywords are not all</span>
<span class="sd">            unique.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Somehow add a python call that reads the databases and</span>
<span class="sd">          constructs the table for presentation in sphinx so that the</span>
<span class="sd">          text above doesn&#39;t have to be edited with changes in the</span>
<span class="sd">          available databases.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the source directory exists</span>
    <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotADirectoryError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> does not exist!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">))</span>

    <span class="c1"># Check the configuration files exist</span>
    <span class="n">ini_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">+</span><span class="s1">&#39;/python/mangadap/config/spatial_binning/*.ini&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ini_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Could not find any configuration files in </span><span class="si">{0}</span><span class="s1"> !&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                      <span class="n">dapsrc</span><span class="o">+</span><span class="s1">&#39;/python/mangadap/config/spatial_binning&#39;</span><span class="p">))</span>

    <span class="c1"># Build the list of library definitions</span>
    <span class="n">binning_methods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ini_files</span><span class="p">:</span>
        <span class="c1"># Read the config file</span>
        <span class="n">cnfg</span> <span class="o">=</span> <span class="n">DefaultConfig</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># Ensure it has the necessary elements to define the template</span>
        <span class="c1"># library</span>
        <span class="n">validate_spatial_binning_scheme_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
            <span class="n">binpar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">binclass</span> <span class="o">=</span> <span class="n">spatialbinning</span><span class="o">.</span><span class="n">GlobalBinning</span><span class="p">()</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="n">binclass</span><span class="o">.</span><span class="n">bin_index</span>
        <span class="k">elif</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;radial&#39;</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">radii</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s1">&#39;radii&#39;</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">radii</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">radii</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">binpar</span> <span class="o">=</span> <span class="n">spatialbinning</span><span class="o">.</span><span class="n">RadialBinningPar</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;pa&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">),</span>
                                                     <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;ell&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">),</span>
                                                     <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;radius_scale&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.</span><span class="p">),</span>
                                                     <span class="n">radii</span><span class="p">,</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;log_step&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">binclass</span> <span class="o">=</span> <span class="n">spatialbinning</span><span class="o">.</span><span class="n">RadialBinning</span><span class="p">()</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="n">binclass</span><span class="o">.</span><span class="n">bin_index</span>
        <span class="k">elif</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;voronoi&#39;</span><span class="p">:</span>
            <span class="n">binpar</span> <span class="o">=</span> <span class="n">spatialbinning</span><span class="o">.</span><span class="n">VoronoiBinningPar</span><span class="p">(</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;target_snr&#39;</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                                      <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;noise_calib&#39;</span><span class="p">))</span>
            <span class="n">binclass</span> <span class="o">=</span> <span class="n">spatialbinning</span><span class="o">.</span><span class="n">VoronoiBinning</span><span class="p">()</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="n">binclass</span><span class="o">.</span><span class="n">bin_index</span>
        <span class="k">else</span><span class="p">:</span>   <span class="c1"># Do not bin!</span>
            <span class="n">binpar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">binclass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">binfunc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">stack_spec_res</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spec_res&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;spaxel&#39;</span>
        <span class="n">prepixel_sres</span> <span class="o">=</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;prepixel_sres&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">stackpar</span> <span class="o">=</span> <span class="n">SpectralStackPar</span><span class="p">(</span><span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;operation&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">),</span>
                                    <span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;velocity_register&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack_covariance_mode&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">),</span>
                                    <span class="n">SpectralStack</span><span class="o">.</span><span class="n">parse_covariance_parameters</span><span class="p">(</span>
                                            <span class="n">cnfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stack_covariance_mode&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">),</span>
                                            <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;stack_covariance_par&#39;</span><span class="p">]),</span>
                                    <span class="n">stack_spec_res</span><span class="p">,</span> <span class="n">prepixel_sres</span><span class="p">)</span>
        <span class="n">stackclass</span> <span class="o">=</span> <span class="n">SpectralStack</span><span class="p">()</span>
        <span class="n">stackfunc</span> <span class="o">=</span> <span class="n">stackclass</span><span class="o">.</span><span class="n">stack_DRPFits</span>

        <span class="n">binning_methods</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">SpatiallyBinnedSpectraDef</span><span class="p">(</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;galactic_reddening&#39;</span><span class="p">],</span>
                                                       <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;galactic_rv&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.1</span><span class="p">),</span>
                                                       <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">),</span>
                                                       <span class="n">binpar</span><span class="p">,</span> <span class="n">binclass</span><span class="p">,</span> <span class="n">binfunc</span><span class="p">,</span> <span class="n">stackpar</span><span class="p">,</span>
                                                       <span class="n">stackclass</span><span class="p">,</span> <span class="n">stackfunc</span><span class="p">,</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;spec_res&#39;</span><span class="p">],</span>
                                                       <span class="n">prepixel_sres</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1"># Check the keywords of the libraries are all unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">binning_methods</span> <span class="p">])</span> <span class="p">))</span> \
            <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">binning_methods</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Spatial binning method keywords are not all unique!&#39;</span><span class="p">)</span>

    <span class="c1"># Return the default list of assessment methods</span>
    <span class="k">return</span> <span class="n">binning_methods</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectraBitMask"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectraBitMask">[docs]</a><span class="k">class</span> <span class="nc">SpatiallyBinnedSpectraBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class that specifies the mask bits for the spatially binned</span>
<span class="sd">    spectra.  See :class:`mangadap.util.bitmask.BitMask` for attributes.</span>

<span class="sd">    A list of the bits and meanings are provided by the base class</span>
<span class="sd">    function :func:`mangadap.util.bitmask.BitMask.info`; i.e.,::</span>

<span class="sd">        from mangadap.proc.spatiallybinnedspectra import SpatiallyBinnedSpectraBitMask</span>
<span class="sd">        bm = SpatiallyBinnedSpectraBitMask()</span>
<span class="sd">        bm.info()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;mangadap&#39;</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">,</span>
                                                     <span class="s1">&#39;bitmasks&#39;</span><span class="p">,</span>
                                                     <span class="s1">&#39;spatially_binned_spectra_bits.ini&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra">[docs]</a><span class="k">class</span> <span class="nc">SpatiallyBinnedSpectra</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that holds spatially binned spectra.</span>

<span class="sd">    Args:</span>
<span class="sd">        method_key (str): The keyword that designates which method,</span>
<span class="sd">            provided in *method_list*, to use for the binning procedure.  </span>
<span class="sd">        drpf (:class:`mangadap.drpfits.DRPFits`): The DRP datacube with</span>
<span class="sd">            the spectra to bin.</span>
<span class="sd">        rdxqa (:class:`mangadap.proc.reductionassessments.ReductionAssessments`):</span>
<span class="sd">            The basic assessments of the DRP data that are needed for</span>
<span class="sd">            the binning procedures.</span>
<span class="sd">        reff (float): (**Optional**) The effective radius of the galaxy.</span>
<span class="sd">        method_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`SpatiallyBinnedSpectraDef` objects that define one</span>
<span class="sd">            or more methods to use for the spatial binning.  Default is</span>
<span class="sd">            to use the config files in the DAP source directory to</span>
<span class="sd">            construct the available methods using</span>
<span class="sd">            :func:`available_spatial_binning_methods`.</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_source`.</span>
<span class="sd">        dapver (str): (**Optional**) The DAP version to use for the</span>
<span class="sd">            analysis, used to override the default defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_version`.</span>
<span class="sd">        analysis_path (str): (**Optional**) The top-level path for the</span>
<span class="sd">            DAP output files, used to override the default defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">        directory_path (str): The exact path to the directory with DAP</span>
<span class="sd">            output that is common to number DAP &quot;methods&quot;.  See</span>
<span class="sd">            :attr:`directory_path`.</span>
<span class="sd">        output_file (str): (**Optional**) Exact name for the output</span>
<span class="sd">            file.  The default is to use</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">        hardcopy (bool): (**Optional**) Flag to write the HDUList</span>
<span class="sd">            attribute to disk.  Default is True; if False, the HDUList</span>
<span class="sd">            is only kept in memory and would have to be reconstructed.</span>
<span class="sd">        symlink_dir (str): (**Optional**) Create a symbolic link to the</span>
<span class="sd">            created file in the supplied directory.  Default is to</span>
<span class="sd">            produce no symbolic link.</span>
<span class="sd">        clobber (bool): (**Optional**) Overwrite any existing files.</span>
<span class="sd">            Default is to use any existing file instead of redoing the</span>
<span class="sd">            analysis and overwriting the existing output.</span>
<span class="sd">        checksum (bool): (**Optional**) Use the checksum in the fits</span>
<span class="sd">            header to confirm that the data has not been corrupted.  The</span>
<span class="sd">            checksum is **always** written to the fits header when the</span>
<span class="sd">            file is created; this argument does not toggle that</span>
<span class="sd">            functionality.</span>
<span class="sd">        loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">            to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">            using :func:`mangadap.util.log.log_output`.  Default is no</span>
<span class="sd">            logging.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress all terminal and logging</span>
<span class="sd">            output.  Default is False.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        loggers (list): List of `logging.Logger`_ objects to log</span>
<span class="sd">            progress; ignored if quiet=True.  Logging is done using</span>
<span class="sd">            :func:`mangadap.util.log.log_output`.</span>
<span class="sd">        quiet (bool): Suppress all terminal and logging output.</span>


<span class="sd">    .. todo::</span>
<span class="sd">        - Allow velocity offsets for registration.</span>
<span class="sd">   </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    @profile</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_key</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">rdxqa</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Define the method properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_define_method</span><span class="p">(</span><span class="n">method_key</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="n">method_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">galext</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Define the output directory and file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># Set in _set_paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Define the bitmask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">SpatiallyBinnedSpectraBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="c1"># Initialize the main class attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_spectral_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_image_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Bin the spectra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_spectra</span><span class="p">(</span><span class="n">drpf</span><span class="p">,</span> <span class="n">rdxqa</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="n">reff</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span>
                         <span class="n">directory_path</span><span class="o">=</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="n">output_file</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="n">hardcopy</span><span class="p">,</span>
                         <span class="n">symlink_dir</span><span class="o">=</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


<span class="c1">#    def __del__(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Deconstruct the data object by ensuring that the fits file is</span>
<span class="c1">#        properly closed.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if self.hdu is None:</span>
<span class="c1">#            return</span>
<span class="c1">#        self.hdu.close()</span>
<span class="c1">#        self.hdu = None</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._define_method"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._define_method">[docs]</a>    <span class="k">def</span> <span class="nf">_define_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_key</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Select the method</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab the specific method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">select_proc_method</span><span class="p">(</span><span class="n">method_key</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectraDef</span><span class="p">,</span>
                                         <span class="n">method_list</span><span class="o">=</span><span class="n">method_list</span><span class="p">,</span>
                                         <span class="n">available_func</span><span class="o">=</span><span class="n">available_spatial_binning_methods</span><span class="p">,</span>
                                         <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._fill_method_par"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._fill_method_par">[docs]</a>    <span class="k">def</span> <span class="nf">_fill_method_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">good_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalize the binning parameters, as needed.</span>

<span class="sd">        **For the radial binning**, set the ellipticity and position</span>
<span class="sd">        angle.  Set scale radius to the effective radius if desired.</span>

<span class="sd">        **For the Voronoi binning**, set the signal and noise.</span>

<span class="sd">        Args:</span>
<span class="sd">            good_spec (numpy.ndarray):  List of spectra to include in</span>
<span class="sd">                the binning.  See :func:`check_fgoodpix` and</span>
<span class="sd">                :func:`_check_snr`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># For the radial binning, fill in the isophotal and scaling</span>
        <span class="c1"># parameters, if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bintype</span> <span class="o">==</span> <span class="s1">&#39;radial&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;pa&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;pa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">pa</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;ell&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;ell&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">ell</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;radius_scale&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;radius_scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">reff</span>

        <span class="c1"># For the Voronoi binning type, add the signal and noise (or</span>
        <span class="c1"># covariance)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bintype</span> <span class="o">==</span> <span class="s1">&#39;voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">correlation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Overwrite any existing calibration coefficient</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">correlation</span><span class="o">.</span><span class="n">revert_correlation</span><span class="p">()</span>
<span class="c1">#                self.rdxqa.correlation.show()</span>
                <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">correlation</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="n">good_spec</span><span class="p">,:][:,</span><span class="n">good_spec</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">correlation</span><span class="o">.</span><span class="n">to_correlation</span><span class="p">()</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;covar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Covariance</span><span class="p">(</span>
                                <span class="n">inp</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">covar</span><span class="p">[</span><span class="n">covar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                      <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">covar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">j</span><span class="p">[</span><span class="n">covar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())),</span>
                                                      <span class="n">shape</span><span class="o">=</span><span class="n">covar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">())</span>
<span class="c1">#                self.method[&#39;binpar&#39;][&#39;covar&#39;].show()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">][</span><span class="s1">&#39;noise&#39;</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VARIANCE&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">])</span></div>

        <span class="c1"># Nothing to add for binning types &#39;none&#39; or &#39;global&#39;, or</span>
        <span class="c1"># user-defined function!</span>



<div class="viewcode-block" id="SpatiallyBinnedSpectra._set_paths"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the I/O path to the processed template library.  Used to set</span>
<span class="sd">        :attr:`directory_path` and :attr:`output_file`.  If not</span>
<span class="sd">        provided, the defaults are set using, respectively,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_common_path` and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_file_name`.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory_path (str): The exact path to the directory with</span>
<span class="sd">                DAP output that is common to number DAP &quot;methods&quot;.  See</span>
<span class="sd">                :attr:`directory_path`.</span>
<span class="sd">            dapver (str): DAP version.</span>
<span class="sd">            analysis_path (str): The path to the top-level directory</span>
<span class="sd">                containing the DAP output files for a given DRP and DAP</span>
<span class="sd">                version.</span>
<span class="sd">            output_file (str): The name of the file with the reduction assessments.</span>
<span class="sd">                See :func:`compute`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the output directory path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="n">default_dap_common_path</span><span class="p">(</span><span class="n">plate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span>
                                                      <span class="n">ifudesign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span>
                                                      <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                                                      <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">directory_path</span><span class="p">)</span>

        <span class="c1"># Set the output file</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">default_dap_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._initialize_primary_header"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._initialize_primary_header">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_primary_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the header of :attr:`hdu`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            astropy.io.fits.Header : Edited header object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy the from the DRP and clean it</span>
        <span class="k">if</span> <span class="n">hdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">clean_dap_primary_header</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        
        <span class="c1"># Add keywords specific to this object</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;AUTHOR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Kyle B. Westfall &lt;westfall@ucolick.org&gt;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;REFF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reff</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;BINKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Spectal binning method keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;BINMINSN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span> <span class="s1">&#39;Minimum S/N of spectrum to include&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;FSPCOV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;Minimum allowed fraction of good pixels&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;NBINS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="s1">&#39;Number of unique spatial bins&#39;</span><span class="p">)</span>
<span class="c1">#        if len(self.missing_bins) &gt; 0:</span>
<span class="c1">#            hdr[&#39;EMPTYBIN&#39;] = (str(self.missing_bins), &#39;List of bins with no data&#39;)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._add_method_header"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._add_method_header">[docs]</a>    <span class="k">def</span> <span class="nf">_add_method_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add method-specific metadata to the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unbinned</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;BINTYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="s1">&#39;Binning method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;BINTYPE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bintype</span><span class="p">,</span> <span class="s1">&#39;Binning method&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Binning parameter class has no attribute bintype.  No type &#39;</span> \
                                  <span class="s1">&#39;written to the header of the output fits file.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toheader</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Binning parameter class does not have toheader() function.  &#39;</span> \
                              <span class="s1">&#39;No binning parameters written to the header of the output &#39;</span> \
                              <span class="s1">&#39;fits file.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toheader</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toheader</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stacking parameter class does not have toheader() function.  &#39;</span> \
                              <span class="s1">&#39;No stacking parameters written to the header of the output &#39;</span> \
                              <span class="s1">&#39;fits file.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">toheader</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._add_reddening_header"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._add_reddening_header">[docs]</a>    <span class="k">def</span> <span class="nf">_add_reddening_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the relevant reddening information to the header.</span>

<span class="sd">        Args:</span>
<span class="sd">            hdr (astropy.io.fits.Header): Input header object to edit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            astropy.io.fits.Header : Edited header object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;EBVGAL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EBVGAL&#39;</span><span class="p">],</span> <span class="s1">&#39;Galactic reddening E(B-V)&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;GEXTLAW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">form</span><span class="p">),</span> <span class="s1">&#39;Galactic extinction law&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;RVGAL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">rv</span><span class="p">,</span> <span class="s1">&#39;Ratio of total to selective extinction, R(V)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._initialize_cube_mask"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._initialize_cube_mask">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_cube_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the mask, copying the DIDNOTUSE and FORESTAR bits</span>
<span class="sd">        from the DRP file, and setting the LOW_SPECCOV and LOW_SNR bits</span>
<span class="sd">        based on the input boolean arrays.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : Bitmask array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the spaxels with good spectral coverage and S/N</span>
        <span class="n">good_fgoodpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_fgoodpix</span><span class="p">()</span>
        <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr</span><span class="p">()</span>

        <span class="c1"># Initialize to all zeros</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>

        <span class="c1"># Turn on the flag stating that the pixel wasn&#39;t used</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                         <span class="n">flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">do_not_stack_flags</span><span class="p">())</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that the pixel has a foreground star</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that the number of valid channels in</span>
        <span class="c1"># the spectrum was below the input fraction.</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_fgoodpix</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;LOW_SPECCOV&#39;</span><span class="p">)</span>

        <span class="c1"># Turn on the flag stating that the S/N in the spectrum was</span>
        <span class="c1"># below the requested limit</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;LOW_SNR&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._check_snr"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._check_snr">[docs]</a>    <span class="k">def</span> <span class="nf">_check_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which spectra in :attr:`rdxqa` have a S/N greater than</span>
<span class="sd">        the minimum set by :attr:`method`.  Only these spectra will be</span>
<span class="sd">        included in the binning.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : Boolean array for the spectra that satisfy</span>
<span class="sd">            the criterion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._assign_spectral_arrays"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._assign_spectral_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_spectral_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set :attr:`spectral_arrays`, which contains the list of</span>
<span class="sd">        extensions in :attr:`hdu` that contain spectral data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="s1">&#39;IVAR&#39;</span><span class="p">,</span> <span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="s1">&#39;SPECRES&#39;</span><span class="p">,</span> <span class="s1">&#39;FLUXD&#39;</span><span class="p">,</span> <span class="s1">&#39;NPIX&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._assign_image_arrays"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._assign_image_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_image_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set :attr:`image_arrays`, which contains the list of extensions</span>
<span class="sd">        in :attr:`hdu` that are on-sky image data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;BINID&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._per_bin_dtype"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._per_bin_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">_per_bin_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the record array data type that holds the information</span>
<span class="sd">        for the binned spectra.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            There currently is no mask; however, could add masks for:</span>
<span class="sd">                - Insufficient good wavelength channels in the spectrum.</span>
<span class="sd">                - Variance in flux in bin is too large.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;BINID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NBIN&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;LW_SKY_COO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;AREA&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AREA_FRAC&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;VARIANCE&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;SNR&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
               <span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._get_missing_bins"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._get_missing_bins">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_missing_bins</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">))</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._unbinned_data_table"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._unbinned_data_table">[docs]</a>    <span class="k">def</span> <span class="nf">_unbinned_data_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the output data table for the unbinned spectra.</span>

<span class="sd">        Args:</span>
<span class="sd">            bin_indx (numpy.ndarray): The integer vector with the bin</span>
<span class="sd">                associated with each spectrum in the DRP cube.  This is</span>
<span class="sd">                the flattened BINID array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.recarray : The record array that is put in the BINS</span>
<span class="sd">            extension of :attr:`hdu`.</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the spectra that have a bin ID</span>
        <span class="n">good_spec</span> <span class="o">=</span> <span class="n">bin_indx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="p">[]</span>                  <span class="c1"># No missing bins</span>

        <span class="c1"># Copy the data from the ReductionAssessments object</span>
        <span class="n">bin_data</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_bin_dtype</span><span class="p">())</span>

        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_SKY_COO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">pixelscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">default_cube_pixelscale</span><span class="p">()</span>

        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">),</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA_FRAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;VARIANCE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VARIANCE&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">bin_data</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._interpolated_response_function"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._interpolated_response_function">[docs]</a>    <span class="k">def</span> <span class="nf">_interpolated_response_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">response_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;response_func&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">response_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Just return a uniform response function</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">response_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">response_func</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._binned_data_table"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._binned_data_table">[docs]</a>    <span class="k">def</span> <span class="nf">_binned_data_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_indx</span><span class="p">,</span> <span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">per_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the output data table for the binned spectra.</span>

<span class="sd">        Args:</span>
<span class="sd">            bin_indx (numpy.ndarray): The integer vector with the bin</span>
<span class="sd">                associated with each spectrum in the DRP cube.  This is</span>
<span class="sd">                the flattened BINID array.</span>
<span class="sd">            stack_flux (numpy.ndarray): The stacked spectra, organized</span>
<span class="sd">                as :math:`N_{\rm spec}\times\N_\lambda}`.</span>
<span class="sd">            stack_flux (numpy.ndarray): The stacked inverse variance,</span>
<span class="sd">                organized as :math:`N_{\rm spec}\times\N_\lambda}`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.recarray : The record array that is put in the BINS</span>
<span class="sd">            extension of :attr:`hdu`.</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the unique bins and the number of spectra in each bin</span>
        <span class="n">unique_bins</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">unique_bins</span><span class="p">,</span> <span class="n">unique_indx</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                  <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                               <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Get the number of returned bins:</span>
        <span class="c1"># - The number of returned bins MAY NOT BE THE SAME as the</span>
        <span class="c1">#   number of requested bins.  E.g., if radial bins were</span>
        <span class="c1">#   requested out to 2.5 Reff, when coverage only goes to 1.5</span>
        <span class="c1">#   Reff.</span>
        <span class="c1"># - Bins with no spectra are not included in the data table!</span>
        <span class="c1"># - Missing bins are only identified as those without indices in</span>
        <span class="c1">#   the range of provided bin numbers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="n">SpatiallyBinnedSpectra</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">)</span>

        <span class="c1"># Intialize the data for the binned spectra</span>
        <span class="n">bin_data</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_per_bin_dtype</span><span class="p">())</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_bins</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_count</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Recalculate the mean signal, mean noise, and mean S/N of the</span>
        <span class="c1"># binned spectra</span>
<span class="c1">#        print(numpy.sum(stack_ivar.mask))</span>
<span class="c1">#        print(numpy.sum(stack_flux.mask))</span>
<span class="c1">#        assert numpy.all(stack_ivar.mask == stack_flux.mask)</span>
        <span class="k">if</span> <span class="n">stack_ivar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No inverse variance for stack.  Errors set to unity.&#39;</span><span class="p">)</span>

        <span class="n">_wavelength_mask</span> <span class="o">=</span> <span class="n">SpectralPixelMask</span><span class="p">(</span><span class="n">waverange</span><span class="o">=</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;waverange&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">stack_flux</span><span class="p">)</span> <span class="o">|</span> <span class="n">_wavelength_mask</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

        <span class="k">if</span> <span class="n">stack_ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">|=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">stack_ivar</span><span class="p">)</span>

        <span class="n">_stack_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">stack_flux</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">)</span>

        <span class="c1"># Same as in mangadap.drpfits.DRPFits.flux_stats() ...</span>
        <span class="c1"># Set the response function</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">per_pixel</span> <span class="k">else</span> \
                    <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                             <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">_response_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolated_response_function</span><span class="p">()</span>
        <span class="c1"># Get the signal</span>
        <span class="n">response_integral</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">_stack_flux</span><span class="p">))</span>
                                        <span class="o">*</span> <span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#        print(bin_data[&#39;SIGNAL&#39;].shape)</span>
<span class="c1">#        print(_stack_flux.shape)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_stack_flux</span><span class="o">*</span><span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span>
                                                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">response_integral</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># And the variance and SNR if the inverse variance is available</span>
        <span class="k">if</span> <span class="n">stack_ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_stack_ivar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">stack_ivar</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">)</span>
            <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;VARIANCE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">_stack_ivar</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span> \
                                                        <span class="o">*</span> <span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">response_integral</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_stack_flux</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_stack_ivar</span><span class="p">)</span>
                                                            <span class="o">*</span> <span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                            <span class="n">response_integral</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">_stack_ivar</span>
        <span class="k">del</span> <span class="n">_mask</span><span class="p">,</span> <span class="n">_stack_flux</span>

<span class="c1">#        indx = bin_indx == 0</span>
<span class="c1">#        print(self.rdxqa[&#39;SPECTRUM&#39;].data[&#39;SIGNAL&#39;][indx])</span>
<span class="c1">#        print(bin_data[&#39;SIGNAL&#39;][0])</span>
<span class="c1">#        print(self.rdxqa[&#39;SPECTRUM&#39;].data[&#39;VARIANCE&#39;][indx])</span>
<span class="c1">#        print(bin_data[&#39;VARIANCE&#39;][0])</span>
<span class="c1">#        print(self.rdxqa[&#39;SPECTRUM&#39;].data[&#39;SNR&#39;][indx])</span>
<span class="c1">#        print(bin_data[&#39;SNR&#39;][0])</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.scatter(self.rdxqa[&#39;SPECTRUM&#39;].data[&#39;SNR&#39;][unique_indx], bin_data[&#39;SNR&#39;])</span>
<span class="c1">#        pyplot.plot([0,100],[0,100],color=&#39;k&#39;)</span>
<span class="c1">#        pyplot.show()</span>
    
<span class="c1">#        pyplot.imshow(bin_indx.reshape((int(numpy.sqrt(len(bin_indx))),)*2))</span>
<span class="c1">#        pyplot.colorbar()</span>
<span class="c1">#        pyplot.show()</span>

<span class="c1">#        pyplot.plot(self.drpf[&#39;WAVE&#39;].data, _response_func)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># TODO: This only works with a limiting wavelength range, not a</span>
        <span class="c1"># response function</span>
<span class="c1">#        stack_nsum = numpy.sum(numpy.invert(_mask), axis=1)</span>
<span class="c1">#        bin_data[&#39;SIGNAL&#39;] = numpy.ma.sum(_stack_flux,axis=1) / stack_nsum</span>
<span class="c1">#        if stack_ivar is not None:</span>
<span class="c1">#            _stack_ivar = numpy.ma.MaskedArray(stack_ivar.data, mask=_mask)</span>
<span class="c1">#            bin_data[&#39;VARIANCE&#39;] = numpy.ma.sum(numpy.ma.power(_stack_ivar, -1.), axis=1)/stack_nsum</span>
<span class="c1">#            bin_data[&#39;SNR&#39;] = numpy.ma.sum(_stack_flux * numpy.ma.sqrt(_stack_ivar),</span>
<span class="c1">#                                           axis=1)/stack_nsum</span>
<span class="c1">#            del _stack_ivar</span>
<span class="c1">#        del _mask, _stack_flux</span>


<span class="c1">#        pyplot.scatter(bin_data[&#39;SNR&#39;], bin_data[&#39;SIGNAL&#39;], marker=&#39;.&#39;, color=&#39;k&#39;, s=40, lw=0)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Sort the list of bin ids and determine where the spectra jump</span>
        <span class="c1"># between bins</span>
        <span class="n">srt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">)</span>
        <span class="n">bin_change</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">[</span><span class="n">srt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Some convenience reference variables</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SIGNAL&#39;</span><span class="p">]</span>

        <span class="c1"># Get the signal-weighted on-sky coordinates</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">wsum</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">((</span><span class="n">y</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">wsum</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">((</span><span class="n">r</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">wsum</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">((</span><span class="n">t</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">wsum</span>

        <span class="c1"># ... and the unweighted on-sky coordinates</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span>

        <span class="c1"># The mean azimuth can go wrong when bins cross the major axis</span>
        <span class="n">_wt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(((</span><span class="n">t</span><span class="o">+</span><span class="mi">180</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">)[</span><span class="n">srt</span><span class="p">],</span> <span class="n">bin_change</span><span class="p">)</span><span class="o">/</span><span class="n">wsum</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">_wt</span><span class="o">-</span><span class="mi">180</span><span class="o">-</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1.0</span>        <span class="c1"># HARDWIRED</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;LW_ELL_COO&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wt</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">-</span><span class="mi">180</span>

        <span class="n">_bt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">srt</span><span class="p">]</span><span class="o">+</span><span class="mi">180</span><span class="p">,</span> <span class="n">bin_change</span><span class="p">)</span> <span class="o">/</span> <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;NBIN&#39;</span><span class="p">]</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">_bt</span><span class="o">-</span><span class="mi">180</span><span class="o">-</span><span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1.0</span>           <span class="c1"># HARDWIRED</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;ELL_COO&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_bt</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">-</span><span class="mi">180</span>

<span class="c1">#        pyplot.scatter( wt, _wt-180-bin_data[&#39;LW_ELL_COO&#39;][:,1], marker=&#39;.&#39;,color=&#39;r&#39;,s=40,lw=0 )</span>
<span class="c1">#        pyplot.scatter( bt, _bt-180-bin_data[&#39;ELL_COO&#39;][:,1], marker=&#39;.&#39;,color=&#39;b&#39;,s=40,lw=0 )</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Compute the area covered by each bin</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">binned_on_sky_area</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Calculate the fractional area of the bin covered by the</span>
        <span class="c1"># spectra, if possible; if not, the fractional area is unity</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bin_total_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bin_area</span><span class="p">()[</span><span class="n">unique_bins</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not calculate nominal bin area:: &#39;</span>
                              <span class="s1">&#39;AttributeError: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">bin_total_area</span> <span class="o">=</span> <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA&#39;</span><span class="p">]</span>
        <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA_FRAC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_data</span><span class="p">[</span><span class="s1">&#39;AREA&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">bin_total_area</span>

<span class="c1">#        pyplot.scatter(bin_data[&#39;ELL_COO&#39;][:,0], bin_data[&#39;SNR&#39;])</span>
<span class="c1">#        pyplot.show()</span>

        <span class="k">return</span> <span class="n">bin_data</span></div>

   
<div class="viewcode-block" id="SpatiallyBinnedSpectra._apply_reddening"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._apply_reddening">[docs]</a>    <span class="k">def</span> <span class="nf">_apply_reddening</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">covar</span><span class="p">,</span> <span class="n">deredden</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">form</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">covar</span>

        <span class="c1"># Apply the reddening correction</span>
        <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">deredden</span><span class="o">=</span><span class="n">deredden</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sdev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">deredden</span><span class="o">=</span><span class="n">deredden</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">covar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">input_indx</span><span class="p">):</span>
                <span class="n">covar</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">covar</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">redcorr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="n">deredden</span> \
                                    <span class="k">else</span> <span class="n">covar</span><span class="o">.</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">redcorr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">covar</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra._construct_2d_hdu"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra._construct_2d_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">_construct_2d_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_indx</span><span class="p">,</span> <span class="n">good_fgoodpix</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">,</span> <span class="n">bin_data</span><span class="p">,</span> <span class="n">stack_flux</span><span class="p">,</span>
                          <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_npix</span><span class="p">,</span> <span class="n">stack_mask</span><span class="p">,</span> <span class="n">stack_sres</span><span class="p">,</span> <span class="n">stack_covar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct :attr:`hdu` that is held in memory for manipulation of</span>
<span class="sd">        the object.  See :func:`construct_3d_hdu` if you want to convert</span>
<span class="sd">        the object into a DRP-like datacube.</span>

<span class="sd">        bin_indx is 2d</span>

<span class="sd">        stack_sres is expected to be a MaskedArray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing hdu ...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stack_sres</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stack_sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">stack_covar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stack_covar</span><span class="p">,</span> <span class="n">Covariance</span><span class="p">))</span> \
                                    <span class="k">else</span> <span class="n">stack_covar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="c1">#        print(self.covariance.shape)</span>
<span class="c1">#        self.covariance.show(plane=self.covariance.input_indx[0])</span>

        <span class="c1"># Initialize the headers</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_primary_header</span><span class="p">()</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_header</span><span class="p">(</span><span class="n">pri_hdr</span><span class="p">)</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_reddening_header</span><span class="p">(</span><span class="n">pri_hdr</span><span class="p">)</span>
        <span class="n">red_hdr</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span>
        <span class="n">red_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_reddening_header</span><span class="p">(</span><span class="n">red_hdr</span><span class="p">)</span>
        <span class="n">map_hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">build_map_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span> <span class="s1">&#39;K Westfall &lt;westfall@ucolick.org&gt;&#39;</span><span class="p">)</span>

        <span class="c1"># Get the spatial map mask</span>
        <span class="c1"># Marginalize the DRP spectra over wavelength</span>
        <span class="n">map_mask</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">marginalize_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                <span class="p">[</span> <span class="s1">&#39;NOCOV&#39;</span><span class="p">,</span> <span class="s1">&#39;LOWCOV&#39;</span><span class="p">,</span> <span class="s1">&#39;DEADFIBER&#39;</span><span class="p">,</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;DONOTUSE&#39;</span> <span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                <span class="n">out_flag</span><span class="o">=</span><span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
        <span class="n">map_mask</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">marginalize_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;FORESTAR&#39;</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">out_mask</span><span class="o">=</span><span class="n">map_mask</span><span class="p">)</span>
        <span class="n">drp_bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Add the spectra with low spectral coverage</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_fgoodpix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">drp_bad</span><span class="p">)</span>
        <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;LOW_SPECCOV&#39;</span><span class="p">)</span>
        <span class="c1"># Add the spectra with low S/N</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_snr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">drp_bad</span><span class="p">)</span>
        <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;LOW_SNR&#39;</span><span class="p">)</span>

        <span class="c1"># Fill the covariance HDUs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pri_hdr</span><span class="p">,</span> <span class="n">ivar_hdu</span><span class="p">,</span> <span class="n">covar_hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">output_hdus</span><span class="p">(</span><span class="n">hdr</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">)</span>

        <span class="c1"># Save the data to the hdu attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_flux</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_ivar</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_mask</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_sres</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">redcorr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">red_hdr</span><span class="p">,</span>
                                                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;REDCORR&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_sdev</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUXD&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stack_npix</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NPIX&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINID&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">map_mask</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span> <span class="p">[</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                             <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">bin_data</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                                <span class="n">array</span><span class="o">=</span><span class="n">bin_data</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">bin_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="p">],</span>
                                                               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINS&#39;</span><span class="p">)</span>
                                <span class="p">])</span>

        <span class="c1"># Fill the covariance matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">covar_hdu</span> <span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.file_name"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.file_name">[docs]</a>    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the output file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.file_path"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.file_path">[docs]</a>    <span class="k">def</span> <span class="nf">file_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full path to the output file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="SpatiallyBinnedSpectra.info"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">info</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_unbinned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if the spectra are unbinned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binclass&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binfunc&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.do_not_fit_flags"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.do_not_fit_flags">[docs]</a>    <span class="k">def</span> <span class="nf">do_not_fit_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">,</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">,</span> <span class="s1">&#39;LOW_SPECCOV&#39;</span><span class="p">,</span> <span class="s1">&#39;LOW_SNR&#39;</span><span class="p">,</span> <span class="s1">&#39;NONE_IN_STACK&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.check_fgoodpix"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.check_fgoodpix">[docs]</a>    <span class="k">def</span> <span class="nf">check_fgoodpix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum_fraction</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which spectra in :attr:`rdxqa` have a fractional</span>
<span class="sd">        spectral coverage of greater than the provided minimum fraction.</span>
<span class="sd">        Only these spectra will be included in the binning.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            minimum_fraction (float): (**Optional**) The minimum</span>
<span class="sd">                fraction of the spectrum that must be valid for the</span>
<span class="sd">                spectrum to be included in any bin.  Default is 0.8.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : Boolean array for the spectra that satisfy</span>
<span class="sd">            the criterion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;FGOODPIX&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minimum_fraction</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.above_snr_limit"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.above_snr_limit">[docs]</a>    <span class="k">def</span> <span class="nf">above_snr_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sn_limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flag bins above a provided S/N limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        warnings.warn(&#39;You\&#39;re setting all but two spectra as bad!&#39;)</span>
<span class="c1">#        test = self.hdu[&#39;BINS&#39;].data[&#39;SNR&#39;] &gt; sn_limit</span>
<span class="c1">#        test[:-2] = False</span>
<span class="c1">#        return test</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sn_limit</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.spectral_resolution_options"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.spectral_resolution_options">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">spectral_resolution_options</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the allowed options for treating the spectral resolution.</span>

<span class="sd">        Options are:</span>

<span class="sd">            &#39;spaxel&#39;: If available, use the spectral resolution</span>
<span class="sd">            determined for each spaxel.  This is pulled from the &#39;DISP&#39;</span>
<span class="sd">            extension in the DRP file; an exception will be raised if</span>
<span class="sd">            this extension does not exist!</span>

<span class="sd">            &#39;cube&#39;: Only consider the median spectral resolution</span>
<span class="sd">            determine for the entire datacube.  This is pulled from the</span>
<span class="sd">            &#39;SPECRES&#39; extension in the DRP file; an exception will be</span>
<span class="sd">            raised if this extension does not exist!</span>

<span class="sd">        Returns:</span>
<span class="sd">            list : List of the available method keywords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;spaxel&#39;</span><span class="p">,</span> <span class="s1">&#39;cube&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.bin_spectra"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.bin_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">bin_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">rdxqa</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bin and stack the spectra.</span>

<span class="sd">        Args:</span>
<span class="sd">            drpf (:class:`mangadap.drpfits.DRPFits`): The DRP datacube</span>
<span class="sd">                with the spectra to bin.</span>
<span class="sd">            rdxqa (:class:`mangadap.proc.reductionassessments.ReductionAssessments`):</span>
<span class="sd">                The basic assessments of the DRP data that are needed</span>
<span class="sd">                for the binning procedures.</span>
<span class="sd">            reff (float): (**Optional**) The effective radius of the</span>
<span class="sd">                galaxy.</span>
<span class="sd">            dapver (str): (**Optional**) The DAP version to use for the</span>
<span class="sd">                analysis, used to override the default defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_version`.</span>
<span class="sd">            analysis_path (str): (**Optional**) The top-level path for</span>
<span class="sd">                the DAP output files, used to override the default</span>
<span class="sd">                defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">            directory_path (str): The exact path to the directory with</span>
<span class="sd">                DAP output that is common to number DAP &quot;methods&quot;.  See</span>
<span class="sd">                :attr:`directory_path`.</span>
<span class="sd">            output_file (str): (**Optional**) Exact name for the output</span>
<span class="sd">                file.  The default is to use</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">            hardcopy (bool): (**Optional**) Flag to write the HDUList</span>
<span class="sd">                attribute to disk.  Default is True; if False, the</span>
<span class="sd">                HDUList is only kept in memory and would have to be</span>
<span class="sd">                reconstructed.</span>
<span class="sd">            symlink_dir (str): (**Optional**) Create a symbolic link to</span>
<span class="sd">                the created file in the supplied directory.  Default is</span>
<span class="sd">                to produce no symbolic link.</span>
<span class="sd">            clobber (bool): (**Optional**) Overwrite any existing files.</span>
<span class="sd">                Default is to use any existing file instead of redoing</span>
<span class="sd">                the analysis and overwriting the existing output.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_</span>
<span class="sd">                objects to log progress; ignored if quiet=True.  Logging</span>
<span class="sd">                is done using :func:`mangadap.util.log.log_output`.</span>
<span class="sd">                Default is no logging.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.  Default is False.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># DRPFits object always needed</span>
        <span class="k">if</span> <span class="n">drpf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide DRP file object to compute assessments.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drpf</span><span class="p">,</span> <span class="n">DRPFits</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid DRPFits object!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DRP file previously unopened.  Reading now.&#39;</span><span class="p">)</span>
            <span class="n">drpf</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">()</span>

        <span class="c1"># TODO: How many of these attributes should I keep, vs. just use</span>
        <span class="c1"># drpf attributes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span> <span class="o">=</span> <span class="n">drpf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nspec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">dispaxis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nwave</span>

        <span class="c1"># ReductionAssessment object always needed</span>
        <span class="k">if</span> <span class="n">rdxqa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide a ReductionAssessment object to bin spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rdxqa</span><span class="p">,</span> <span class="n">ReductionAssessment</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid ReductionAssessment object!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span> <span class="o">=</span> <span class="n">rdxqa</span>

        <span class="c1"># Set the Galactic extinction correction defined by the method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">galext</span> <span class="o">=</span> <span class="n">GalacticExtinction</span><span class="p">(</span><span class="n">form</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;galactic_reddening&#39;</span><span class="p">],</span>
                                         <span class="n">wave</span><span class="o">=</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                         <span class="n">ebv</span><span class="o">=</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;EBVGAL&#39;</span><span class="p">],</span>
                                         <span class="n">rv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;galactic_rv&#39;</span><span class="p">])</span>

        <span class="c1"># Save the effective radius if provided.  Only used if/when</span>
        <span class="c1"># scaling the radii by the effective radius in the radial</span>
        <span class="c1"># binning approach</span>
        <span class="k">if</span> <span class="n">reff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="o">=</span> <span class="n">reff</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the good spectra</span>
        <span class="c1">#   - Must have valid pixels over more than 80% of the spectral</span>
        <span class="c1">#   range </span>
        <span class="n">good_fgoodpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_fgoodpix</span><span class="p">()</span>
        <span class="c1">#   - Must have sufficienct S/N, as defined by the input par</span>
        <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr</span><span class="p">()</span>
        <span class="c1"># Good spectra have both these criteria</span>
        <span class="n">good_spec</span> <span class="o">=</span> <span class="n">good_fgoodpix</span> <span class="o">&amp;</span> <span class="n">good_snr</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0:^50}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SPATIALLY BINNING SPECTRA&#39;</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>

            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Total spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="nb">len</span><span class="p">(</span><span class="n">good_fgoodpix</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;With 80</span><span class="si">% s</span><span class="s1">pectral coverage: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_fgoodpix</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;With good S/N: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of good spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_spec</span><span class="p">)))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">form</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Galactic dereddening not applied.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Galactic extinction law: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">form</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Galactic E(B-V) = </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">ebv</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Galactic R(V): </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">rv</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_spec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No good spectra!&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fill in any remaining binning parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_method_par</span><span class="p">(</span><span class="n">good_spec</span><span class="p">)</span>

        <span class="c1"># (Re)Set the output paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># No binning so just fill the hdu with the appropriate data from</span>
        <span class="c1"># the DRP file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unbinned</span><span class="p">:</span>

            <span class="c1"># TODO: This is just a short cut.  Would be better if I</span>
            <span class="c1"># didn&#39;t use this.  I.e., I should treat the function calls</span>
            <span class="c1"># exactly the same, but just create binning and stacking</span>
            <span class="c1"># classes for when the data is unbinned...</span>
        
            <span class="c1"># Report data is unbinned</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                            <span class="s1">&#39;No binning requested; analyzing DRP spaxel data directly.&#39;</span><span class="p">)</span>

            <span class="c1"># Generate pseudo bin index</span>
            <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_index</span><span class="p">[</span><span class="n">good_spec</span><span class="p">]))</span>
            <span class="n">bin_indx</span><span class="p">[</span><span class="n">i</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_spec</span><span class="p">))</span>

<span class="c1">#            pyplot.imshow(bin_indx.reshape(self.drpf.spatial_shape), origin=&#39;lower&#39;,</span>
<span class="c1">#                          interpolation=&#39;nearest&#39;)</span>
<span class="c1">#            pyplot.show()</span>

            <span class="c1"># Build the data arrays directly from the DRP file</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="n">drpf</span><span class="o">.</span><span class="n">do_not_stack_flags</span><span class="p">())[</span><span class="n">good_spec</span><span class="p">,:]</span>

            <span class="n">sdev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ivar</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">,</span>
                                             <span class="n">flag</span><span class="o">=</span><span class="n">drpf</span><span class="o">.</span><span class="n">do_not_stack_flags</span><span class="p">())[</span><span class="n">good_spec</span><span class="p">,:]</span>
            <span class="n">npix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">npix</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">)[</span><span class="n">good_spec</span><span class="p">,:]</span>

            <span class="c1"># The definition of the extension below:</span>
            <span class="c1"># - If the user wants the single resolution vector for the</span>
            <span class="c1">#   entire cube (spec_res = cube), then that extension is</span>
            <span class="c1">#   defined explicitly</span>
            <span class="c1"># - Currently the only other options is spec_res=spaxel.  In</span>
            <span class="c1">#   that case, the extension is set to None so that the</span>
            <span class="c1">#   DRPFits class can properly decide which data to return</span>
            <span class="c1">#   based on whether or not the DISP extension is present.</span>
            <span class="c1"># For MPL-5/DR14 data and earlier, the two spectral</span>
            <span class="c1"># resolution options should result in identical output!</span>
            <span class="c1"># !! Use the new pre-pixelized LSF measurements !!</span>
            <span class="n">specres_ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;spec_res&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cube&#39;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spectral_resolution</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">specres_ext</span><span class="p">,</span> <span class="n">toarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">pre</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;prepixel_sres&#39;</span><span class="p">],</span>
                                                 <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">good_spec</span><span class="p">,:]</span>

            <span class="c1"># TODO: Does this work with any covariance mode?  Don&#39;t like</span>
            <span class="c1"># this back and forth between what is supposed to be a stack</span>
            <span class="c1"># only function</span>
            <span class="c1"># (SpectralStack.build_covariance_data_DRPFits) and</span>
            <span class="c1"># something that is supposed to be indepenent of the details</span>
            <span class="c1"># of the stacking implementation (SpatiallyBinnedSpectra)...</span>

            <span class="c1"># Try to add the covariance data, if requested</span>
            <span class="n">covar</span><span class="o">=</span><span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">][</span><span class="s1">&#39;covar_mode&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Attempting to compute covariance.&#39;</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">build_covariance_data_DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">][</span><span class="s1">&#39;covar_mode&#39;</span><span class="p">],</span> 
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">][</span><span class="s1">&#39;covar_par&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not build covariance data:: &#39;</span>
                                      <span class="s1">&#39;AttributeError: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="n">covar</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covar</span><span class="p">,</span> <span class="n">Covariance</span><span class="p">):</span>
                    <span class="n">covar</span> <span class="o">=</span> <span class="n">covar</span><span class="o">.</span><span class="n">spaxel_to_bin_covariance</span><span class="p">(</span><span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="c1"># Fill the table with the per-spectrum data</span>
            <span class="n">bin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unbinned_data_table</span><span class="p">(</span><span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="c1"># Deredden the spectra if the method requests it</span>
            <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_reddening</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">covar</span><span class="p">)</span>

            <span class="c1"># Build the internal HDUList object and covariance attribute</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">hardcopy</span> <span class="ow">or</span> <span class="n">symlink_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Hardcopies and symlinks of the SpatiallyBinnedSpectra object are &#39;</span>
                              <span class="s1">&#39;never kept when analyzing unbinned data.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_2d_hdu</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">good_fgoodpix</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">,</span> <span class="n">bin_data</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span>
                                   <span class="n">npix</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">covar</span><span class="p">)</span>
            <span class="c1"># Finish</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check that the file path is defined</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ofile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File path for output file is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Output path: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Output file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># If the file already exists, and not clobbering, just read the</span>
        <span class="c1"># file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="o">=</span> <span class="n">symlink_dir</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">clobber</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Reading existing file&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="ow">and</span> <span class="n">reff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="o">!=</span> <span class="n">reff</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Provided effective radius different from available file; set &#39;</span> \
                              <span class="s1">&#39;clobber=True to overwrite.&#39;</span><span class="p">)</span>
            <span class="c1"># Make sure the symlink exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">create_symlink</span><span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Determine how to bin the spectra.  To be included in any bin,</span>
        <span class="c1"># the spectra must be selected as &#39;good&#39; according to the</span>
        <span class="c1"># selections made above.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Binning spectra ...&#39;</span><span class="p">)</span>
        <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">bin_indx</span><span class="p">[</span><span class="n">good_spec</span><span class="p">]</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binfunc&#39;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">par</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_indx</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No spectra in ANY bin!&#39;</span><span class="p">)</span>

<span class="c1">#        # Done for testing missing bins</span>
<span class="c1">#        warnings.warn(&#39;You\&#39;re forcing bins 2 and 3 to be empty!&#39;)</span>
<span class="c1">#        time.sleep(3)</span>
<span class="c1">#        warnings.warn(&#39;Proceeding...&#39;)</span>
<span class="c1">#        bin_indx[ (bin_indx == 2) | (bin_indx == 3) ] = 1</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Stack the spectra in each bin</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Stacking spectra ...&#39;</span><span class="p">)</span>
        <span class="n">stack_wave</span><span class="p">,</span> <span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_npix</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_sres</span><span class="p">,</span> <span class="n">stack_covar</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackfunc&#39;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span> <span class="n">bin_indx</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">stack_covar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stack_covar</span><span class="o">.</span><span class="n">is_correlation</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected to have stack covariance be a correlation matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct the mask</span>
        <span class="n">stack_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stack_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">stack_npix</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stack_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">stack_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;NONE_IN_STACK&#39;</span><span class="p">,</span> <span class="s1">&#39;NO_STDDEV&#39;</span><span class="p">])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">stack_npix</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">stack_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">stack_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;NO_STDDEV&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fill the table with the per-bin data (BEFORE applying the</span>
        <span class="c1"># reddening)</span>
        <span class="n">bin_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binned_data_table</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Deredden the spectra if the method requests it</span>
        <span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_covar</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_reddening</span><span class="p">(</span><span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_covar</span><span class="p">)</span>

<span class="c1">#        if self.galext.form is not None:</span>
<span class="c1">#            stack_flux, stack_ivar = self.galext.apply(stack_flux, ivar=stack_ivar)</span>
<span class="c1">#            stack_sdev = self.galext.apply(stack_sdev)</span>
<span class="c1">#            if stack_covar is not None:</span>
<span class="c1">#                for i,j in enumerate(stack_covar.input_indx):</span>
<span class="c1">#                    stack_covar.cov[i] *= numpy.square(self.galext.redcorr[j])</span>

<span class="c1">#        print(stack_covar.input_indx)</span>
<span class="c1">#        stack_covar.show(plane=0)</span>

<span class="c1">#        indx = int(numpy.where(bin_indx == 4)[0][0])</span>
<span class="c1">#        pyplot.step(self.drpf[&#39;WAVE&#39;].data, self.drpf.select(indx), where=&#39;mid&#39;,</span>
<span class="c1">#                    linestyle=&#39;-&#39;, color=&#39;b&#39;)</span>
<span class="c1">#        pyplot.step(stack_wave, stack_flux[4,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        pyplot.step(self.drpf[&#39;WAVE&#39;].data, self.drpf.select(indx, ext=&#39;IVAR&#39;), where=&#39;mid&#39;,</span>
<span class="c1">#                    linestyle=&#39;-&#39;, color=&#39;b&#39;)</span>
<span class="c1">#        pyplot.step(stack_wave, stack_ivar[4,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Build the internal HDUList object and covariance attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="n">hardcopy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_2d_hdu</span><span class="p">(</span><span class="n">bin_indx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">),</span> <span class="n">good_fgoodpix</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">,</span>
                               <span class="n">bin_data</span><span class="p">,</span> <span class="n">stack_flux</span><span class="p">,</span> <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_npix</span><span class="p">,</span>
                               <span class="n">stack_mask</span><span class="p">,</span> <span class="n">stack_sres</span><span class="p">,</span> <span class="n">stack_covar</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Write the data, if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.construct_3d_hdu"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.construct_3d_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">construct_3d_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reformat the binned spectra into a cube matching the shape of</span>
<span class="sd">        the DRP fits file from which it was derived.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing binned spectra datacube ...&#39;</span><span class="p">)</span>

        <span class="c1"># Get/Copy the necessary data arrays</span>
        <span class="n">bin_indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_sdev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUXD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_ivar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;NPIX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stack_sres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Reconstruct the stacked spectra into a DRP-like datacube</span>
        <span class="n">flux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="n">sres</span> \
                <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                               <span class="p">[</span> <span class="n">stack_flux</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">stack_flux</span><span class="p">),</span>
                                                 <span class="n">stack_sdev</span><span class="p">,</span> <span class="n">stack_ivar</span><span class="p">,</span> <span class="n">stack_npix</span><span class="p">,</span> <span class="n">stack_sres</span> <span class="p">])</span>

        <span class="c1"># TODO: Move this to the Covariance class?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">bin_to_spaxel_covariance</span><span class="p">(</span><span class="n">bin_indx</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

<span class="c1">#        print(self.covariance.input_indx)</span>
<span class="c1">#        self.covariance.show(plane=self.covariance.input_indx[0])</span>

<span class="c1">#        pyplot.imshow(flux.reshape(self.drpf[&#39;FLUX&#39;].shape)[:,:,1000].T, origin=&#39;lower&#39;,</span>
<span class="c1">#                      interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        pyplot.step(stack_wave, flux.reshape(self.drpf[&#39;FLUX&#39;].shape)[20,20,:], where=&#39;mid&#39;,</span>
<span class="c1">#                    linestyle=&#39;-&#39;, color=&#39;b&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Initialize the basics of the mask</span>
        <span class="n">mask_bit_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_cube_mask</span><span class="p">()</span>

        <span class="c1"># Add flags based on the availability of pixels to stack</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">npix</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mask_bit_values</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask_bit_values</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                                     <span class="p">[</span><span class="s1">&#39;NONE_IN_STACK&#39;</span><span class="p">,</span> <span class="s1">&#39;NO_STDDEV&#39;</span><span class="p">])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">npix</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask_bit_values</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask_bit_values</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;NO_STDDEV&#39;</span><span class="p">)</span>

        <span class="c1"># DEBUG</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">mask_bit_values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Something should have been masked!&#39;</span><span class="p">)</span>

<span class="c1">#        pyplot.imshow(bin_indx.reshape(self.drpf.spatial_shape).T, origin=&#39;lower&#39;,</span>
<span class="c1">#                      interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Primary header is identical regardless of the shape of the</span>
        <span class="c1"># extensions</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cube_hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">build_cube_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span> <span class="s1">&#39;K Westfall &lt;westfall@ucolick.org&gt;&#39;</span><span class="p">)</span>

        <span class="c1"># Fill the covariance HDUs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pri_hdr</span><span class="p">,</span> <span class="n">ivar_hdu</span><span class="p">,</span> <span class="n">covar_hdu</span> <span class="o">=</span> <span class="n">covariance</span><span class="o">.</span><span class="n">output_hdus</span><span class="p">(</span><span class="n">reshape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hdr</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">)</span>

        <span class="c1"># Save the data to the hdu attribute</span>
        <span class="c1"># TODO: Strip headers of sub extensions of everything but</span>
        <span class="c1"># the WCS and HDUCLAS information.  Key WCS information in</span>
        <span class="c1"># BINID.</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mask_bit_values</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sres</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;REDCORR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sdev</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUXD&#39;</span><span class="p">),</span>
                             <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">npix</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">cube_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NPIX&#39;</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                           <span class="p">])</span>

        <span class="c1"># Fill the covariance matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">covar_hdu</span> <span class="p">]</span>

        <span class="k">return</span> <span class="n">hdu</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.write"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_DRP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the hdu object to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert the spectral arrays in the HDU to a 3D cube and write</span>
        <span class="c1"># it</span>
        <span class="k">if</span> <span class="n">match_DRP</span><span class="p">:</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_3d_hdu</span><span class="p">()</span>
            <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">symlink_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Just write the unique (2D) data</span>
        <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">symlink_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span> </div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.read"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Read an existing file with a previously binned set of spectra.</span>

<span class="sd">        Args:</span>
<span class="sd">            ifile (str): (**Optional**) Name of the file with the data.</span>
<span class="sd">                Default is to use the name provided by</span>
<span class="sd">                :func:`file_path`.</span>
<span class="sd">            strict (bool): (**Optional**) Force a strict reading of the</span>
<span class="sd">                file to make sure that it adheres to the expected</span>
<span class="sd">                format.  At the moment, this only checks to make sure</span>
<span class="sd">                the method keyword printed in the header matches the</span>
<span class="sd">                expected value in :attr:`method`.</span>
<span class="sd">            checksum (bool): (**Optional**) Use the checksum in the</span>
<span class="sd">                header to check for corruption of the data.  Default is</span>
<span class="sd">                False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: Raised if the file does not exist.</span>
<span class="sd">            ValueError: Raised if strict is true and the header keyword</span>
<span class="sd">                &#39;BINKEY&#39; does not match the method keyword.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ifile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ifile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;File does not exist!: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ifile</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#        self.hdu = fits.open(ifile, checksum=checksum)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>

        <span class="c1"># Confirm that the internal method is the same as the method</span>
        <span class="c1"># that was used in writing the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BINKEY&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Keywords in header do not match specified method keywords!&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Keywords in header do not match specified method keywords!&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: &quot;strict&quot; should also check other aspects of the file to</span>
        <span class="c1"># make sure that the details of the method are also the same,</span>
        <span class="c1"># not just the keyword</span>

<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO, &#39;Reverting to python-native structure.&#39;)</span>
<span class="c1">#        DAPFitsUtil.restructure_rss(self.hdu, ext=self.spectral_arrays)</span>
<span class="c1">#        DAPFitsUtil.restructure_map(self.hdu, ext=self.image_arrays)</span>

        <span class="c1"># Attempt to read and construct the covariance object</span>
        <span class="c1"># TODO: Covariance matrices need to have the input_index</span>
        <span class="c1"># written to the file</span>
<span class="c1">#        self.covariance = Covariance.from_fits(self.hdu, ivar_ext=None, row_major=True,</span>
<span class="c1">#                                               correlation=True)</span>
<span class="c1">#        var = numpy.ma.power(self.hdu[&#39;IVAR&#39;].data[:,:,self.covariance.input_index],</span>
<span class="c1">#                             -1).filled(0.0).reshape(-1, self.covariance.shape[-1])</span>
<span class="c1">#        self.covariance = self.covariance.apply_new_variance(var)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">Covariance</span><span class="o">.</span><span class="n">from_fits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ivar_ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">row_major</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">correlation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">input_index</span><span class="p">],</span>
                                 <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">apply_new_variance</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to find/read covariance data.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Attempt to read the effective radius</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;REFF&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to read effective radius from file header!&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reff</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Attempt to read binning parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fromheader</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;binpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fromheader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># Attempt to stacking parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fromheader</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fromheader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NBINS&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="n">SpatiallyBinnedSpectra</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">])</span></div>
<span class="c1">#        try:</span>
<span class="c1">#            self.missing_bins = eval(self.hdu[&#39;PRIMARY&#39;].header[&#39;EMPTYBIN&#39;])</span>
<span class="c1">#        except KeyError:</span>
<span class="c1">#            # Assume if this fails, it&#39;s because the keyword doesn&#39;t</span>
<span class="c1">#            # exist</span>
<span class="c1">#            self.missing_bins = []</span>

        <span class="c1"># Galactic extinction data already set by bin_spectra</span>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.copy_to_array"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.copy_to_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_array`</span>
<span class="sd">        specific for :class:`SpatiallyBinnedSpectra`.</span>

<span class="sd">        Return a copy of the selected data array.  The array size is</span>
<span class="sd">        always :math:`N_{\rm models} \times N_{\rm wavelength}`; i.e., the</span>
<span class="sd">        data is always flattened to two dimensions and the unique</span>
<span class="sd">        spectra are selected.</span>

<span class="sd">        Args:</span>
<span class="sd">            ext (str) : (**Optional**) Name of the extension from which</span>
<span class="sd">                to draw the data.  Must be allowed for the current</span>
<span class="sd">                :attr:`mode`; see :attr:`data_arrays`.  Default is</span>
<span class="sd">                ``&#39;FLUX&#39;``.</span>
<span class="sd">            waverange (array-like) : (**Optional**) Two-element array</span>
<span class="sd">                with the first and last wavelength to include in the</span>
<span class="sd">                computation.  Default is to use the full wavelength</span>
<span class="sd">                range.</span>
<span class="sd">            include_missing (bool) : (**Optional**) Create an array with</span>
<span class="sd">                a size that accommodates the missing models.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A 2D array with a copy of the data from the</span>
<span class="sd">            selected extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                         <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span>
                                        <span class="n">missing_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="k">if</span> <span class="n">include_missing</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span>
                                        <span class="n">unique_bins</span><span class="o">=</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">unique_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.copy_to_masked_array"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.copy_to_masked_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for</span>
<span class="sd">        :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_masked_array`</span>
<span class="sd">        specific for :class:`SpatiallyBinnedSpectra`.</span>

<span class="sd">        Return a copy of the selected data array as a masked array.</span>
<span class="sd">        This is functionally identical to :func:`copy_to_array`,</span>
<span class="sd">        except the output format is a `numpy.ma.MaskedArray`_.  The</span>
<span class="sd">        pixels that are considered to be masked can be specified using</span>
<span class="sd">        `flag`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            ext (str) : (**Optional**) Name of the extension from which</span>
<span class="sd">                to draw the data.  Must be allowed for the current</span>
<span class="sd">                :attr:`mode`; see :attr:`data_arrays`.  Default is</span>
<span class="sd">                `&#39;FLUX&#39;`.</span>
<span class="sd">            flag (str or list): (**Optional**) (List of) Flag names that</span>
<span class="sd">                are considered when deciding if a pixel should be</span>
<span class="sd">                masked.  The names *must* be a valid bit name as defined</span>
<span class="sd">                by :attr:`bitmask`.  If not provided, *ANY* non-zero</span>
<span class="sd">                mask bit is omitted.</span>
<span class="sd">            waverange (array-like) : (**Optional**) Two-element array</span>
<span class="sd">                with the first and last wavelength to include in the</span>
<span class="sd">                computation.  Default is to use the full wavelength</span>
<span class="sd">                range.</span>
<span class="sd">            include_missing (bool) : (**Optional**) Create an array with</span>
<span class="sd">                a size that accommodates the missing models.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A 2D array with a copy of the data from the</span>
<span class="sd">            selected extension.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">mask_ext</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
                                              <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                              <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                              <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span>
                                       <span class="n">missing_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="k">if</span> <span class="n">include_missing</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                                              <span class="n">nbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span>
                                        <span class="n">unique_bins</span><span class="o">=</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">unique_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.get_bin_indices"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.get_bin_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_bin_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the bins in the BIN table.</span>

<span class="sd">        Args:</span>
<span class="sd">            bins (array-like): The bin ID numbers to find</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Integer array with the index of each bin ID in</span>
<span class="sd">            the BINID columns of the BINS extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.find_nearest_bin"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.find_nearest_bin">[docs]</a>    <span class="k">def</span> <span class="nf">find_nearest_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_bins</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a KDTree to find the bins nearest to and excluding a list of</span>
<span class="sd">        input bins.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_bins (array-like): One or more bin ID numbers to use</span>
<span class="sd">                to locate the bin nearest to it based on its on-sky</span>
<span class="sd">                coordinates.  The list must be a unique set.</span>
<span class="sd">            weighted (bool): (**Optional**) Use the weighted coordinates</span>
<span class="sd">                (LW_SKY_COO) instead of the unweighted coordinates</span>
<span class="sd">                (SKY_COO) when finding the nearest bin.</span>
<span class="sd">            indices (bool): (**Optional**) Return the indices of the</span>
<span class="sd">                nearest bins instead of their ID number (default).</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The bin IDs, one per input bin, of the bin</span>
<span class="sd">            closest to each input bin.  Any bins that are in</span>
<span class="sd">            :attr:`missing_bins` have a return value of -1; there are no</span>
<span class="sd">            coordinates for these bins.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the set of input bins is not unique or</span>
<span class="sd">                contains bin IDs that are not present.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the input bin IDs</span>
        <span class="n">_input_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">input_bins</span><span class="p">)</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_bins</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide a unique set of input bin IDs.&#39;</span><span class="p">)</span>
        <span class="n">maxbinid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxbinid</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input contains invalid bin IDs.&#39;</span><span class="p">)</span>

        <span class="c1"># Account for any missing bins</span>
        <span class="n">valid_input_bin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_input_bins</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> \
                            <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">([</span> <span class="n">ib</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="n">_input_bins</span> <span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">valid_input_bin</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input bin IDs include missing bins.  Returned as -1.&#39;</span><span class="p">)</span>
        <span class="n">_input_bins</span> <span class="o">=</span> <span class="n">_input_bins</span><span class="p">[</span><span class="n">valid_input_bin</span><span class="p">]</span>

        <span class="c1"># Select the coordinate column</span>
        <span class="n">col</span> <span class="o">=</span> <span class="s1">&#39;LW_SKY_COO&#39;</span> <span class="k">if</span> <span class="n">weighted</span> <span class="k">else</span> <span class="s1">&#39;SKY_COO&#39;</span>

        <span class="c1"># The reference bins are all bins EXCEPT those provided</span>
        <span class="n">reference_bin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">],</span> <span class="n">_input_bins</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get the coordinates of the reference grid</span>
        <span class="n">ref_coo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">reference_bin</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">reference_bin</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Construct the KDTree</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">ref_coo</span><span class="p">)</span>

        <span class="c1"># Get the indices of the input bins in the internal list</span>
        <span class="n">input_bin_indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_indices</span><span class="p">(</span><span class="n">_input_bins</span><span class="p">)</span>

        <span class="c1"># Get the coordinates of the bins to match to the nearest</span>
        <span class="c1"># reference bin</span>
        <span class="n">input_coo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">input_bin_indx</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">input_bin_indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Get the indices of the nearest bins</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">input_coo</span><span class="p">)</span>

        <span class="c1"># Return either the bin indices or the bin ID numbers</span>
        <span class="n">output_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_input_bins</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">output_bins</span><span class="p">[</span><span class="n">valid_input_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">reference_bin</span><span class="p">][</span><span class="n">nearest_bin</span><span class="p">]</span> \
                        <span class="k">if</span> <span class="n">indices</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">reference_bin</span><span class="p">][</span><span class="n">nearest_bin</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">output_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">single_value</span> <span class="k">else</span> <span class="n">output_bins</span></div>


<div class="viewcode-block" id="SpatiallyBinnedSpectra.replace_with_data_from_nearest_bin"><a class="viewcode-back" href="../../../mangadap.proc.spatiallybinnedspectra.html#mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra.replace_with_data_from_nearest_bin">[docs]</a>    <span class="k">def</span> <span class="nf">replace_with_data_from_nearest_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bad_bins</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace data in the list of provided bad bins with the data from</span>
<span class="sd">        the nearest good bin.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (array-like): Data for each bin.  The length must be</span>
<span class="sd">                the same as :attr:`nbins`.</span>
<span class="sd">            bad_bins (array-like): The list of indices (must not be a</span>
<span class="sd">                boolean array) with bad values to be replaced.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A new array with the bad data filled with the</span>
<span class="sd">            data from the nearest bin.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the input array doesn&#39;t have the</span>
<span class="sd">                correct shape or if the list of bad bins has numbers</span>
<span class="sd">                outside the viable range (0,self.nbins-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input data must have </span><span class="si">{0}</span><span class="s1"> elements.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">))</span>
            
        <span class="c1"># No bad bins so just return the input</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="c1"># Select the bins to replace</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">replace</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bin_indices</span><span class="p">(</span><span class="n">bad_bins</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Get the coordinates of the reference grid</span>
        <span class="n">coo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Return the replaced data</span>
        <span class="k">return</span> <span class="n">replace_with_data_from_nearest_coo</span><span class="p">(</span><span class="n">coo</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="p">)</span></div></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>