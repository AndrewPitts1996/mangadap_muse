

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.spectralindices &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="mangadap" href="../../mangadap.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../mangadap.html">mangadap</a> &raquo;</li>
        
      <li>mangadap.proc.spectralindices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.spectralindices</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A class hierarchy that performs the spectral-index measurements.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/spectralindices.py</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">    Add examples!</span>

<span class="sd">*Notes*:</span>
<span class="sd">    </span>
<span class="sd">    If neither stellar-continuum nor emission-line models are provided:</span>
<span class="sd">        - Indices are measure on the binned spectra</span>
<span class="sd">        - No velocity-dispersion corrections are calculated</span>

<span class="sd">    If a stellar-continuum model is provided without an emission-line</span>
<span class="sd">    model:</span>
<span class="sd">        - Indices are measured on the binned spectra</span>
<span class="sd">        - Velocity-dispersion corrections are computed for any binned</span>
<span class="sd">          spectrum with a stellar-continuum fit based on the optimal</span>
<span class="sd">          template</span>

<span class="sd">    If an emission-line model is provided without a stellar-continuum</span>
<span class="sd">    model:</span>
<span class="sd">        - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">          spectra; spectra with emission-line fits have the model</span>
<span class="sd">          emission lines subtracted from them before these measurements.</span>
<span class="sd">        - If the emission-line model includes data regarding the</span>
<span class="sd">          stellar-continuum fit (template spectra and template weights),</span>
<span class="sd">          corrections are calculated for spectra with emission-line</span>
<span class="sd">          models based on the continuum fits; otherwise, no corrections</span>
<span class="sd">          are calculated.</span>

<span class="sd">    If both stellar-continuum and emission-line models are provided, and</span>
<span class="sd">    if the stellar-continuum and emission-line fits are performed on the</span>
<span class="sd">    same spectra:</span>
<span class="sd">        - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">          spectra; spectra with emission-line fits have the model</span>
<span class="sd">          emission lines subtracted from them before these measurements.</span>
<span class="sd">        - Velocity-dispersion corrections are based on the</span>
<span class="sd">          stellar-continuum templates and weights</span>

<span class="sd">    If both stellar-continuum and emission-line models are provided, and</span>
<span class="sd">    if the stellar-continuum and emission-line fits are performed on</span>
<span class="sd">    different spectra:</span>
<span class="sd">        - The behavior is exactly as if the stellar-continuum model was</span>
<span class="sd">          not provided.</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **20 Apr 2016**: Implementation begun by K. Westfall (KBW)</span>
<span class="sd">    | **09 May 2016**: (KBW) Add subtraction of emission-line models</span>
<span class="sd">    | **11 Jul 2016**: (KBW) Allow to not apply dispersion corrections</span>
<span class="sd">        for index measurements</span>
<span class="sd">    | **28 Jul 2016**: (KBW) Fixed error in initialization of guess</span>
<span class="sd">        redshift when stellar continuum is provided.</span>
<span class="sd">    | **23 Feb 2017**: (KBW) Use DAPFitsUtil read and write functions.</span>
<span class="sd">    | **27 Feb 2017**: (KBW) Use DefaultConfig</span>
<span class="sd">    | **02 Feb 2018**: (KBW) Allow for stellar-continuum and</span>
<span class="sd">        emission-line models to be performed on different spectra (i.e.,</span>
<span class="sd">        allow for the hybrid binning scheme).  Adjust for change to</span>
<span class="sd">        :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.fill_to_match`.</span>
<span class="sd">    | **15 Mar 2018**: (KBW) Correct the indices measured in angstroms</span>
<span class="sd">        for redshift.  Keep the indices as measured by the best-fitting</span>
<span class="sd">        model.</span>

<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _numpy.recarray: https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>

<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..par.artifactdb</span> <span class="k">import</span> <span class="n">ArtifactDB</span>
<span class="kn">from</span> <span class="nn">..par.absorptionindexdb</span> <span class="k">import</span> <span class="n">AbsorptionIndexDB</span>
<span class="kn">from</span> <span class="nn">..par.bandheadindexdb</span> <span class="k">import</span> <span class="n">BandheadIndexDB</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">dap_source_dir</span><span class="p">,</span> <span class="n">default_dap_file_name</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_method</span><span class="p">,</span> <span class="n">default_dap_method_path</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_common_path</span><span class="p">,</span> <span class="n">default_analysis_path</span>
<span class="kn">from</span> <span class="nn">..util.resolution</span> <span class="k">import</span> <span class="n">SpectralResolution</span><span class="p">,</span> <span class="n">match_spectral_resolution</span>
<span class="kn">from</span> <span class="nn">..util.sampling</span> <span class="k">import</span> <span class="n">spectral_coordinate_step</span><span class="p">,</span> <span class="n">spectrum_velocity_scale</span>
<span class="kn">from</span> <span class="nn">..util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span><span class="p">,</span> <span class="n">rec_to_fits_type</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util.parser</span> <span class="k">import</span> <span class="n">DefaultConfig</span>
<span class="kn">from</span> <span class="nn">.spatiallybinnedspectra</span> <span class="k">import</span> <span class="n">SpatiallyBinnedSpectra</span>
<span class="kn">from</span> <span class="nn">.templatelibrary</span> <span class="k">import</span> <span class="n">TemplateLibrary</span>
<span class="kn">from</span> <span class="nn">.stellarcontinuummodel</span> <span class="k">import</span> <span class="n">StellarContinuumModel</span>
<span class="kn">from</span> <span class="nn">.emissionlinemodel</span> <span class="k">import</span> <span class="n">EmissionLineModel</span>
<span class="kn">from</span> <span class="nn">.bandpassfilter</span> <span class="k">import</span> <span class="n">passband_integral</span><span class="p">,</span> <span class="n">passband_integrated_width</span><span class="p">,</span> <span class="n">pseudocontinuum</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">select_proc_method</span><span class="p">,</span> <span class="n">flux_to_fnu</span>

<span class="kn">import</span> <span class="nn">astropy.constants</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>
<span class="c1">#from memory_profiler import profile</span>

<div class="viewcode-block" id="SpectralIndicesDef"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndicesDef">[docs]</a><span class="k">class</span> <span class="nc">SpectralIndicesDef</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that holds the parameters necessary to perform the</span>
<span class="sd">    spectral-index measurements.</span>

<span class="sd">    Args:</span>
<span class="sd">        key (str): Keyword used to distinguish between different</span>
<span class="sd">            spectral-index databases.</span>
<span class="sd">        minimum_snr (bool): Minimum S/N of spectrum to fit</span>
<span class="sd">        fwhm (int, float): Resolution FWHM in angstroms at which to make</span>
<span class="sd">            the measurements.</span>
<span class="sd">        compute_corrections (bool): Flag to compute dispersion corrections</span>
<span class="sd">            to indices.  Dispersion corrections are always calculated!</span>
<span class="sd">        artifacts (str): String identifying the artifact database to use</span>
<span class="sd">        absindex (str): String identifying the absorption-index database</span>
<span class="sd">            to use</span>
<span class="sd">        bandhead (str): String identifying the bandhead-index database</span>
<span class="sd">            to use</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">compute_corrections</span><span class="p">,</span> <span class="n">artifacts</span><span class="p">,</span> <span class="n">absindex</span><span class="p">,</span> <span class="n">bandhead</span><span class="p">):</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;fwhm&#39;</span><span class="p">,</span> <span class="s1">&#39;compute_corrections&#39;</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;absindex&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;bandhead&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span>   <span class="n">key</span><span class="p">,</span>   <span class="n">minimum_snr</span><span class="p">,</span>   <span class="n">fwhm</span><span class="p">,</span>   <span class="n">compute_corrections</span><span class="p">,</span>   <span class="n">artifacts</span><span class="p">,</span>   <span class="n">absindex</span><span class="p">,</span>
                          <span class="n">bandhead</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span>   <span class="nb">str</span><span class="p">,</span>         <span class="n">in_fl</span><span class="p">,</span>  <span class="n">in_fl</span><span class="p">,</span>                  <span class="nb">bool</span><span class="p">,</span>         <span class="nb">str</span><span class="p">,</span>        <span class="nb">str</span><span class="p">,</span>
                               <span class="nb">str</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span></div>


<div class="viewcode-block" id="validate_spectral_indices_config"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.validate_spectral_indices_config">[docs]</a><span class="k">def</span> <span class="nf">validate_spectral_indices_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Validate :class:`mangadap.util.parser.DefaultConfig` object with</span>
<span class="sd">    spectral-index measurement parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        cnfg (:class:`mangadap.util.parser.DefaultConfig`): Object with</span>
<span class="sd">            parameters to validate.</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: Raised if any required keywords do not exist.</span>
<span class="sd">        ValueError: Raised if keys have unacceptable values.</span>
<span class="sd">        FileNotFoundError: Raised if a file is specified but could not</span>
<span class="sd">            be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for required keywords</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keyword </span><span class="se">\&#39;</span><span class="s1">key</span><span class="se">\&#39;</span><span class="s1"> must be provided.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;absorption_indices&#39;</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;bandhead_indices&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide either an absorption-index database or a bandhead-index &#39;</span> \
                         <span class="s1">&#39;database, or both.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="available_spectral_index_databases"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.available_spectral_index_databases">[docs]</a><span class="k">def</span> <span class="nf">available_spectral_index_databases</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the list of available spectral index databases</span>

<span class="sd">    Available database combinations:</span>

<span class="sd">    .. todo::</span>
<span class="sd">        Fill in</span>

<span class="sd">    Args:</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.dap_source_dir`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of :func:`SpectralIndicesDef` objects, each</span>
<span class="sd">        defining a spectral-index database to measure.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotADirectoryError: Raised if the provided or default</span>
<span class="sd">            *dapsrc* is not a directory.</span>
<span class="sd">        OSError/IOError: Raised if no spectral-index configuration files</span>
<span class="sd">            could be found.</span>
<span class="sd">        KeyError: Raised if the spectral-index database keywords are not</span>
<span class="sd">            all unique.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Somehow add a python call that reads the databases and</span>
<span class="sd">          constructs the table for presentation in sphinx so that the</span>
<span class="sd">          text above doesn&#39;t have to be edited with changes in the</span>
<span class="sd">          available databases.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the source directory exists</span>
    <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">dap_source_dir</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotADirectoryError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> does not exist!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">))</span>

    <span class="c1"># Check the configuration files exist</span>
    <span class="n">search_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python/mangadap/config/spectral_indices&#39;</span><span class="p">)</span>
    <span class="n">ini_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">search_dir</span><span class="p">,</span> <span class="s1">&#39;*.ini&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ini_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Could not find any configuration files in </span><span class="si">{0}</span><span class="s1"> !&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">search_dir</span><span class="p">))</span>

    <span class="c1"># Build the list of library definitions</span>
    <span class="n">index_set_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ini_files</span><span class="p">:</span>
        <span class="c1"># Read the config file</span>
        <span class="n">cnfg</span> <span class="o">=</span> <span class="n">DefaultConfig</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># Ensure it has the necessary elements to define the template</span>
        <span class="c1"># library</span>
        <span class="n">validate_spectral_indices_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">)</span>

        <span class="n">index_set_list</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">SpectralIndicesDef</span><span class="p">(</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span>
                                               <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">),</span> 
                                               <span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;resolution_fwhm&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                                               <span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;compute_sigma_correction&#39;</span><span class="p">,</span>
                                                            <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                               <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;artifact_mask&#39;</span><span class="p">],</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;absorption_indices&#39;</span><span class="p">],</span>
                                               <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;bandhead_indices&#39;</span><span class="p">])</span> <span class="p">]</span>

    <span class="c1"># Check the keywords of the libraries are all unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_set_list</span><span class="p">])))</span> \
                <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_set_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Spectral-index set keywords are not all unique!&#39;</span><span class="p">)</span>

    <span class="c1"># Return the default list of assessment methods</span>
    <span class="k">return</span> <span class="n">index_set_list</span></div>


<div class="viewcode-block" id="SpectralIndicesBitMask"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndicesBitMask">[docs]</a><span class="k">class</span> <span class="nc">SpectralIndicesBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Derived class that specifies the mask bits for the spectral-index</span>
<span class="sd">    measurements.  See :class:`mangadap.util.bitmask.BitMask` for</span>
<span class="sd">    attributes.</span>

<span class="sd">    A list of the bits and meanings are provided by the base class</span>
<span class="sd">    function :func:`mangadap.util.bitmask.BitMask.info`; i.e.,::</span>

<span class="sd">        from mangadap.proc.spectralindices import SpectralIndicesBitMask</span>
<span class="sd">        bm = SpectralIndicesBitMask()</span>
<span class="sd">        bm.info()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">dap_source_dir</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;mangadap&#39;</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">,</span>
                                                     <span class="s1">&#39;bitmasks&#39;</span><span class="p">,</span> <span class="s1">&#39;spectral_indices_bits.ini&#39;</span><span class="p">))</span></div>


<span class="c1"># TODO: These two should have the same base class</span>
<div class="viewcode-block" id="AbsorptionLineIndices"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.AbsorptionLineIndices">[docs]</a><span class="k">class</span> <span class="nc">AbsorptionLineIndices</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measure a set of spectral indices in a single spectrum.</span>

<span class="sd">    By default, the center of the two side-bands is the flux-weighted</span>
<span class="sd">    center; set weighted_center=False to get use the unweighted center</span>
<span class="sd">    of the band.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">bluebands</span><span class="p">,</span> <span class="n">redbands</span><span class="p">,</span> <span class="n">mainbands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">weighted_center</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># Check the shape of the input spectrum</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux must be a single vector!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux and wavelength vectors must have the same shape.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Band definitions must be two-dimensional: Nindx x 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">redbands</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mainbands</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input bands must have identical shape.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nindx</span> <span class="o">=</span> <span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Make sure the units exist</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input units not provided.  Assuming angstroms.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="s1">&#39;ang&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get the two pseudocontinua and the flux-weighted band centers</span>
        <span class="c1"># pseudocontinuum returns center, continuum, and continuum_err</span>
        <span class="c1"># as MaskedArrays; by default center is the flux-weighted center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blue_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_incomplete</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">blue_empty</span> <span class="o">=</span> <span class="n">pseudocontinuum</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">bluebands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                              <span class="n">weighted_center</span><span class="o">=</span><span class="n">weighted_center</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">red_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_incomplete</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">red_empty</span> <span class="o">=</span> <span class="n">pseudocontinuum</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">redbands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                             <span class="n">weighted_center</span><span class="o">=</span><span class="n">weighted_center</span><span class="p">)</span>

        <span class="c1"># Get the parameters for the linear continuum across the</span>
        <span class="c1"># primary passband</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">continuum_m</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">)</span> \
                                <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_center</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">continuum_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_center</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum_m</span>

<span class="c1">#        print(&#39;Number of non-finite continuum m,b: {0} {1}&#39;.format(</span>
<span class="c1">#                                numpy.sum(numpy.invert(numpy.isfinite(self.continuum_m))),</span>
<span class="c1">#                                numpy.sum(numpy.invert(numpy.isfinite(self.continuum_b)))))</span>

        <span class="c1"># Compute the continuum normalized indices.  This has to be done</span>
        <span class="c1"># in a for loop because the continuum is index-dependent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_incomplete</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_empty</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="n">lg10</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mainbands</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_empty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_empty</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
                
            <span class="c1"># From Worthey et al. 1994, eqns. 2 and 3</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum_b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">wave</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">flux</span><span class="o">/</span><span class="n">cont</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ang&#39;</span> <span class="k">else</span> <span class="n">flux</span><span class="o">/</span><span class="n">cont</span>

            <span class="c1"># Calculate the integral over the passband</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">passband_integral</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">integrand</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">passband_integral</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">err</span><span class="o">/</span><span class="n">cont</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                                      <span class="n">quad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Get the fraction of the band covered by the spectrum and</span>
            <span class="c1"># flag bands that are only partially covered or empty</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">passband_integrated_width</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>
            <span class="n">interval_frac</span> <span class="o">=</span> <span class="n">interval</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">main_incomplete</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval_frac</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">main_empty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">interval_frac</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1">#            # TEST: Change calculation</span>
<span class="c1">#            cont = self.continuum_b[i] + self.continuum_m[i]*wave</span>
<span class="c1">#            fint = passband_integral(wave, flux, passband=m, log=log)</span>
<span class="c1">#            cint = passband_integral(wave, cont, passband=m, log=log)</span>
<span class="c1">#</span>
<span class="c1">##            print(interval*(1-fint/cint) - self.index[i])</span>
<span class="c1">#            self.index[i] = interval*(1.0-fint/cint if self.units[i] == &#39;ang&#39; else fint/cint)</span>
<span class="c1">#            if err is not None:</span>
<span class="c1">#                eint = numpy.sqrt(passband_integral(wave, numpy.square(err), passband=m, log=log))</span>
<span class="c1">#                self.index_err[i] = abs(interval*eint/cint)</span>

            <span class="c1"># Convert the index to magnitudes using Worthey et al. 1994,</span>
            <span class="c1"># eqn. 3: The passband interval cancels out of the error</span>
            <span class="c1"># propagation.  The error calculation is done first so as to</span>
            <span class="c1"># not replace the linear calculation of the index.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># If err is None, self.index_err=0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">2.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">lg10</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">interval</span><span class="p">)</span></div>


<div class="viewcode-block" id="BandheadIndices"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.BandheadIndices">[docs]</a><span class="k">class</span> <span class="nc">BandheadIndices</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measure a set of bandhead indices in a single spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">bluebands</span><span class="p">,</span> <span class="n">redbands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Check the shape of the input spectrum</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux must be a single vector!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux and wavelength vectors must have the same shape.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Band definitions must be two-dimensional: Nindx x 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">redbands</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input bands must have identical shape.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nindx</span> <span class="o">=</span> <span class="n">bluebands</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Check input order</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input order not specified.  Assuming r_b.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="s1">&#39;r_b&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="c1"># Get the two pseudocontinua and the flux-weighted band centers</span>
        <span class="c1"># pseudocontinuum returns center, continuum, and continuum_err</span>
        <span class="c1"># as MaskedArrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blue_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_incomplete</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">blue_empty</span> <span class="o">=</span> <span class="n">pseudocontinuum</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">bluebands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">red_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_incomplete</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">red_empty</span> <span class="o">=</span> <span class="n">pseudocontinuum</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">passband</span><span class="o">=</span><span class="n">redbands</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span>

        <span class="c1"># Determine which indices have both a valid index and index</span>
        <span class="c1"># error calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_incomplete</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_empty</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1">#        self.divbyzero = numpy.invert(numpy.absolute(self.red_continuum.filled(0.0)) &gt; 0) \</span>
<span class="c1">#                            | numpy.invert(numpy.absolute(self.blue_continuum.filled(0.0)) &gt; 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Calculate the index in the correct order</span>
        <span class="n">blue_n</span> <span class="o">=</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;b_r&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
<span class="c1">#        import pdb</span>
<span class="c1">#        pdb.set_trace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">blue_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">[</span><span class="n">blue_n</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">[</span><span class="n">blue_n</span><span class="p">])</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span><span class="p">[</span><span class="n">blue_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">[</span><span class="n">blue_n</span><span class="p">])</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">blue_n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">blue_n</span><span class="p">)],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">blue_n</span><span class="p">)])</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divbyzero</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">blue_n</span><span class="p">)]</span> \
                <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">blue_n</span><span class="p">)])</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Calculate the index errors</span>
        <span class="n">berr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum_err</span> <span class="ow">is</span> <span class="kc">None</span> \
                                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum_err</span>
        <span class="n">rerr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum_err</span> <span class="ow">is</span> <span class="kc">None</span> \
                                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">red_continuum_err</span>
        <span class="c1"># Error is independent of ratio order when written in this way</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">berr</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">blue_continuum</span><span class="p">))</span> <span class="o">+</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">rerr</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">red_continuum</span><span class="p">))</span>
                                      <span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span></div>



<span class="c1">#        n = numpy.ma.zeros(self.nindx, dtype=numpy.float)</span>
<span class="c1">#        d = numpy.ma.zeros(self.nindx, dtype=numpy.float)</span>
<span class="c1">#        n[blue_n] = self.blue_continuum[blue_n]</span>
<span class="c1">#        d[blue_n] = self.red_continuum[blue_n]</span>
<span class="c1">#        n[~blue_n] = self.red_continuum[~blue_n]</span>
<span class="c1">#        d[~blue_n] = self.blue_continuum[~blue_n]</span>
<span class="c1">#</span>
<span class="c1">#        nerr = numpy.ma.zeros(self.nindx)</span>
<span class="c1">#        derr = numpy.ma.zeros(self.nindx)</span>
<span class="c1">#        if self.blue_continuum_err is not None:</span>
<span class="c1">#            nerr[blue_n] = self.blue_continuum_err[blue_n]</span>
<span class="c1">#            derr[~blue_n] = self.blue_continuum_err[~blue_n]</span>
<span class="c1">#        if self.red_continuum_err is not None:</span>
<span class="c1">#            nerr[~blue_n] = self.red_continuum_err[~blue_n]</span>
<span class="c1">#            derr[blue_n] = self.red_continuum_err[blue_n]</span>
<span class="c1">#</span>
<span class="c1">#        # Determine which indices have both a valid index and index</span>
<span class="c1">#        # error calculation</span>
<span class="c1">#        self.main_incomplete = None</span>
<span class="c1">#        self.main_empty = None</span>
<span class="c1">#        self.divbyzero = ~((numpy.absolute(d) &gt; 0) &amp; (numpy.absolute(n) &gt; 0))</span>
<span class="c1">#</span>
<span class="c1">#        # Calculate the indices and their nominal errors</span>
<span class="c1">#        self.index = numpy.zeros(self.nindx, dtype=numpy.float)</span>
<span class="c1">#        self.index[~self.divbyzero] = n[~self.divbyzero]/d[~self.divbyzero]</span>
<span class="c1">#        self.index_err = numpy.zeros(self.nindx, dtype=numpy.float)</span>
<span class="c1">#        self.index_err[~self.divbyzero] = numpy.sqrt(</span>
<span class="c1">#                            numpy.square(nerr[~self.divbyzero]*self.index[~self.divbyzero]</span>
<span class="c1">#                                            / n[~self.divbyzero])</span>
<span class="c1">#                          + numpy.square(derr[~self.divbyzero]*self.index[~self.divbyzero]</span>
<span class="c1">#                                            / d[~self.divbyzero]) )</span>


<div class="viewcode-block" id="SpectralIndices"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices">[docs]</a><span class="k">class</span> <span class="nc">SpectralIndices</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that computes and interfaces with the spectral-index</span>
<span class="sd">    measurements.</span>

<span class="sd">    If neither stellar-continuum nor emission-line models are provided:</span>
<span class="sd">        - Indices are measure on the binned spectra</span>
<span class="sd">        - No velocity-dispersion corrections are calculated</span>

<span class="sd">    If a stellar-continuum model is provided without an emission-line</span>
<span class="sd">    model:</span>
<span class="sd">        - Indices are measured on the binned spectra</span>
<span class="sd">        - Velocity-dispersion corrections are computed for any binned</span>
<span class="sd">          spectrum with a stellar-continuum fit based on the optimal</span>
<span class="sd">          template</span>

<span class="sd">    If an emission-line model is provided without a stellar-continuum</span>
<span class="sd">    model:</span>
<span class="sd">        - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">          spectra; spectra with emission-line fits have the model</span>
<span class="sd">          emission lines subtracted from them before these measurements.</span>
<span class="sd">        - If the emission-line model includes data regarding the</span>
<span class="sd">          stellar-continuum fit (template spectra and template weights),</span>
<span class="sd">          corrections are calculated for spectra with emission-line</span>
<span class="sd">          models based on the continuum fits; otherwise, no corrections</span>
<span class="sd">          are calculated.</span>

<span class="sd">    If both stellar-continuum and emission-line models are provided, and</span>
<span class="sd">    if the stellar-continuum and emission-line fits are performed on the</span>
<span class="sd">    same spectra:</span>
<span class="sd">        - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">          spectra; spectra with emission-line fits have the model</span>
<span class="sd">          emission lines subtracted from them before these measurements.</span>
<span class="sd">        - Velocity-dispersion corrections are based on the</span>
<span class="sd">          stellar-continuum templates and weights</span>

<span class="sd">    If both stellar-continuum and emission-line models are provided, and</span>
<span class="sd">    if the stellar-continuum and emission-line fits are performed on</span>
<span class="sd">    different spectra:</span>
<span class="sd">        - The behavior is exactly as if the stellar-continuum model was</span>
<span class="sd">          not provided.</span>

<span class="sd">    **Detail what should be provided in terms of the redshift**</span>

<span class="sd">    Args:</span>
<span class="sd">        database_key (str): Keyword used to select the specfic list of</span>
<span class="sd">            indices to measure and how they should be measured;  see</span>
<span class="sd">            :class:`SpectralIndicesDef`.</span>
<span class="sd">        binned_spectra</span>
<span class="sd">            (:class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra`):</span>
<span class="sd">            The binned spectra for the measurements.</span>
<span class="sd">        redshift (float, numpy.ndarray): (**Optional**) A single or</span>
<span class="sd">            spectrum-dependent redshift, :math:`z`, to use for shifting</span>
<span class="sd">            the index bands.  Default is to measure the indices at their</span>
<span class="sd">            provided wavelengths (i.e., :math:`z=0`).</span>
<span class="sd">        stellar_continuum</span>
<span class="sd">            (:class:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel`):</span>
<span class="sd">            (**Optional**) The stellar-continuum model as applied to the</span>
<span class="sd">            binned spectra.</span>
<span class="sd">        emission_line_model</span>
<span class="sd">            (:class:`mangadap.proc.emissionlinemodel.EmissionLineModel`):</span>
<span class="sd">            (**Optional**) The emission-line model as applied to either</span>
<span class="sd">            the binned spectra or the unbinned spaxels.</span>
<span class="sd">        database_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`SpectralIndicesDef` objects that define one or more</span>
<span class="sd">            methods to use for the spectral-index measurements.  The</span>
<span class="sd">            default list is provided by the config files in the DAP</span>
<span class="sd">            source directory and compiled into this list using</span>
<span class="sd">            :func:`available_spectral_index_databases`.</span>
<span class="sd">        artifact_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`mangadap.par.spectralfeaturedb.SpectralFeatureDBDef`</span>
<span class="sd">            objects that define the unique key for the artifact database</span>
<span class="sd">            (see :mod:`mangadap.par.artifactdb`).</span>
<span class="sd">        absorption_index_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`mangadap.par.spectralfeaturedb.SpectralFeatureDBDef`</span>
<span class="sd">            objects that define the unique key for the absorption-index</span>
<span class="sd">            database (see :mod:`mangadap.par.absorptionindexdb`).</span>
<span class="sd">        bandhead_index_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`mangadap.par.spectralfeaturedb.SpectralFeatureDBDef`</span>
<span class="sd">            objects that define the unique key for the bandhead-index</span>
<span class="sd">            database (see :mod:`mangadap.par.bandheadindexdb`).</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.dap_source_dir`.</span>
<span class="sd">        dapver (str): (**Optional**) The DAP version to use for the</span>
<span class="sd">            analysis, used to override the default defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_version`.</span>
<span class="sd">        analysis_path (str): (**Optional**) The top-level path for the</span>
<span class="sd">            DAP output files, used to override the default defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">        directory_path (str): The exact path to the directory with DAP</span>
<span class="sd">            output that is common to number DAP &quot;methods&quot;.  See</span>
<span class="sd">            :attr:`directory_path`.</span>
<span class="sd">        output_file (str): (**Optional**) Exact name for the output</span>
<span class="sd">            file.  The default is to use</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">        hardcopy (bool): (**Optional**) Flag to write the HDUList</span>
<span class="sd">            attribute to disk.  Default is True; if False, the HDUList</span>
<span class="sd">            is only kept in memory and would have to be reconstructed.</span>
<span class="sd">        tpl_symlink_dir (str): (**Optional**) Create a symbolic link to</span>
<span class="sd">            the created template library file in the supplied directory.</span>
<span class="sd">            Default is to produce no symbolic link.</span>
<span class="sd">        clobber (bool): (**Optional**) Overwrite any existing files.</span>
<span class="sd">            Default is to use any existing file instead of redoing the</span>
<span class="sd">            analysis and overwriting the existing output.</span>
<span class="sd">        checksum (bool): (**Optional**) Use the checksum in the fits</span>
<span class="sd">            header to confirm that the data has not been corrupted.  The</span>
<span class="sd">            checksum is **always** written to the fits header when the</span>
<span class="sd">            file is created; this argument does not toggle that</span>
<span class="sd">            functionality.</span>
<span class="sd">        loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">            to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">            using :func:`mangadap.util.log.log_output`.  Default is no</span>
<span class="sd">            logging.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress all terminal and logging</span>
<span class="sd">            output.  Default is False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database_key</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">emission_line_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">database_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">artifact_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">absorption_index_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandhead_index_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Define the database properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artdb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_define_databases</span><span class="p">(</span><span class="n">database_key</span><span class="p">,</span> <span class="n">database_list</span><span class="o">=</span><span class="n">database_list</span><span class="p">,</span>
                               <span class="n">artifact_list</span><span class="o">=</span><span class="n">artifact_list</span><span class="p">,</span>
                               <span class="n">absorption_index_list</span><span class="o">=</span><span class="n">absorption_index_list</span><span class="p">,</span>
                               <span class="n">bandhead_index_list</span><span class="o">=</span><span class="n">bandhead_index_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nabs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbhd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nabs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbhd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correct_indices</span> <span class="o">=</span> <span class="kc">False</span>            <span class="c1"># !! HARDCODED !!</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Define the output directory and file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="kc">None</span>              <span class="c1"># Set in _set_paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize the objects used in the assessments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">SpectralIndicesBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_image_arrays</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Run the assessments of the DRP file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="n">stellar_continuum</span><span class="p">,</span>
                     <span class="n">emission_line_model</span><span class="o">=</span><span class="n">emission_line_model</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                     <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="n">directory_path</span><span class="p">,</span>
                     <span class="n">output_file</span><span class="o">=</span><span class="n">output_file</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="n">hardcopy</span><span class="p">,</span> <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="n">tpl_symlink_dir</span><span class="p">,</span>
                     <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<div class="viewcode-block" id="SpectralIndices._define_databases"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._define_databases">[docs]</a>    <span class="k">def</span> <span class="nf">_define_databases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database_key</span><span class="p">,</span> <span class="n">database_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">artifact_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">absorption_index_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bandhead_index_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Select the database of indices</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab the specific database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">select_proc_method</span><span class="p">(</span><span class="n">database_key</span><span class="p">,</span> <span class="n">SpectralIndicesDef</span><span class="p">,</span>
                                           <span class="n">method_list</span><span class="o">=</span><span class="n">database_list</span><span class="p">,</span>
                                           <span class="n">available_func</span><span class="o">=</span><span class="n">available_spectral_index_databases</span><span class="p">,</span>
                                           <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="c1"># Instantiate the artifact, absorption-index, and bandhead-index</span>
        <span class="c1"># databases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artdb</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">ArtifactDB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">],</span> <span class="n">artdb_list</span><span class="o">=</span><span class="n">artifact_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="c1"># TODO: Generalize the name of this object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span> <span class="o">=</span> <span class="n">SpectralPixelMask</span><span class="p">(</span><span class="n">artdb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">artdb</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;absindex&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">AbsorptionIndexDB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;absindex&#39;</span><span class="p">],</span> <span class="n">indxdb_list</span><span class="o">=</span><span class="n">absorption_index_list</span><span class="p">,</span>
                                  <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;bandhead&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">BandheadIndexDB</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;bandhead&#39;</span><span class="p">],</span> <span class="n">indxdb_list</span><span class="o">=</span><span class="n">bandhead_index_list</span><span class="p">,</span>
                                <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices._set_paths"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the :attr:`directory_path` and :attr:`output_file`.  If not</span>
<span class="sd">        provided, the defaults are set using, respectively,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_common_path` and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_file_name`.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory_path (str): The exact path to the DAP</span>
<span class="sd">                spectral-index file.  See :attr:`directory_path`.</span>
<span class="sd">            dapver (str): DAP version.</span>
<span class="sd">            analysis_path (str): The path to the top-level directory</span>
<span class="sd">                containing the DAP output files for a given DRP and DAP</span>
<span class="sd">                version.</span>
<span class="sd">            output_file (str): The name of the file with spectral-index</span>
<span class="sd">                moment measurements.  See :func:`measure`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the output directory path</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">default_dap_method</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                    <span class="n">stellar_continuum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_path</span> <span class="o">=</span> <span class="n">default_analysis_path</span><span class="p">(</span><span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span>
                                                   <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">)</span> \
                                    <span class="k">if</span> <span class="n">analysis_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">analysis_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="n">default_dap_method_path</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">plate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span>
                                                      <span class="n">ifudesign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span>
                                                      <span class="n">ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span>
                                                      <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                                                      <span class="n">analysis_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">analysis_path</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">directory_path</span><span class="p">)</span>

        <span class="c1"># Set the output file</span>
        <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>
        <span class="n">ref_method</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">default_dap_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="n">ref_method</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices._initialize_primary_header"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._initialize_primary_header">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_primary_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">measurements_binid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the header of :attr:`hdu`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            astropy.io.fits.Header : Edited header object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy the from the DRP and clean it</span>
        <span class="k">if</span> <span class="n">hdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">clean_dap_primary_header</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;AUTHOR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Kyle B. Westfall &lt;westfall@ucolick.org&gt;&#39;</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SIKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Spectral-index database keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SIMINSN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span> <span class="s1">&#39;Minimum S/N of spectrum to include&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SIFWHM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">],</span> <span class="s1">&#39;FWHM of index system resolution (ang)&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ARTDB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;artifacts&#39;</span><span class="p">],</span> <span class="s1">&#39;Artifact database keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ABSDB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;absindex&#39;</span><span class="p">],</span> <span class="s1">&#39;Absorption-index database keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;BHDDB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;bandhead&#39;</span><span class="p">],</span> <span class="s1">&#39;Bandhead-index database keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SCKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Stellar-continuum model keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;ELFKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span>
                                <span class="s1">&#39;Emission-line modeling method keyword&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;NBINS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">,</span> <span class="s1">&#39;Number of unique spatial bins&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SICORR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span><span class="p">,</span> <span class="s1">&#39;Velocity dispersion corrections computed&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;SIREBIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">measurements_binid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Bin IDs disconnected from SC binning&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<span class="c1">#    def _initialize_mask(self, good_snr):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#        Initialize the mask be setting the DIDNOTUSE, FORESTAR, and LOW_SNR masks</span>
<span class="c1">#</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # Initialize to all zeros</span>
<span class="c1">#        mask = numpy.zeros(self.shape, dtype=self.bitmask.minimum_dtype())</span>
<span class="c1">#</span>
<span class="c1">#        # Turn on the flag stating that the pixel wasn&#39;t used</span>
<span class="c1">##        print(&#39;Mask size:&#39;, self.binned_spectra[&#39;MASK&#39;].data.size)</span>
<span class="c1">#        indx = self.binned_spectra.bitmask.flagged(self.binned_spectra[&#39;MASK&#39;].data,</span>
<span class="c1">#                                                   flag=self.binned_spectra.do_not_fit_flags())</span>
<span class="c1">##        print(&#39;Masked as DIDNOTUSE:&#39;, numpy.sum(indx))</span>
<span class="c1">#        mask[indx] = self.bitmask.turn_on(mask[indx], &#39;DIDNOTUSE&#39;)</span>
<span class="c1">#</span>
<span class="c1">#        # Turn on the flag stating that the pixel has a foreground star</span>
<span class="c1">#        indx = self.binned_spectra.bitmask.flagged(self.binned_spectra[&#39;MASK&#39;].data,</span>
<span class="c1">#                                                   flag=&#39;FORESTAR&#39;)</span>
<span class="c1">##        print(&#39;Masked as FORESTAR: &#39;, numpy.sum(indx))</span>
<span class="c1">#        mask[indx] = self.bitmask.turn_on(mask[indx], &#39;FORESTAR&#39;)</span>
<span class="c1">#</span>
<span class="c1">#        # Turn on the flag stating that the S/N in the spectrum was</span>
<span class="c1">#        # below the requested limit</span>
<span class="c1">#        indx = numpy.array([numpy.invert(good_snr).reshape(self.spatial_shape).T]*self.nwave).T</span>
<span class="c1">#        mask[indx] = self.bitmask.turn_on(mask[indx], flag=&#39;LOW_SNR&#39;)</span>
<span class="c1">#</span>
<span class="c1">#        return mask</span>


<div class="viewcode-block" id="SpectralIndices._index_database_dtype"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._index_database_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">_index_database_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_len</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the record array data type for the output fits</span>
<span class="sd">        extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;TYPE&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;U10&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NAME&#39;</span><span class="p">,</span><span class="s1">&#39;&lt;U</span><span class="si">{0:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_len</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;PASSBAND&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;BLUEBAND&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;REDBAND&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;UNIT&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U3&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;COMPONENT&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;INTEGRAND&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U7&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ORDER&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U3&#39;</span><span class="p">)</span>
               <span class="p">]</span></div>

    
<div class="viewcode-block" id="SpectralIndices._compile_database"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._compile_database">[docs]</a>    <span class="k">def</span> <span class="nf">_compile_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the database with the specifications of each index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">name_len</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">name_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">name_len</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">name_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># Instatiate the table data that will be saved defining the set</span>
        <span class="c1"># of indices measured</span>
        <span class="n">passband_database</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nindx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_database_dtype</span><span class="p">(</span><span class="n">name_len</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="o">.</span><span class="n">nsets</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">passband_database</span><span class="p">[</span><span class="s1">&#39;TYPE&#39;</span><span class="p">][:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;absorption&#39;</span>
            <span class="n">hk</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="s1">&#39;NAME&#39;</span><span class="p">,</span> <span class="s1">&#39;PASSBAND&#39;</span><span class="p">,</span> <span class="s1">&#39;BLUEBAND&#39;</span><span class="p">,</span> <span class="s1">&#39;REDBAND&#39;</span><span class="p">,</span> <span class="s1">&#39;UNIT&#39;</span><span class="p">,</span> <span class="s1">&#39;COMPONENT&#39;</span> <span class="p">]</span>
            <span class="n">ak</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;primary&#39;</span><span class="p">,</span> <span class="s1">&#39;blueside&#39;</span><span class="p">,</span> <span class="s1">&#39;redside&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="s1">&#39;component&#39;</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">_hk</span><span class="p">,</span> <span class="n">_ak</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span><span class="n">ak</span><span class="p">):</span>
                <span class="n">passband_database</span><span class="p">[</span><span class="n">_hk</span><span class="p">][:</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="p">[</span><span class="n">_ak</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">passband_database</span><span class="p">[</span><span class="s1">&#39;TYPE&#39;</span><span class="p">][</span><span class="n">t</span><span class="p">:]</span> <span class="o">=</span> <span class="s1">&#39;bandhead&#39;</span>
            <span class="n">hk</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="s1">&#39;NAME&#39;</span><span class="p">,</span> <span class="s1">&#39;BLUEBAND&#39;</span><span class="p">,</span> <span class="s1">&#39;REDBAND&#39;</span><span class="p">,</span> <span class="s1">&#39;INTEGRAND&#39;</span><span class="p">,</span> <span class="s1">&#39;ORDER&#39;</span> <span class="p">]</span>
            <span class="n">ak</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;blueside&#39;</span><span class="p">,</span> <span class="s1">&#39;redside&#39;</span><span class="p">,</span> <span class="s1">&#39;integrand&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">_hk</span><span class="p">,</span> <span class="n">_ak</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hk</span><span class="p">,</span><span class="n">ak</span><span class="p">):</span>
                <span class="n">passband_database</span><span class="p">[</span><span class="n">_hk</span><span class="p">][</span><span class="n">t</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span><span class="p">[</span><span class="n">_ak</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">passband_database</span></div>


<div class="viewcode-block" id="SpectralIndices._assign_image_arrays"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._assign_image_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_image_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set :attr:`image_arrays`, which contains the list of extensions</span>
<span class="sd">        in :attr:`hdu` that are on-sky image data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;BINID&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="SpectralIndices._get_missing_bins"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._get_missing_bins">[docs]</a>    <span class="k">def</span> <span class="nf">_get_missing_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unique_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">above_snr_limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">+</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">SpatiallyBinnedSpectra</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">(</span><span class="n">unique_bins</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices._assign_redshifts"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._assign_redshifts">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_redshifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">,</span>
                          <span class="n">default_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the redshift to use for each spectrum for the spectral index</span>
<span class="sd">        measurements.</span>
<span class="sd">        </span>
<span class="sd">        In terms of precedence, directly provided redshifts override</span>
<span class="sd">        those in any available StellarContinuumModel.</span>

<span class="sd">        If self.stellar_continuum and redshift are None, the default</span>
<span class="sd">        redshift is used (or 0.0 if this is also None).</span>

<span class="sd">        To get the stellar kinematics, the function calls</span>
<span class="sd">        :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.matched_kinematics`.</span>
<span class="sd">        It is expected that the stellar kinematics were fixed to these</span>
<span class="sd">        values during any emission-line modeling that may have altered</span>
<span class="sd">        the continuum fit itself (e.g., :class:`mangadap.proc.Sasuke`).</span>

<span class="sd">        In this function, the provided redshift must be a single value</span>
<span class="sd">        or None; therefore, the means of any vectors should be provided</span>
<span class="sd">        instead of the full vector.</span>

<span class="sd">        The function is borrows heavily from</span>
<span class="sd">        :func:`mangadap.proc.emissionlinemodel.EmissionLineModel._assign_input_kinematics`.</span>

<span class="sd">        Args:</span>

<span class="sd">            redshift (float, numpy.ndarray): Redshifts (:math:`z`) to</span>
<span class="sd">                use for each spectrum.  If None, the default</span>

<span class="sd">            default_redshift (float): (**Optional**) Only used if there</span>
<span class="sd">                are stellar kinematics available.  Provides the default</span>
<span class="sd">                redshift to use for spectra without stellar</span>
<span class="sd">                measurements; see :arg:`redshift` in</span>
<span class="sd">                :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.matched_kinematics`.</span>
<span class="sd">                If None (default), the median of the unmasked stellar</span>
<span class="sd">                velocities will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct the binid matrix if measuring on unbinned spaxels</span>
        <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">:</span>
            <span class="n">binid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">good_snr</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nspec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span>
            <span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the redshift measured for the stars and use them if no</span>
        <span class="c1"># default value is provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">matched_kinematics</span><span class="p">(</span>
                                                <span class="n">binid</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">default_redshift</span><span class="p">,</span>
                                                <span class="n">nearest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">good_snr</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="k">return</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Use the default value(s)</span>
        <span class="n">_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nspec</span> <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided redshift must be either a single value or match the &#39;</span>
                             <span class="s1">&#39;number of binned spectra or the number of unbinned spaxels.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">_redshift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralIndices._flag_good_spectra"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._flag_good_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">_flag_good_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">:</span>
            <span class="n">fgoodpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">check_fgoodpix</span><span class="p">()</span>
            <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SNR&#39;</span><span class="p">]</span> \
                                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">fgoodpix</span> <span class="o">&amp;</span> <span class="n">good_snr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">above_snr_limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="SpectralIndices.spectra_for_index_measurements"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.spectra_for_index_measurements">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">spectra_for_index_measurements</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">measure_on_unbinned_spaxels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">pixelmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution_fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">emission_line_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the set of spectra for the spectral-index measurements.</span>

<span class="sd">        If the input fwhm is &gt; 0, this function will match the spectral</span>
<span class="sd">        resolution of the data to the spectral-index system, based on</span>
<span class="sd">        the provided FWHM.  It also subtracts the emission-line model if</span>
<span class="sd">        provided.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Allow resolution_fwhm to be wavelength dependent, provided</span>
<span class="sd">            via a vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            binned_spectra</span>
<span class="sd">                (:class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra`):</span>
<span class="sd">                The binned spectra object.  The returned spectra are</span>
<span class="sd">                either the binned spectra or the DRP spectra internal to</span>
<span class="sd">                this object.</span>
<span class="sd">            measure_on_unbinned_spaxels (bool): (**Optional**) Flag to</span>
<span class="sd">                return the unbinned spaxels as opposed to the binned</span>
<span class="sd">                spectra.  Default is to use the binned spectra.</span>
<span class="sd">            pixelmask</span>
<span class="sd">                (:class:`mangadap.util.pixelmask.SpectralPixelMask`):</span>
<span class="sd">                (**Optional**) Defines the pixels that should</span>
<span class="sd">                automatically be masked during the measurements.  By</span>
<span class="sd">                default, nothing is masked in addition to that specified</span>
<span class="sd">                by the data mask.</span>
<span class="sd">            select (numpy.ndarray): (**Optional**) Boolean vector</span>
<span class="sd">                selecting which spectra to return.  The length must</span>
<span class="sd">                match the number of binned spectra or the total number</span>
<span class="sd">                of DRP spectra, depending on the provided</span>
<span class="sd">                :arg:`measure_on_unbinned_spaxels`.  Default is to</span>
<span class="sd">                return all spectra.</span>

<span class="sd">            resolution_fwhm (float): (**Optional**)</span>
<span class="sd">                Wavelength-independent FWHM of the resolution element at</span>
<span class="sd">                which to measure the indices.  If</span>
<span class="sd">                &gt; 0, the spectra are resolution matched from the input</span>
<span class="sd">                resolution to the provided resolution; otherwise, the</span>
<span class="sd">                resolution is not altered.</span>

<span class="sd">            emission_line_model</span>
<span class="sd">                (:class:`mangadap.proc.emissionlinemodel.EmissionLineModel`):</span>
<span class="sd">                (**Optional**) Object providing the emission-line model.</span>
<span class="sd">                The emission-line model must match the selection of the</span>
<span class="sd">                spectra (binned or unbinned) to fit, as given by the</span>
<span class="sd">                fitting method (`deconstruct_bins`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, numpy.ma.MaskedArray: Three arrays are</span>
<span class="sd">            returned: (1) the common wavelength vector, (2) the masked</span>
<span class="sd">            flux array, and (3) the masked inverse variance array.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the emission-line model and spectra</span>
<span class="sd">                selection (binned vs. unbinned) do not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that the spectrum selection and emission-line model are</span>
        <span class="c1"># consistent</span>
        <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> <span class="ow">and</span> <span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">emission_line_model</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use this emission-line model with unbinned spaxels.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the main data arrays</span>
        <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">:</span>
            <span class="c1"># TODO: Should probably make this a function within</span>
            <span class="c1"># SpatiallyBinnedSpectra, particularly because of the</span>
            <span class="c1"># dereddening</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">do_not_fit_flags</span><span class="p">()</span>
            <span class="n">binid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                                                                <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>
            <span class="n">wave</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">ivar</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">deredden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spectral_resolution</span><span class="p">(</span>
                        <span class="n">ext</span><span class="o">=</span> <span class="s1">&#39;SPECRES&#39;</span> <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;spec_res&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cube&#39;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">toarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;prepixel_sres&#39;</span><span class="p">],</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">do_not_fit_flags</span><span class="p">()</span>
            <span class="n">binid</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">wave</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">ivar</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">)</span>

        <span class="c1"># Total number of spectra</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Mask any pixels in the pixel mask</span>
        <span class="k">if</span> <span class="n">pixelmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">pixelmask</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">nspec</span><span class="o">=</span><span class="n">nspec</span><span class="p">)</span>
            <span class="n">flux</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">ivar</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Remove the emission lines if provided        </span>
<span class="c1">#        warnings.warn(&#39;DEBUG&#39;)</span>
        <span class="k">if</span> <span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="c1">#            pyplot.imshow(flux, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
            <span class="n">eml_model</span> <span class="o">=</span> <span class="n">emission_line_model</span><span class="o">.</span><span class="n">fill_to_match</span><span class="p">(</span><span class="n">binid</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">)</span>
<span class="c1">#            pyplot.imshow(eml_model, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
            <span class="n">no_eml</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">eml_model</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">-=</span> <span class="n">eml_model</span>
            <span class="n">flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">no_eml</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1">#            pyplot.imshow(flux, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#            exit()</span>

        <span class="c1"># Make sure ivar mask is identical to flux mask</span>
        <span class="n">ivar</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set the selected spectra</span>
        <span class="n">_select</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">select</span>

        <span class="c1"># Adjust the spectral resolution</span>
        <span class="n">_resolution_fwhm</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">resolution_fwhm</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">resolution_fwhm</span>
        <span class="k">if</span> <span class="n">_resolution_fwhm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">adjust_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">_resolution_fwhm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">select</span><span class="p">,:],</span> <span class="n">ivar</span><span class="p">[</span><span class="n">select</span><span class="p">,:]</span></div>


<div class="viewcode-block" id="SpectralIndices.adjust_spectral_resolution"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.adjust_spectral_resolution">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">adjust_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">resolution_fwhm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        flux and ivar are expected to be masked arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Revert flux and ivar to unmasked arrays</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">ivar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># For masked pixels, interpolate across them using simple linear</span>
        <span class="c1"># interpolation.</span>
        <span class="c1"># TODO: This approach needs to be vetted.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>              <span class="c1"># Masked pixels</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>       <span class="c1"># Unmasked pixels</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>      <span class="c1"># No masked pixels so continue</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>      <span class="c1"># No unmasked pixels!</span>
                <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">continue</span>
            <span class="c1"># Linearly interpolate both the flux and inverse variance</span>
            <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">mp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="n">mp</span><span class="p">],</span> <span class="n">wave</span><span class="p">[</span><span class="n">up</span><span class="p">],</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">up</span><span class="p">])</span>
            <span class="n">ivar</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">mp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="n">mp</span><span class="p">],</span> <span class="n">wave</span><span class="p">[</span><span class="n">up</span><span class="p">],</span> <span class="n">ivar</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">up</span><span class="p">])</span>

<span class="c1">#        pyplot.step(wave, flux[0,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;r&#39;, lw=0.5)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Use :func:`mangadap.util.resolution.match_spectral_resolution`</span>
        <span class="c1"># to match the spectral resolution of the binned spectra to the</span>
        <span class="c1"># spectral-index system</span>
        <span class="n">new_sres</span> <span class="o">=</span> <span class="n">wave</span><span class="o">/</span><span class="n">resolution_fwhm</span>
        
        <span class="n">_flux</span><span class="p">,</span> <span class="n">_sres</span><span class="p">,</span> <span class="n">sigoff</span><span class="p">,</span> <span class="n">_mask</span><span class="p">,</span> <span class="n">_ivar</span> \
                <span class="o">=</span> <span class="n">match_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span>
                                            <span class="n">log10</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">new_log10</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># FOR DEBUGGING</span>
<span class="c1">#        warnings.warn(&#39;NOT MATCHING SPECTRAL RESOLUTION!&#39;)</span>
<span class="c1">#        new_flux = flux.copy()</span>
<span class="c1">#        new_mask = mask.copy()</span>

<span class="c1">#        pyplot.step(wave, flux[0,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;k&#39;, lw=0.5)</span>
<span class="c1">#        pyplot.step(wave, new_flux[0,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;r&#39;, lw=2.5)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        pyplot.step(wave, ivar[0,:]/numpy.mean(ivar[0,:]), where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;k&#39;,</span>
<span class="c1">#                    lw=0.5)</span>
<span class="c1">#        pyplot.step(wave, new_ivar[0,:]/numpy.mean(new_ivar[0,:]), where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;r&#39;, lw=2.5)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># From resolution.py:  &quot;Any pixel that had a resolution that was</span>
        <span class="c1"># lower than the target resolution (up to some tolerance defined</span>
        <span class="c1"># by *min_sig_pix*) is returned as masked.&quot;  This is exactly</span>
        <span class="c1"># what should be masked with the SPECRES_LOW bit.</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices.unit_selection"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.unit_selection">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unit_selection</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean arrays selection which indices are unitless, in</span>
<span class="sd">        angstrom units, or in magnitude units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nabs</span><span class="p">,</span> <span class="n">nbhd</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">count_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">)</span>
        
        <span class="c1"># Flag the indices as either having magnitude or angstrom units</span>
        <span class="n">angu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nabs</span> <span class="o">+</span> <span class="n">nbhd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">magu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nabs</span> <span class="o">+</span> <span class="n">nbhd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ules</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nabs</span> <span class="o">+</span> <span class="n">nbhd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Flag absorption-line indices as either angstrom or magnitude</span>
        <span class="k">if</span> <span class="n">nabs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">angu</span><span class="p">[:</span><span class="n">nabs</span><span class="p">]</span> <span class="o">=</span> <span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ang&#39;</span>
            <span class="n">magu</span><span class="p">[:</span><span class="n">nabs</span><span class="p">]</span> <span class="o">=</span> <span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span>

        <span class="c1"># Bandhead indices are unitless</span>
        <span class="k">if</span> <span class="n">nbhd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ules</span><span class="p">[</span><span class="n">nabs</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">ules</span><span class="p">,</span> <span class="n">angu</span><span class="p">,</span> <span class="n">magu</span></div>


<div class="viewcode-block" id="SpectralIndices._resolution_matched_templates"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices._resolution_matched_templates">[docs]</a>    <span class="k">def</span> <span class="nf">_resolution_matched_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a version of the template library that has had its</span>
<span class="sd">        resolution matched to that of the spectral-index database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">velocity_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">velocity_offset</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">get_template_library</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                                                           <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span>
                                                           <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="n">tpl_symlink_dir</span><span class="p">,</span>
                                                           <span class="n">velocity_offset</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">,</span>
                                                           <span class="n">resolution_fwhm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">])</span></div>
    

<div class="viewcode-block" id="SpectralIndices.calculate_dispersion_corrections"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.calculate_dispersion_corrections">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_dispersion_corrections</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">continuum</span><span class="p">,</span> <span class="n">continuum_dcnvlv</span><span class="p">,</span>
                                         <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_dcnvlv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the dispersion corrections using the best-fitting</span>
<span class="sd">        template models.</span>

<span class="sd">        Allow the &quot;deconvolved&quot; continuum spectra to be at a different</span>
<span class="sd">        redshift than the best-fitting continuum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        pyplot.step(wave, flux[0,:], where=&#39;mid&#39;, linestyle=&#39;-&#39;, color=&#39;k&#39;, lw=0.5, zorder=1)</span>
<span class="c1">#        pyplot.plot(wave, continuum[0,:], linestyle=&#39;-&#39;, color=&#39;g&#39;, lw=1.0, zorder=3, alpha=0.5)</span>
<span class="c1">#        pyplot.plot(wave, continuum_dcnvlv[0,:], linestyle=&#39;-&#39;, color=&#39;b&#39;, lw=1.0, zorder=3,</span>
<span class="c1">#                    alpha=0.5)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Make sure continuum includes the flux masks</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">_continuum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span>
        <span class="n">_continuum_dcnvlv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">continuum_dcnvlv</span><span class="p">)</span>
        <span class="n">_continuum</span><span class="p">[</span><span class="n">_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">_continuum_dcnvlv</span><span class="p">[</span><span class="n">_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Measure the indices for both sets of spectra</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">measure_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">_continuum</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                                               <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>
        <span class="n">dcnvlv_indx</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">measure_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">_continuum_dcnvlv</span><span class="p">,</span>
                                                      <span class="n">redshift</span><span class="o">=</span><span class="n">redshift_dcnvlv</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>

<span class="c1">#        print(&#39;Flagged D4000:&#39;)</span>
<span class="c1">#        for bit in [&#39;MAIN_EMPTY&#39;, &#39;BLUE_EMPTY&#39;, &#39;RED_EMPTY&#39;, &#39;DIVBYZERO&#39; ]:</span>
<span class="c1">#            print(&#39;indx {0}:        {1}/{2}&#39;.format(bit,</span>
<span class="c1">#                                            numpy.sum(bitmask.flagged(indx[&#39;MASK&#39;][:,43],</span>
<span class="c1">#                                            flag=bit)), indx[&#39;MASK&#39;].shape[0]))</span>
<span class="c1">#            print(&#39;dcnvlv_indx {0}: {1}/{2}&#39;.format(bit,</span>
<span class="c1">#                                            numpy.sum(bitmask.flagged(dcnvlv_indx[&#39;MASK&#39;][:,43],</span>
<span class="c1">#                                            flag=bit)), dcnvlv_indx[&#39;MASK&#39;].shape[0]))</span>

        <span class="c1"># Do not apply the correction if any of the bands were empty or</span>
        <span class="c1"># would have had to divide by zero</span>
        <span class="n">bad_indx</span> <span class="o">=</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;MAIN_EMPTY&#39;</span><span class="p">,</span> <span class="s1">&#39;BLUE_EMPTY&#39;</span><span class="p">,</span> <span class="s1">&#39;RED_EMPTY&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;DIVBYZERO&#39;</span> <span class="p">])</span>
        <span class="n">bad_indx</span> <span class="o">|=</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">dcnvlv_indx</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;MAIN_EMPTY&#39;</span><span class="p">,</span> <span class="s1">&#39;BLUE_EMPTY&#39;</span><span class="p">,</span>
                                                                <span class="s1">&#39;RED_EMPTY&#39;</span><span class="p">,</span> <span class="s1">&#39;DIVBYZERO&#39;</span> <span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of indices: &#39;</span><span class="p">,</span> <span class="n">bad_indx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bad indices: &#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bad_indx</span><span class="p">))</span>

        <span class="c1"># Determine which indices have good measurements</span>
        <span class="n">ules</span><span class="p">,</span> <span class="n">angu</span><span class="p">,</span> <span class="n">magu</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">unit_selection</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">)</span>
        <span class="n">good_les</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">bad_indx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ules</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">))</span> \
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">good_ang</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">bad_indx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angu</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">))</span> \
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">good_mag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">bad_indx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">magu</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Good unitless indices: &#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_les</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Good angstrom indices: &#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_ang</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Good magnitude indices: &#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_mag</span><span class="p">))</span>

        <span class="c1"># Save the *good* indices for the best-fitting models</span>
        <span class="n">model_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">model_indices</span><span class="p">[</span><span class="n">good_les</span> <span class="o">|</span> <span class="n">good_ang</span> <span class="o">|</span> <span class="n">good_mag</span><span class="p">]</span> \
                <span class="o">=</span> <span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_les</span> <span class="o">|</span> <span class="n">good_ang</span> <span class="o">|</span> <span class="n">good_mag</span><span class="p">]</span>

        <span class="c1"># Determine the dispersion corrections</span>
        <span class="n">corrections</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">corrections</span><span class="p">[</span><span class="n">good_les</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcnvlv_indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">]</span> <span class="o">/</span> <span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">]</span>
        <span class="n">corrections</span><span class="p">[</span><span class="n">good_ang</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcnvlv_indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">]</span> <span class="o">/</span> <span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">]</span>
        <span class="n">corrections</span><span class="p">[</span><span class="n">good_mag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcnvlv_indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">]</span> <span class="o">-</span> <span class="n">indx</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">]</span>

        <span class="c1"># Return the results</span>
        <span class="k">return</span> <span class="n">model_indices</span><span class="p">,</span> <span class="n">corrections</span><span class="p">,</span> <span class="n">good_les</span><span class="p">,</span> <span class="n">good_ang</span><span class="p">,</span> <span class="n">good_mag</span></div>


<div class="viewcode-block" id="SpectralIndices.apply_dispersion_corrections"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.apply_dispersion_corrections">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">apply_dispersion_corrections</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">indxcorr</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a set of dispersion corrections.  Errors in the dispersion</span>
<span class="sd">        corrections are assumed to be negligible.</span>

<span class="sd">        Args:</span>
<span class="sd">            indx (array-like): Indices to correct.</span>
<span class="sd">            indxcorr (array-like): Index corrections.</span>
<span class="sd">            err (array-like): (**Optional**) Error in the indices.</span>
<span class="sd">            unit (str): (**Optional**) Unit of the index; must be either</span>
<span class="sd">                magnitudes (mag) or angstroms (ang) or None.  Default is</span>
<span class="sd">                None.  Unitless corrections and angstrom corrections are</span>
<span class="sd">                treated identically.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The corrected indices and errors are</span>
<span class="sd">            returned.  If no errors are returned, the second returned</span>
<span class="sd">            object is None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the unit is not ang or mag.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;ang&#39;</span><span class="p">,</span> <span class="s1">&#39;mag&#39;</span> <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unit must be None, ang, or mag.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;ang&#39;</span> <span class="p">]:</span>
            <span class="n">_indx</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="n">indxcorr</span>
            <span class="n">_err</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">err</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">indxcorr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_indx</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">+</span> <span class="n">indxcorr</span>
            <span class="n">_err</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">err</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_indx</span><span class="p">,</span> <span class="n">_err</span></div>


<div class="viewcode-block" id="SpectralIndices.count_indices"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.count_indices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">count_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the total number (absorption-line and bandhead) indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">absdb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">absdb</span><span class="o">.</span><span class="n">nsets</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">bhddb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bhddb</span><span class="o">.</span><span class="n">nsets</span></div>


<div class="viewcode-block" id="SpectralIndices.output_dtype"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.output_dtype">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">output_dtype</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the record array data type for the output fits</span>
<span class="sd">        extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;BINID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">(),</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;BCEN&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;BCONT&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;BCONTERR&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;RCEN&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;RCONT&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;RCONTERR&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;INDX&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,)),</span> 
                 <span class="p">(</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="n">nindx</span><span class="p">,))</span>
               <span class="p">]</span></div>


<div class="viewcode-block" id="SpectralIndices.check_and_prep_input"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.check_and_prep_input">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_and_prep_input</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Check the bitmask if provided</span>
        <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">BitMask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input bitmask must have type BitMask.&#39;</span><span class="p">)</span>

        <span class="c1"># Check the input wavelength and flux shapes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input wavelengths must be a single vector.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wavelength vector does not match shape of the flux array.&#39;</span><span class="p">)</span>

        <span class="c1"># Check the mask shape</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input mask must have the same shape as the flux array.&#39;</span><span class="p">)</span>

        <span class="c1"># Check the input redshifts</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">redshift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">redshift</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_redshift</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nspec</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide one redshift per input spectrum (flux.shape[0]).&#39;</span><span class="p">)</span>

        <span class="c1"># Convert the input arrays to masked arrays if they aren&#39;t</span>
        <span class="c1"># already, and compare the array shapes</span>
        <span class="n">_flux</span> <span class="o">=</span> <span class="n">flux</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">else</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ivar</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input ivar array must be the same shape as the flux array.&#39;</span><span class="p">)</span>
            <span class="n">_ivar</span> <span class="o">=</span> <span class="n">ivar</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">else</span> \
                        <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span><span class="n">_ivar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">_redshift</span></div>


<div class="viewcode-block" id="SpectralIndices.set_masks"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.set_masks">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_masks</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="n">blue_incomplete</span><span class="p">,</span> <span class="n">blue_empty</span><span class="p">,</span> <span class="n">red_incomplete</span><span class="p">,</span> <span class="n">red_empty</span><span class="p">,</span> <span class="n">divbyzero</span><span class="p">,</span>
                  <span class="n">main_incomplete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">main_empty</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="c1">#        print(&#39;blue incomplete: {0}/{1}&#39;.format(numpy.sum(blue_incomplete), blue_incomplete.size))</span>
<span class="c1">#        print(&#39;blue empty: {0}/{1}&#39;.format(numpy.sum(blue_empty), blue_empty.size))</span>
<span class="c1">#        print(&#39;red incomplete: {0}/{1}&#39;.format(numpy.sum(red_incomplete), red_incomplete.size))</span>
<span class="c1">#        print(&#39;red empty: {0}/{1}&#39;.format(numpy.sum(red_empty), red_empty.size))</span>
<span class="c1">#        print(&#39;divbyzero: {0}/{1}&#39;.format(numpy.sum(divbyzero), divbyzero.size))</span>
<span class="c1">#        if main_incomplete is not None:</span>
<span class="c1">#            print(&#39;main incomplete: {0}/{1}&#39;.format(numpy.sum(main_incomplete),</span>
<span class="c1">#                                                    main_incomplete.size))</span>
<span class="c1">#        if main_empty is not None:</span>
<span class="c1">#            print(&#39;main empty: {0}/{1}&#39;.format(numpy.sum(main_empty), main_empty.size))</span>

        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">blue_incomplete</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">blue_incomplete</span><span class="p">],</span> <span class="s1">&#39;BLUE_INCOMP&#39;</span><span class="p">)</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">blue_empty</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">blue_empty</span><span class="p">],</span> <span class="s1">&#39;BLUE_EMPTY&#39;</span><span class="p">)</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">red_incomplete</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">red_incomplete</span><span class="p">],</span> <span class="s1">&#39;RED_INCOMP&#39;</span><span class="p">)</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">red_empty</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">red_empty</span><span class="p">],</span> <span class="s1">&#39;RED_EMPTY&#39;</span><span class="p">)</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">divbyzero</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">divbyzero</span><span class="p">],</span> <span class="s1">&#39;DIVBYZERO&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main_incomplete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">main_incomplete</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">main_incomplete</span><span class="p">],</span> <span class="s1">&#39;MAIN_INCOMP&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">main_empty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">main_empty</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">main_empty</span><span class="p">],</span> <span class="s1">&#39;MAIN_EMPTY&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">measurements</span></div>


<div class="viewcode-block" id="SpectralIndices.save_results"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.save_results">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="p">(</span><span class="n">AbsorptionLineIndices</span><span class="p">,</span> <span class="n">BandheadIndices</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input must be of type AbsorptionLineIndices or BandheadIndices&#39;</span><span class="p">)</span>

        <span class="c1"># Save the data</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BCEN&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">blue_center</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BCONT&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">blue_continuum</span>
        <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BCONTERR&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">blue_continuum_err</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;RCEN&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">red_center</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;RCONT&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">red_continuum</span>
        <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;RCONTERR&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">red_continuum_err</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">index_err</span>

        <span class="c1"># Reshape the flags</span>
        <span class="n">blue_incomplete</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">blue_incomplete</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">blue_incomplete</span>
        <span class="n">blue_empty</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">blue_empty</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">blue_empty</span>
        <span class="n">red_incomplete</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">red_incomplete</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">red_incomplete</span>
        <span class="n">red_empty</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">red_empty</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">red_empty</span>
        <span class="n">main_incomplete</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">main_incomplete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_incomplete</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">main_incomplete</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">main_incomplete</span>
        <span class="n">main_empty</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">main_empty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_empty</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">main_empty</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">main_empty</span>
        <span class="n">divbyzero</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">divbyzero</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">divbyzero</span>

        <span class="c1"># Set the masks</span>
        <span class="k">return</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">set_masks</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="n">blue_incomplete</span><span class="p">,</span> <span class="n">blue_empty</span><span class="p">,</span> <span class="n">red_incomplete</span><span class="p">,</span>
                                         <span class="n">red_empty</span><span class="p">,</span> <span class="n">divbyzero</span><span class="p">,</span> <span class="n">main_incomplete</span><span class="o">=</span><span class="n">main_incomplete</span><span class="p">,</span>
                                         <span class="n">main_empty</span><span class="o">=</span><span class="n">main_empty</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices.measure_indices"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.measure_indices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">measure_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measure the spectral indices in a set of spectra.</span>

<span class="sd">        Args:</span>
<span class="sd">            absdb</span>
<span class="sd">                (:class:`mangadap.par.aborptionlinedb.AbsorptionIndexDB`):</span>
<span class="sd">                Database with the absorption-line index definitions.</span>
<span class="sd">                Can be None.</span>
<span class="sd">            bhddb</span>
<span class="sd">                (:class:`mangadap.par.bandheadindexdb.BandheadIndexDB`):</span>
<span class="sd">                Database with the bandhead index definitions.</span>
<span class="sd">            wave (array-like): 1D vector with the wavelength of each</span>
<span class="sd">                pixel.  *Assumed to be logarithmically binned in</span>
<span class="sd">                radius.*</span>
<span class="sd">            flux (array-like): 2D array with the flux, ordered as</span>
<span class="sd">                :math:`N_{\rm spec}\times N_{\rm wave}`.  Can be a</span>
<span class="sd">                numpy.ma.MaskedArray; masked pixels will be ignored in</span>
<span class="sd">                the measurement.</span>
<span class="sd">            ivar (array-like): (**Optional**) Inverse variance in the</span>
<span class="sd">                flux.  Must match flux array shape.  Used to calculate</span>
<span class="sd">                propagated errors in the index.  Default is that errors</span>
<span class="sd">                are ignored.</span>
<span class="sd">            mask (array-like): (**Optional**) Boolean array flagging to</span>
<span class="sd">                ignore (mask=True) or include (mask=False) each flux</span>
<span class="sd">                measurement in the index calculation.</span>
<span class="sd">            redshift (array-like): (**Optional**) Redshift to use for</span>
<span class="sd">                each spectrum when determining the index.  Must have the</span>
<span class="sd">                correct length compared to the flux array.  Default is</span>
<span class="sd">                to assume the spectra are at rest wavelength.</span>
<span class="sd">            bitmask (:class:`mangadap.util.bitmask.BitMask`):</span>
<span class="sd">                (**Optional**)  If an index is flagged for some reason</span>
<span class="sd">                (see :func:`set_masks`), this object is used to set the</span>
<span class="sd">                mask value; this should typically be</span>
<span class="sd">                :class:`SpectralIndicesBitMask` object.  If not</span>
<span class="sd">                provided, the masked values are all set to True (False</span>
<span class="sd">                otherwise).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `numpy.recarray`_: A record array with the following</span>
<span class="sd">            columns, each with one element per spectrum:</span>

<span class="sd">                 0. ``BINID``: Bin identifier</span>
<span class="sd">                 1. ``BINID_INDEX``: Index of the bin identifier</span>
<span class="sd">                 2. ``REDSHIFT``: Redshift used for measurement</span>
<span class="sd">                 3. ``MASK``: Boolean or maskbit value for index</span>
<span class="sd">                 4. ``BCEN``: Blue passband center</span>
<span class="sd">                 5. ``BCONT``: Blue passband pseudo-continuum</span>
<span class="sd">                 6. ``BCONTERR``: Error in the above</span>
<span class="sd">                 7. ``RCEN``: Red passband center</span>
<span class="sd">                 8. ``RCONT``: Red passband pseudo-continuum</span>
<span class="sd">                 9. ``RCONTERR``: Error in the above</span>
<span class="sd">                10. ``INDX``: Index value</span>
<span class="sd">                11. ``INDXERR``: Error in the above</span>
<span class="sd">                12. ``MODEL_INDX``: Index measured on the best-fitting</span>
<span class="sd">                                    stellar-continuum model</span>
<span class="sd">                13. ``INDX_DISPCORR``: Index dispersion correction</span>

<span class="sd">            This function does not add the ``BINID``, ``BINID_INDEX``,</span>
<span class="sd">            or ``INDX_DISPCORR`` values.  Each element in columns 3-12</span>
<span class="sd">            are vectors with a length of :math:`N_{\rm index}` --- the</span>
<span class="sd">            total number of indices calcualte (see</span>
<span class="sd">            :func:`count_indices`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the input databases</span>
        <span class="k">if</span> <span class="n">absdb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">AbsorptionIndexDB</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input database must have type AbsorptionIndexDB.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bhddb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bhddb</span><span class="p">,</span> <span class="n">BandheadIndexDB</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input database must have type BandheadIndexDB.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the number of indices</span>
        <span class="n">nabs</span><span class="p">,</span> <span class="n">nbhd</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">count_indices</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">)</span>
        <span class="n">nindx</span> <span class="o">=</span> <span class="n">nabs</span><span class="o">+</span><span class="n">nbhd</span>
        <span class="k">if</span> <span class="n">nindx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No indices to measure!&#39;</span><span class="p">)</span>

        <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Check the input and initialize the output</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">output_dtype</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span><span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">))</span>
        <span class="n">_flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">check_and_prep_input</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                                           <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>
<span class="c1">#        print(_flux.shape)</span>
<span class="c1">#        print(None if noise is None else noise.shape)</span>
<span class="c1">#        print(wave.shape)</span>
<span class="c1">#        print((numpy.array([wave]*nspec)).shape)</span>

        <span class="c1"># Create the f_nu spectra</span>
        <span class="c1"># The conversion is multiplicative, meaning the calculation of</span>
        <span class="c1"># the error calculation can use exactly the same function </span>
        <span class="n">flux_fnu</span> <span class="o">=</span> <span class="n">flux_to_fnu</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wave</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">),</span> <span class="n">_flux</span><span class="p">)</span>
        <span class="n">noise_fnu</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">flux_to_fnu</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wave</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">),</span> <span class="n">noise</span><span class="p">)</span>

<span class="c1">#        nu = 1e-13*astropy.constants.c.to(&#39;nm/s&#39;).value/wave    # In THz</span>
<span class="c1">#        pyplot.plot(wave, _flux[0,:]*wave, linestyle=&#39;-&#39;, color=&#39;r&#39;, lw=1, zorder=2)</span>
<span class="c1">#        pyplot.plot(wave, flux_fnu[0,:]*nu, linestyle=&#39;-&#39;, color=&#39;0.5&#39;, lw=3, zorder=1)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Get the list of good indices of each type</span>
        <span class="n">abs_fnu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nabs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">absdb</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">absdb</span><span class="o">.</span><span class="n">dummy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;integrand&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fnu&#39;</span><span class="p">)</span>
        <span class="n">good_abs_fnu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nabs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">good_abs_fnu</span><span class="p">[:</span><span class="n">nabs</span><span class="p">][</span><span class="n">abs_fnu</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">abs_flambda</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nabs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">absdb</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">absdb</span><span class="o">.</span><span class="n">dummy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;integrand&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;flambda&#39;</span><span class="p">)</span>
        <span class="n">good_abs_flambda</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nabs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">good_abs_flambda</span><span class="p">[:</span><span class="n">nabs</span><span class="p">][</span><span class="n">abs_flambda</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">bhd_fnu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbhd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">bhddb</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">bhddb</span><span class="o">.</span><span class="n">dummy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;integrand&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;fnu&#39;</span><span class="p">)</span>
        <span class="n">good_bhd_fnu</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbhd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">good_bhd_fnu</span><span class="p">[</span><span class="n">nabs</span><span class="p">:][</span><span class="n">bhd_fnu</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">bhd_flambda</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbhd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">bhddb</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">bhddb</span><span class="o">.</span><span class="n">dummy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;integrand&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;flambda&#39;</span><span class="p">)</span>
        <span class="n">good_bhd_flambda</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbhd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">good_bhd_flambda</span><span class="p">[</span><span class="n">nabs</span><span class="p">:][</span><span class="n">bhd_flambda</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Mask any dummy indices</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nindx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">dummy</span><span class="p">[:</span><span class="n">nabs</span><span class="p">]</span> <span class="o">=</span> <span class="n">absdb</span><span class="o">.</span><span class="n">dummy</span>
        <span class="n">dummy</span><span class="p">[</span><span class="n">nabs</span><span class="p">:]</span> <span class="o">=</span> <span class="n">bhddb</span><span class="o">.</span><span class="n">dummy</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dummy</span><span class="p">):</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">dummy</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                    <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">dummy</span><span class="p">],</span> <span class="s1">&#39;UNDEFINED_BANDS&#39;</span><span class="p">)</span>

        <span class="c1"># No valid indices</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dummy</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">measurements</span>

        <span class="c1"># Perform the measurements on each spectrum</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Measuring spectral indices in spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># -----------------------------------</span>
            <span class="c1"># Measure the absorption-line indices</span>
            <span class="k">if</span> <span class="n">nabs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># Shift the bands</span>
                <span class="n">_bluebands</span> <span class="o">=</span> <span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;blueside&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">_redbands</span> <span class="o">=</span> <span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;redside&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">_mainbands</span> <span class="o">=</span> <span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;primary&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Integrate over F_nu</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_abs_fnu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Make the measurements ...</span>
                    <span class="n">_noise</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">noise_fnu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise_fnu</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">AbsorptionLineIndices</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux_fnu</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">_bluebands</span><span class="p">[</span><span class="n">abs_fnu</span><span class="p">],</span>
                                                    <span class="n">_redbands</span><span class="p">[</span><span class="n">abs_fnu</span><span class="p">],</span> <span class="n">_mainbands</span><span class="p">[</span><span class="n">abs_fnu</span><span class="p">],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">_noise</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">][</span><span class="n">abs_fnu</span><span class="p">])</span>
                    <span class="c1"># ... and save them</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                   <span class="n">good_abs_fnu</span><span class="p">,</span>
                                                                   <span class="n">err</span><span class="o">=</span><span class="n">_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                                                                   <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>

                <span class="c1"># Integrate over F_lambda</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_abs_flambda</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Make the measurements ...</span>
                    <span class="n">_noise</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">AbsorptionLineIndices</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">_bluebands</span><span class="p">[</span><span class="n">abs_flambda</span><span class="p">],</span>
                                                    <span class="n">_redbands</span><span class="p">[</span><span class="n">abs_flambda</span><span class="p">],</span> <span class="n">_mainbands</span><span class="p">[</span><span class="n">abs_flambda</span><span class="p">],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">_noise</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">absdb</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">][</span><span class="n">abs_flambda</span><span class="p">])</span>
                    <span class="c1"># ... and save them</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                   <span class="n">good_abs_flambda</span><span class="p">,</span>
                                                                   <span class="n">err</span><span class="o">=</span><span class="n">_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                                                                   <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>

            <span class="c1"># -----------------------------------</span>
            <span class="c1"># Measure the bandhead indices</span>
            <span class="k">if</span> <span class="n">nbhd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># Shift the bands</span>
                <span class="n">_bluebands</span> <span class="o">=</span> <span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;blueside&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">_redbands</span> <span class="o">=</span> <span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;redside&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Integrate over F_nu</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_bhd_fnu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Make the measurements ...</span>
                    <span class="n">_noise</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">noise_fnu</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise_fnu</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">BandheadIndices</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux_fnu</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">_bluebands</span><span class="p">[</span><span class="n">bhd_fnu</span><span class="p">],</span>
                                              <span class="n">_redbands</span><span class="p">[</span><span class="n">bhd_fnu</span><span class="p">],</span> <span class="n">err</span><span class="o">=</span><span class="n">_noise</span><span class="p">,</span>
                                              <span class="n">order</span><span class="o">=</span><span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">][</span><span class="n">bhd_fnu</span><span class="p">])</span>
                    <span class="c1"># ... and save them</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                   <span class="n">good_bhd_fnu</span><span class="p">,</span>
                                                                   <span class="n">err</span><span class="o">=</span><span class="n">_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                                                                   <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>

                <span class="c1"># Integrate over F_lambda</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_bhd_flambda</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Make the measurements ...</span>
                    <span class="n">_noise</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">BandheadIndices</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">_bluebands</span><span class="p">[</span><span class="n">bhd_flambda</span><span class="p">],</span>
                                              <span class="n">_redbands</span><span class="p">[</span><span class="n">bhd_flambda</span><span class="p">],</span> <span class="n">err</span><span class="o">=</span><span class="n">_noise</span><span class="p">,</span>
                                              <span class="n">order</span><span class="o">=</span><span class="n">bhddb</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">][</span><span class="n">bhd_flambda</span><span class="p">])</span>
                    <span class="c1"># ... and save them</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">measurements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                   <span class="n">good_bhd_flambda</span><span class="p">,</span>
                                                                   <span class="n">err</span><span class="o">=</span><span class="n">_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                                                                   <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">)</span>

<span class="c1">#            pyplot.scatter(_interval, interval/_interval, marker=&#39;.&#39;, color=&#39;k&#39;, s=50)</span>
<span class="c1">#            pyplot.show()</span>

<span class="c1">#            center = numpy.mean(_sidebands, axis=1).reshape(-1,self.nindx)</span>
<span class="c1">#            pyplot.step(wave, flux[i,:], where=&#39;mid&#39;, color=&#39;k&#39;, lw=0.5, linestyle=&#39;-&#39;)</span>
<span class="c1">#            pyplot.scatter(center[0,:], measurements[&#39;BCONT&#39;][i,:], marker=&#39;.&#39;,</span>
<span class="c1">#                           s=100, color=&#39;b&#39;, lw=0)</span>
<span class="c1">#            pyplot.scatter(center[1,:], measurements[&#39;RCONT&#39;][i,:], marker=&#39;.&#39;,</span>
<span class="c1">#                           s=100, color=&#39;r&#39;, lw=0)</span>
<span class="c1">#            pyplot.show()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Measuring spectral indices in spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nspec</span><span class="p">))</span>

        <span class="c1"># Correct the indices with angstrom units to rest-frame</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">angu</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">unit_selection</span><span class="p">(</span><span class="n">absdb</span><span class="p">,</span> <span class="n">bhddb</span><span class="p">)</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][:,</span><span class="n">angu</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;REDSHIFT&#39;</span><span class="p">][:,</span><span class="kc">None</span><span class="p">])</span>

<span class="c1">#        x = numpy.append(center, numpy.array([[-100]*self.absdb.nsets]).T,axis=1).ravel()</span>
<span class="c1">#        _x = numpy.ma.MaskedArray(x, mask=x==-100)</span>
<span class="c1">#        print(_x)</span>
<span class="c1">#        y = numpy.append(pseudocontinuum, numpy.array([[-100]*self.absdb.nsets]).T,axis=1).ravel()</span>
<span class="c1">#        _y = numpy.ma.MaskedArray(y, mask=y==-100)</span>
<span class="c1">#        print(type(_y))</span>
<span class="c1">#        print(numpy.sum(_y.mask))</span>
<span class="c1">#        pyplot.plot(_x, _y, color=&#39;g&#39;, lw=2, linestyle=&#39;-&#39;)</span>
<span class="c1">#        pyplot.show()</span>

<span class="c1">#        print(&#39;Total masked: {0}/{1}&#39;.format(numpy.sum(measurements[&#39;MASK&#39;] &gt; 0),</span>
<span class="c1">#                                             measurements[&#39;MASK&#39;].size))</span>

        <span class="c1"># Return the data</span>
        <span class="k">return</span> <span class="n">measurements</span></div>


<div class="viewcode-block" id="SpectralIndices.file_name"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.file_name">[docs]</a>    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the output file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span></div>


<div class="viewcode-block" id="SpectralIndices.file_path"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.file_path">[docs]</a>    <span class="k">def</span> <span class="nf">file_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full path to the output file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices.measure"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">emission_line_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measure the spectral indices using the binned spectra and the</span>
<span class="sd">        internal spectral index database, and construct the internal</span>
<span class="sd">        data structure.</span>

<span class="sd">        If neither stellar-continuum nor emission-line models are</span>
<span class="sd">        provided:</span>
<span class="sd">            - Indices are measure on the binned spectra</span>
<span class="sd">            - No velocity-dispersion corrections are calculated</span>

<span class="sd">        If a stellar-continuum model is provided without an</span>
<span class="sd">        emission-line model:</span>
<span class="sd">            - Indices are measured on the binned spectra</span>
<span class="sd">            - Velocity-dispersion corrections are computed for any</span>
<span class="sd">              binned spectrum with a stellar-continuum fit based on the</span>
<span class="sd">              optimal template</span>

<span class="sd">        If an emission-line model is provided without a</span>
<span class="sd">        stellar-continuum model:</span>
<span class="sd">            - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">              spectra; spectra with emission-line fits have the model</span>
<span class="sd">              emission lines subtracted from them before these</span>
<span class="sd">              measurements.</span>
<span class="sd">            - If the emission-line model includes data regarding the</span>
<span class="sd">              stellar-continuum fit (template spectra and template</span>
<span class="sd">              weights), corrections are calculated for spectra with</span>
<span class="sd">              emission-line models based on the continuum fits;</span>
<span class="sd">              otherwise, no corrections are calculated.</span>

<span class="sd">        If both stellar-continuum and emission-line models are provided,</span>
<span class="sd">        and if the stellar-continuum and emission-line fits are</span>
<span class="sd">        performed on the same spectra:</span>
<span class="sd">            - Indices are measured on the relevant (binned or unbinned)</span>
<span class="sd">              spectra; spectra with emission-line fits have the model</span>
<span class="sd">              emission lines subtracted from them before these</span>
<span class="sd">              measurements.</span>
<span class="sd">            - Velocity-dispersion corrections are based on the</span>
<span class="sd">              stellar-continuum templates and weights</span>

<span class="sd">        If both stellar-continuum and emission-line models are provided,</span>
<span class="sd">        and if the stellar-continuum and emission-line fits are</span>
<span class="sd">        performed on different spectra:</span>
<span class="sd">            - The behavior is exactly as if the stellar-continuum model</span>
<span class="sd">              was not provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            binned_spectra</span>
<span class="sd">                (:class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra`):</span>
<span class="sd">                The binned spectra for the measurements.</span>
<span class="sd">            redshift (float, numpy.ndarray): (**Optional**) A single or</span>
<span class="sd">                spectrum-dependent redshift, :math:`z`, to use for</span>
<span class="sd">                shifting the index bands.  Default is to measure the</span>
<span class="sd">                indices at their provided wavelengths (i.e.,</span>

<span class="sd">                :math:`z=0`).  If providing spectrum-dependent values,</span>
<span class="sd">                the number of values must be the same as the number of</span>
<span class="sd">                stpectrum bins (i.e., binned_spectra.nbins) if either</span>
<span class="sd">                the emission-line model is not provided or it was not</span>
<span class="sd">                determined by deconstructing the bins; the number of</span>
<span class="sd">                values must be the same as the number of DRP spectra if</span>
<span class="sd">                the opposite is true (an emission-line model is provided</span>
<span class="sd">                that deconstructed the bins for its fit).</span>


<span class="sd">            stellar_continuum</span>
<span class="sd">                (:class:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel`):</span>
<span class="sd">                (**Optional**) The stellar-continuum model as applied to</span>
<span class="sd">                the binned spectra.</span>
<span class="sd">            emission_line_model</span>
<span class="sd">                (:class:`mangadap.proc.emissionlinemodel.EmissionLineModel`):</span>
<span class="sd">                (**Optional**) The emission-line model as applied to</span>
<span class="sd">                either the binned spectra or the unbinned spaxels.</span>
<span class="sd">            dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">                directory.  If not provided, the default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.dap_source_dir`.</span>
<span class="sd">            dapver (str): (**Optional**) The DAP version to use for the</span>
<span class="sd">                analysis, used to override the default defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_version`.</span>
<span class="sd">            analysis_path (str): (**Optional**) The top-level path for</span>
<span class="sd">                the DAP output files, used to override the default</span>
<span class="sd">                defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">            directory_path (str): The exact path to the directory with</span>
<span class="sd">                DAP output that is common to number DAP &quot;methods&quot;.  See</span>
<span class="sd">                :attr:`directory_path`.</span>
<span class="sd">            output_file (str): (**Optional**) Exact name for the output</span>
<span class="sd">                file.  The default is to use</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">            hardcopy (bool): (**Optional**) Flag to write the HDUList</span>
<span class="sd">                attribute to disk.  Default is True; if False, the</span>
<span class="sd">                HDUList is only kept in memory and would have to be</span>
<span class="sd">                reconstructed.</span>
<span class="sd">            tpl_symlink_dir (str): (**Optional**) Create a symbolic link</span>
<span class="sd">                to the created template library file in the supplied</span>
<span class="sd">                directory.  Default is to produce no symbolic link.</span>
<span class="sd">            clobber (bool): (**Optional**) Overwrite any existing files.</span>
<span class="sd">                Default is to use any existing file instead of redoing</span>
<span class="sd">                the analysis and overwriting the existing output.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_</span>
<span class="sd">                objects to log progress; ignored if quiet=True.  Logging</span>
<span class="sd">                is done using :func:`mangadap.util.log.log_output`.</span>
<span class="sd">                Default is no logging.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.  Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># SpatiallyBinnedSpectra object always needed</span>
        <span class="k">if</span> <span class="n">binned_spectra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide spectra object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectra</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid SpatiallyBinnedSpectra object!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided SpatiallyBinnedSpectra object is undefined!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span> <span class="o">=</span> <span class="n">binned_spectra</span>

        <span class="c1"># Check stellar-continuum model object, if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stellar_continuum</span><span class="p">,</span> <span class="n">StellarContinuumModel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Provided stellar continuum must have StellarContinuumModel type!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stellar_continuum</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided StellarContinuumModel is undefined!&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="o">=</span> <span class="n">stellar_continuum</span>

        <span class="c1"># Check emission-line model object, if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emission_line_model</span><span class="p">,</span> <span class="n">EmissionLineModel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Provided emission line models must be of type EmissionLineModel.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">emission_line_model</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided EmissionLineModel is undefined!&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="o">=</span> <span class="n">emission_line_model</span>

        <span class="c1"># What stellar continuum is available?</span>
        <span class="c1">#  - Assume the stellar continuum can always be extracted if a</span>
        <span class="c1">#    StellarContinuumModel object is provided</span>
        <span class="c1">#  - Check if the EmissionLineModel fitter has the appropriate</span>
        <span class="c1">#    function; True for Sasuke, not currently true for Elric</span>
        <span class="n">eml_stellar_continuum_available</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitclass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construct_continuum_models</span><span class="p">)</span>

        <span class="c1"># Determine if the velocity-dispersion corrections can be</span>
        <span class="c1"># determined</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;compute_corrections&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">eml_stellar_continuum_available</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cannot compute dispersion corrections; no continuum model available.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Can only correct the indices if the corrections are provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_indices</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cannot apply corrections because they are not being computed.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correct_indices</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># What spectra to use?</span>
        <span class="c1">#  - Assume StellarContinuumModel always fits the binned spectra</span>
        <span class="c1">#  - The EmissionLineModel fits the binned spectra or unbinned</span>
        <span class="c1">#    spaxels as specified by its deconstruct_bins flag</span>
        <span class="n">measure_on_unbinned_spaxels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nspec</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> \
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the good spectra</span>
        <span class="n">good_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag_good_spectra</span><span class="p">(</span><span class="n">measure_on_unbinned_spaxels</span><span class="p">)</span>

        <span class="c1"># Set the number of bins measured and missing bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">()</span>
        
        <span class="c1"># Get the redshifts to apply</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_redshifts</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">,</span> <span class="n">good_snr</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0:^50}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;SPECTRAL-INDEX MEASUREMENTS&#39;</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Measurements for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="s1">&#39;unbinned spaxels&#39;</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> <span class="k">else</span> <span class="s1">&#39;binned spectra&#39;</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">measure_on_unbinned_spaxels</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Missing bins: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;With good S/N and to measure: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)))</span>
            
        <span class="c1"># Make sure there are good spectra</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_snr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No good spectra for measurements!&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># (Re)Set the output paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check that the file path is defined</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ofile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File path for output file is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Report</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span><span class="s1">&#39;Output path: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span><span class="s1">&#39;Output file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">))</span>
        
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># If the file already exists, and not clobbering, just read the</span>
        <span class="c1"># file</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">clobber</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Using existing file&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="k">return</span>

<span class="c1">#        pyplot.scatter(numpy.arange(self.nbins), self.redshift, marker=&#39;.&#39;, s=50, color=&#39;k&#39;, lw=0)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the spectra to use for the measurements</span>
        <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">spectra_for_index_measurements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">,</span>
                                        <span class="n">measure_on_unbinned_spaxels</span><span class="o">=</span><span class="n">measure_on_unbinned_spaxels</span><span class="p">,</span>
                                                    <span class="n">pixelmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelmask</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">good_snr</span><span class="p">,</span>
                                                    <span class="n">resolution_fwhm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">],</span>
                                                    <span class="n">emission_line_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Perform the measurements on the galaxy spectra</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Measuring spectral indices in observed spectra...&#39;</span><span class="p">)</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span>
                                            <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">good_snr</span><span class="p">],</span> <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">)</span>

<span class="c1">#        print(&#39;Flagged D4000:&#39;)</span>
<span class="c1">#        for bit in [&#39;MAIN_EMPTY&#39;, &#39;BLUE_EMPTY&#39;, &#39;RED_EMPTY&#39;, &#39;DIVBYZERO&#39; ]:</span>
<span class="c1">#            print(&#39;measurements {0}: {1}/{2}&#39;.format(bit,</span>
<span class="c1">#                        numpy.sum(self.bitmask.flagged(measurements[&#39;MASK&#39;][:,43], flag=bit)),</span>
<span class="c1">#                        measurements[&#39;MASK&#39;].shape[0]))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Determine the velocity dispersion corrections, if requested.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_corrections</span><span class="p">:</span>

            <span class="c1"># Get the template spectra to use</span>
            <span class="n">replacement_templates</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> \
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolution_matched_templates</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                                                            <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span>
                                                            <span class="n">tpl_symlink_dir</span><span class="o">=</span><span class="n">tpl_symlink_dir</span><span class="p">)</span>
            <span class="c1"># Have to use the corrected velocity dispersion if templates</span>
            <span class="c1"># have been broadened to a new resolution; otherwise, the</span>
            <span class="c1"># corrections are to a zero dispersion model **at the</span>
            <span class="c1"># resolution of the templates**</span>
            <span class="n">corrected_dispersion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c1"># Set the bin IDs to match the stellar continuum to:</span>
            <span class="n">binid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                            <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> \
                                                               <span class="k">else</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># Get two versions of the best-fitting continuum:</span>
            <span class="c1">#   - exactly the best fitting, continuum-only model</span>
            <span class="c1">#   - the same without convolving with the velocity</span>
            <span class="c1">#     dispersion</span>
            <span class="c1"># TODO: To also correct for difference in definition of</span>
            <span class="c1"># velocity, may also want to deredshift the model and</span>
            <span class="c1"># perform the measurements at rest wavelengths; not</span>
            <span class="c1"># currently possible though</span>
            <span class="n">fill_to_match_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_line_model</span><span class="o">.</span><span class="n">fill_continuum_to_match</span> \
                                <span class="k">if</span> <span class="n">eml_stellar_continuum_available</span> <span class="k">else</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">fill_to_match</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing models with LOSVD&#39;</span><span class="p">)</span>
            <span class="n">continuum</span> <span class="o">=</span> <span class="n">fill_to_match_f</span><span class="p">(</span><span class="n">binid</span><span class="p">,</span> <span class="n">replacement_templates</span><span class="o">=</span><span class="n">replacement_templates</span><span class="p">,</span>
                                        <span class="n">corrected_dispersion</span><span class="o">=</span><span class="n">corrected_dispersion</span><span class="p">)</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing models without LOSVD&#39;</span><span class="p">)</span>
            <span class="n">continuum_dcnvlv</span> <span class="o">=</span> <span class="n">fill_to_match_f</span><span class="p">(</span><span class="n">binid</span><span class="p">,</span> <span class="n">replacement_templates</span><span class="o">=</span><span class="n">replacement_templates</span><span class="p">,</span>
                                               <span class="n">redshift_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#, deredshift=True)</span>

<span class="c1">#            pyplot.imshow(flux, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.colorbar()</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#            pyplot.imshow(continuum[good_snr,:], origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="c1">#                          aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.colorbar()</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#            pyplot.imshow(continuum_dcnvlv[good_snr,:], origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="c1">#                          aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.colorbar()</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#            indx = numpy.argmax(numpy.ma.mean(flux, axis=1))</span>
<span class="c1">#            print(indx)</span>
<span class="c1">#            pyplot.plot(wave, flux[indx,:])</span>
<span class="c1">#            pyplot.plot(wave, continuum[good_snr,:][indx,:])</span>
<span class="c1">#            pyplot.plot(wave, continuum_dcnvlv[good_snr,:][indx,:])</span>
<span class="c1">#            pyplot.show()</span>

            <span class="c1"># Get the corrections by performing the measurements on the</span>
            <span class="c1"># best-fitting continuum models, with and without the</span>
            <span class="c1"># velocity dispersion broadening</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Calculating dispersion corrections using stellar continuum model...&#39;</span><span class="p">)</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">],</span> <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">],</span> \
                    <span class="n">good_les</span><span class="p">,</span> <span class="n">good_ang</span><span class="p">,</span> <span class="n">good_mag</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">calculate_dispersion_corrections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absdb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bhddb</span><span class="p">,</span>
                                        <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">continuum</span><span class="p">[</span><span class="n">good_snr</span><span class="p">,:],</span>
                                        <span class="n">continuum_dcnvlv</span><span class="p">[</span><span class="n">good_snr</span><span class="p">,:],</span>
                                        <span class="n">redshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">good_snr</span><span class="p">],</span>
                                        <span class="n">redshift_dcnvlv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">good_snr</span><span class="p">],</span>
                                        <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">)</span>

            <span class="c1"># Flag bad corrections</span>
            <span class="n">bad_correction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_les</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_ang</span><span class="p">)</span> \
                                <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">good_mag</span><span class="p">)</span>
            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">bad_correction</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span>
                                                            <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">bad_correction</span><span class="p">],</span>
                                                            <span class="s1">&#39;NO_DISPERSION_CORRECTION&#39;</span><span class="p">)</span>
            <span class="c1"># Apply the corrections</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_indices</span><span class="p">:</span>
                <span class="c1"># Measured indices</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">],</span> <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">])</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span> <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span>
                                                    <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ang&#39;</span><span class="p">)</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span> <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDXERR&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span>
                                                    <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
                <span class="c1"># Model indices</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">],</span> <span class="n">_</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_les</span><span class="p">])</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span> <span class="n">_</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_ang</span><span class="p">],</span>
                                                    <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ang&#39;</span><span class="p">)</span>
                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span> <span class="n">_</span> \
                        <span class="o">=</span> <span class="n">SpectralIndices</span><span class="o">.</span><span class="n">apply_dispersion_corrections</span><span class="p">(</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;MODEL_INDX&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span>
                                                    <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;INDX_DISPCORR&#39;</span><span class="p">][</span><span class="n">good_mag</span><span class="p">],</span>
                                                    <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Set the number of bins measured, missing bins, and bin IDs</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> \
                                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">]</span>
        <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span> <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span> \
                                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">good_snr</span><span class="p">]</span>
        <span class="n">measurements_binid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">measure_on_unbinned_spaxels</span><span class="p">:</span>
            <span class="n">measurements_binid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">measurements_binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">good_snr</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the header keywords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="n">hardcopy</span>
        <span class="n">pri_hdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_primary_header</span><span class="p">(</span><span class="n">measurements_binid</span><span class="o">=</span><span class="n">measurements_binid</span><span class="p">)</span>
        <span class="n">map_hdr</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">build_map_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                               <span class="s1">&#39;K Westfall &lt;westfall@ucolick.org&gt;&#39;</span><span class="p">)</span>
        <span class="c1"># Get the spatial map mask</span>
        <span class="n">map_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>

        <span class="c1"># Account for measurements on individual spaxels</span>
        <span class="k">if</span> <span class="n">measurements_binid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add any spaxel not used because it was flagged by the</span>
            <span class="c1"># binning step</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
            <span class="c1"># Isolate any spaxels with foreground stars</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                       <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">)</span>
            <span class="c1"># Get the bins that were below the S/N limit</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                        <span class="n">good_snr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;LOW_SNR&#39;</span><span class="p">)</span>

            <span class="c1"># Get the bin ids with measured indices</span>
            <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">downselect_bins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                <span class="n">measurements</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume any model with a binid less than zero is from a</span>
            <span class="c1"># spaxel that was not used</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">measurements_binid</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">map_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

            <span class="c1"># The number of valid bins MUST match the number of</span>
            <span class="c1"># measurements</span>
            <span class="n">nvalid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">indx</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">nvalid</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">measurements</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided id does not match the number of measurements.&#39;</span><span class="p">)</span>

            <span class="c1"># Get the bin ids with fitted models</span>
            <span class="n">bin_indx</span> <span class="o">=</span> <span class="n">measurements_binid</span>

        <span class="c1"># Compile the information on the suite of measured indices</span>
        <span class="n">passband_database</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_database</span><span class="p">()</span>

        <span class="c1"># Save the data to the hdu attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">pri_hdr</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;BINID&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">map_mask</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">map_hdr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MAPMASK&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span> <span class="p">[</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                    <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">passband_database</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                            <span class="n">array</span><span class="o">=</span><span class="n">passband_database</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">passband_database</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="p">],</span>
                                                               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SIPAR&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span> <span class="p">[</span> <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                                    <span class="nb">format</span><span class="o">=</span><span class="n">rec_to_fits_type</span><span class="p">(</span><span class="n">measurements</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span>
                                <span class="n">array</span><span class="o">=</span><span class="n">measurements</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">measurements</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="p">],</span>
                                                               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SINDX&#39;</span><span class="p">)</span>
                                <span class="p">])</span>

        <span class="c1"># Write the data, if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices.write"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the hdu object to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralIndices.read"><a class="viewcode-back" href="../../../mangadap.proc.spectralindices.html#mangadap.proc.spectralindices.SpectralIndices.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read an existing file with a previously binned set of spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ifile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ifile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;File does not exist!: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ifile</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#        self.hdu = fits.open(ifile, checksum=checksum)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>

        <span class="c1"># Confirm that the internal method is the same as the method</span>
        <span class="c1"># that was used in writing the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SIKEY&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Keywords in header does not match specified method keyword!&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Keywords in header does not match specified method keyword!&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: &quot;strict&quot; should also check other aspects of the file to</span>
        <span class="c1"># make sure that the details of the method are also the same,</span>
        <span class="c1"># not just the keyword</span>

<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO, &#39;Reverting to python-native structure.&#39;)</span>
<span class="c1">#        DAPFitsUtil.restructure_map(self.hdu, ext=self.image_arrays)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;NBINS&#39;</span><span class="p">]</span>
        <span class="n">unique_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> \
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;SIREBIN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_missing_bins</span><span class="p">(</span><span class="n">unique_bins</span><span class="o">=</span><span class="n">unique_bins</span><span class="p">)</span></div></div>


</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>