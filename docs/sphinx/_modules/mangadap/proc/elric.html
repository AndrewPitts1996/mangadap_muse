

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.elric &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.elric</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.elric</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements an emission-line profile fitting class.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/elric.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import time</span>
<span class="sd">        import os</span>
<span class="sd">        import logging</span>

<span class="sd">        import numpy</span>
<span class="sd">        from scipy import interpolate, integrate, optimize</span>
<span class="sd">        from scipy.special import erf</span>
<span class="sd">        import astropy.constants</span>
<span class="sd">        from astropy.modeling import FittableModel, Parameter</span>

<span class="sd">        from ..par.parset import ParSet</span>
<span class="sd">        from ..par.emissionlinedb import EmissionLineDB</span>
<span class="sd">        from ..util.fileio import init_record_array</span>
<span class="sd">        from ..util.log import log_output</span>
<span class="sd">        from ..util.pixelmask import SpectralPixelMask</span>
<span class="sd">        from .spatiallybinnedspectra import SpatiallyBinnedSpectra</span>
<span class="sd">        from .stellarcontinuummodel import StellarContinuumModel</span>
<span class="sd">        from .spectralfitting import EmissionLineFit</span>
<span class="sd">        from .util import sample_growth</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">        Add examples</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **26 Apr 2016**: Original implementation by K. Westfall (KBW)</span>
<span class="sd">    | **13 Jul 2016**: (KBW) Include log_bounds determining whether or</span>
<span class="sd">        not a returned parameters is near its boundary.</span>
<span class="sd">    | **19 Jul 2016**: (KBW) Changed file name</span>
<span class="sd">    | **19 Oct 2016**: (KBW) Added</span>
<span class="sd">        :func:`Elric.reset_continuum_mask_window` function to deal with</span>
<span class="sd">        the subtraction of the continuum over the fully viable spectral</span>
<span class="sd">        range, and ignoring small spectral regions ignored during the</span>
<span class="sd">        stellar continuum fit.  Changed the initial creation of the</span>
<span class="sd">        continuum mask to include the emission line regions to avoid any</span>
<span class="sd">        polynomial extrapolation errors, in case the emission line</span>
<span class="sd">        happens to fall exactly at the edge of the valid spectral range.</span>
<span class="sd">    | **08 Nov 2016**: (KBW) Moved the</span>
<span class="sd">        :func:`StellarContinuumModel.reset_continuum_mask_window`</span>
<span class="sd">        function from :class:`Elric` to be a member of</span>
<span class="sd">        :class:`StellarContinuumModel`.</span>
<span class="sd">    | **24 May 2017**: (KBW) Moved _check_db to</span>
<span class="sd">        :func:`mangadap.proc.spectralfitting.EmissionLineFit.check_emission_line_database`</span>
<span class="sd">        and moved fill_equivalent_width to</span>
<span class="sd">        :func:`mangadap.proc.spectralfitting.EmissionLineFit.measure_equivalent_width`.</span>
<span class="sd">        Moved _per_fitting_window_dtype from EmissionLineFit to</span>
<span class="sd">        :class:`Elric`.</span>
<span class="sd">    | **24 Aug 2017**: (KBW) Use new</span>
<span class="sd">        :func:`mangadap.proc.util.sample_growth` instead of old</span>
<span class="sd">        residual_growth function.</span>
<span class="sd">    | **02 Feb 2018**: (KBW) Adjust for change to</span>
<span class="sd">        :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.fill_to_match`.</span>

<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _scipy.optimize.least_squares: http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html</span>
<span class="sd">.. _scipy.optimize.OptimizeResult: http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html</span>

<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _astropy.modeling.polynomial.Legendre1D: http://docs.astropy.org/en/stable/api/astropy.modeling.polynomial.Legendre1D.html</span>
<span class="sd">.. _astropy.modeling.models.CompoundModel: http://docs.astropy.org/en/stable/modeling/compound-models.html</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>
<span class="kn">from</span> <span class="nn">astropy.modeling.polynomial</span> <span class="k">import</span> <span class="n">Legendre1D</span>

<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..par.emissionlinedb</span> <span class="k">import</span> <span class="n">EmissionLineDB</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="k">import</span> <span class="n">lineprofiles</span>
<span class="kn">from</span> <span class="nn">.spatiallybinnedspectra</span> <span class="k">import</span> <span class="n">SpatiallyBinnedSpectra</span>
<span class="kn">from</span> <span class="nn">.stellarcontinuummodel</span> <span class="k">import</span> <span class="n">StellarContinuumModel</span>
<span class="kn">from</span> <span class="nn">.spectralfitting</span> <span class="k">import</span> <span class="n">EmissionLineFit</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">sample_growth</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<span class="c1"># Add strict versioning</span>
<span class="c1"># from distutils.version import StrictVersion</span>

<span class="c1"># Main fitting engine --------------------------------------------------</span>
<div class="viewcode-block" id="LineProfileFit"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit">[docs]</a><span class="k">class</span> <span class="nc">LineProfileFit</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simultaneously fit multiple line profiles.  Currently only allows</span>
<span class="sd">    one to fit using an NCompLineProfile object.  The fitting algorithm</span>
<span class="sd">    used is `scipy.optimize.least_squares`_ with fitting method &#39;trf&#39; to</span>
<span class="sd">    allow for bounds.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        For multicomponent lines, set the first normalization to be the</span>
<span class="sd">        normalization for the sum of all components, then force the</span>
<span class="sd">        normalization of the subcomponents to be ordered from highest to</span>
<span class="sd">        lowest and bounded from 0 to 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (1D array): Independent variable</span>
<span class="sd">        y (1D array): Dependent variable</span>
<span class="sd">        profile_list (list of or individual :class:`NCompLineProfile`):</span>
<span class="sd">            The profile(s) to fit to the dependent variable.</span>
<span class="sd">        base_order (int): (**Optional**) The order of the Legendre</span>
<span class="sd">            polynomial to include in the model for the baseline trend in</span>
<span class="sd">            y below the fitted line profile(s).</span>
<span class="sd">        error (1D array): (**Optional**) Error in the dependent</span>
<span class="sd">            variables.  If not provided, no error weighting is peformed</span>
<span class="sd">            during the fitting process, and the covariance *will not* be</span>
<span class="sd">            constructed.</span>
<span class="sd">        mask (1D array): (**Optional**) Boolean array used to ignore</span>
<span class="sd">            values in `y` during the fit.</span>
<span class="sd">        par (1D array): (**Optional**) Initial guess for model</span>
<span class="sd">            parameters.  The number of parameters much match the</span>
<span class="sd">            expectation based on the provided list of profiles and the</span>
<span class="sd">            order of the baseline polynomial.  If not provided, the</span>
<span class="sd">            parameters are initialized to 0.</span>
<span class="sd">        fixed (1D array): (**Optional**) Flags used to fix parameters</span>
<span class="sd">            during the fit.  The number of parameters much match the</span>
<span class="sd">            expectation based on the provided list of profiles and the</span>
<span class="sd">            order of the baseline polynomial.  If not provided, all</span>
<span class="sd">            parameters are freely fit.</span>
<span class="sd">        bounds (2-tuple): (**Optional**) Tuple with two array-like</span>
<span class="sd">            elements giving the upper and lower bound for each</span>
<span class="sd">            parameter.  The length of each array element must match the</span>
<span class="sd">            number of parameters.  For an unbounded problem, set</span>
<span class="sd">            ``bounds=None``, or use numpy.inf with an appropriate sign</span>
<span class="sd">            to disable bounds on all or some variables.</span>
<span class="sd">        run_fit (bool): (**Optional**) Flag to run the fit upon</span>
<span class="sd">            instantiation of the object, which defaults to True.  If set</span>
<span class="sd">            to False, the object is initialized but the fit is not</span>
<span class="sd">            executed, and can be executed later using :func:`fit`.</span>
<span class="sd">        construct_covariance (bool): (**Optional**) Flag to construct</span>
<span class="sd">            the covariance matrix based on the result object provided by</span>
<span class="sd">            `scipy.optimize.least_squares`_, which defaults to True.  If</span>
<span class="sd">            set to False, the covariance matrix is set to None.</span>
<span class="sd">        verbose (int): (**Optional**) Verbosity level for</span>
<span class="sd">            `scipy.optimize.least_squares`_; default is 0.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        x (numpy.ndarray): Independent variable of length :math:`M`.</span>
<span class="sd">        y (numpy.ndarray): Dependent variable to be fit of length</span>
<span class="sd">            :math:`M`.</span>
<span class="sd">        err (numpy.ndarray): Error, :math:`\sigma`, in the dependent</span>
<span class="sd">            variable of length :math:`M`.</span>
<span class="sd">        mask (numpy.ndarray): Flag to fit dependent variables of length</span>
<span class="sd">            :math:`M`.</span>
<span class="sd">        nlines (int): Number of lines being fit.</span>
<span class="sd">        base_order (int): The order of the Legendre polynomial include</span>
<span class="sd">            in the model; see `astropy.modeling.polynomial.Legendre1D`_.</span>
<span class="sd">        model (`astropy.modeling.models.CompoundModel`_): The compound</span>
<span class="sd">            model being fit composed of the line profiles and the</span>
<span class="sd">            baseline (if a baseline is being fit).  That is, this</span>
<span class="sd">            defines the function :math:`f(\mathbf{x}|\mathbf{\theta})`,</span>
<span class="sd">            where :math:`\mathbf{x}` is the dependent variable and</span>
<span class="sd">            :math:`\mathbf{\theta}` is the list of variables.  The</span>
<span class="sd">            fitting algorithm minimizes the (error-weighted) residuals</span>
<span class="sd">            to approximate :math:`y=f(\mathbf{x}|\mathbf{\theta})`.</span>
<span class="sd">        npar (int): Total number of parameters in the model.  The is the</span>
<span class="sd">            number of parameters per line and the number of parameters</span>
<span class="sd">            included in the baseline.</span>
<span class="sd">        nfitpar (int): Number of *free* parameters, defined as</span>
<span class="sd">            :math:`N`.</span>
<span class="sd">        par (numpy.ndarray): Full list of model parameters, including</span>
<span class="sd">            those parameters that have been fixed.</span>
<span class="sd">        fixed (numpy.ndarray): Flags to fit (False) or fix (True) a</span>
<span class="sd">            given parameter.</span>
<span class="sd">        bounds (2-tuple): Tuple with two array-like</span>
<span class="sd">            elements giving the upper and lower bound for each</span>
<span class="sd">            parameter.  For an unbounded problem, this is set to</span>
<span class="sd">            ``bounds=(-numpy.inf,numpy.inf)``.</span>
<span class="sd">        result (`scipy.optimize.OptimizeResult`_): Object with the</span>
<span class="sd">            results from `scipy.optimize.least_squares`_.  The</span>
<span class="sd">            best-fitting parameters, :math:`\mathbf{\theta}`, is</span>
<span class="sd">            returned as ``result.x``.</span>
<span class="sd">        cov (numpy.ndarray): The formal covariance matrix for the fit.</span>
<span class="sd">            The `scipy.optimize.OptimizeResult`_ object provides the</span>
<span class="sd">            Jacobian of the model, an :math:`M \times N` array with</span>
<span class="sd">            elements</span>

<span class="sd">            .. math::</span>

<span class="sd">                J_{ij} = \left.\frac{\partial f_i}{\partial</span>
<span class="sd">                \theta_j}\right|_{\mathbf{\theta}}</span>

<span class="sd">            at location in parameter space of the best-fitting model.</span>
<span class="sd">            This is used to construct the covariance matrix by taking</span>
<span class="sd">            the inverse of the curvature matrix:</span>

<span class="sd">            .. math::</span>

<span class="sd">                \mathbf{\alpha}_{kl} = \left[\frac{1}{\sigma_{i}}</span>
<span class="sd">                J_{ik}\right]^{\rm T} \left[\frac{1}{\sigma_{i}}</span>
<span class="sd">                J_{il}\right].</span>

<span class="sd">            That is, :math:`\mathbf{C} = \mathbf{\alpha}^{-1}`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: Raised if the provided profile objects are not</span>
<span class="sd">            instances of :class:`NCompLineProfile`.</span>
<span class="sd">        ValueError: Raised if any of the provided parameter arrays (par,</span>
<span class="sd">            fixed) are not one-dimensional or the number of parameters</span>
<span class="sd">            is not as expected based on the number of profile and</span>
<span class="sd">            baseline parameters.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Provide a better initialization for the parameters.</span>
<span class="sd">        - Need to provide the best-fitting parameters and errors as full</span>
<span class="sd">          vectors, including the fixed parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">profile_list</span><span class="p">,</span> <span class="n">base_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">construct_covariance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="c1"># Check the input list of profiles</span>
        <span class="n">_profile_list</span> <span class="o">=</span> <span class="n">profile_list</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">profile_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">profile_list</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_profile_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_profile_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lineprofiles</span><span class="o">.</span><span class="n">NCompLineProfile</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;LineProfileFit only works with NCompLineProfile objects.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct and check the parameter vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="n">p</span><span class="o">.</span><span class="n">npar</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_profile_list</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">base_order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">base_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npar</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input parameter array should only be one-dimensional.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixed</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">par</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input parameter and fixed flags should have the same shape.&#39;</span><span class="p">)</span>
        <span class="n">_par</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">par</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_par</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of parameters provided&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="n">_par</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_par</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="n">fixed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fixed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bounds must have type tuple.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bounds must only have two elements.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lower and/or upper bounds have an incorrect number of parameters.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounded</span> <span class="o">=</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bounds</span>

        <span class="c1"># Get the number of free parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfitpar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">))</span>

        <span class="c1"># Construct the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">_profile_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">profile</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">+=</span> <span class="n">_profile_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">+=</span> <span class="n">Legendre1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_order</span><span class="p">)</span>
        <span class="c1"># Fix the parameters</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">fixed</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1">#        print(self.model)</span>

        <span class="c1"># Need to setup how to tie fluxes, velocities, dispersions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">run_fit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">construct_covariance</span><span class="o">=</span><span class="n">construct_covariance</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>


<div class="viewcode-block" id="LineProfileFit._assign_par"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit._assign_par">[docs]</a>    <span class="k">def</span> <span class="nf">_assign_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fixed parameters are ignored!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfitpar</span> <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of parameters provided&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">)]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">)]</span> \
                                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span> <span class="k">else</span> <span class="n">par</span></div>
        <span class="c1"># Then tie parameters...</span>

        
<div class="viewcode-block" id="LineProfileFit._chi"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit._chi">[docs]</a>    <span class="k">def</span> <span class="nf">_chi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span><span class="p">(</span><span class="n">par</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">err</span></div>


<div class="viewcode-block" id="LineProfileFit._resid"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit._resid">[docs]</a>    <span class="k">def</span> <span class="nf">_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_par</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="n">ymodel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quick_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="n">ymodel</span><span class="p">)</span></div>


<div class="viewcode-block" id="LineProfileFit._calculate_covariance_matrix"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit._calculate_covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cannot calculate covariance matrix without error vector!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
<span class="c1">#        invsig = numpy.array([numpy.ma.power(self.err,-1.)]*self.result.jac.shape[1]).T</span>
<span class="c1">#        a = (invsig.ravel()*self.result.jac.ravel()).reshape(self.result.jac.shape)</span>
<span class="c1">#        a = numpy.dot(a.T,a)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">jac</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Curvature:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="LineProfileFit._quick_sample"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit._quick_sample">[docs]</a>    <span class="k">def</span> <span class="nf">_quick_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample without providing/checking new input parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(*self.par.ravel())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span></div>


<div class="viewcode-block" id="LineProfileFit.sample"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assign_par</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quick_sample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="LineProfileFit.fit"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.LineProfileFit.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">construct_covariance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the line profiles provided upon initialization to the data</span>
<span class="sd">        using `scipy.optimize.least_squares`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the lengths of all the arrays match</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only fit single spectra!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">error</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All vector shapes must be identical.&#39;</span><span class="p">)</span>

        <span class="c1"># If the input is a masked array, combine the two masks; the</span>
        <span class="c1"># first line below works for both normal numpy.ndarrays and</span>
        <span class="c1"># MaskedArray</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">|=</span> <span class="n">mask</span>

        <span class="c1"># Set the internal vectors to be numpy.ndarrays that only include the unmasked values</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Insufficient data points (</span><span class="si">{0}</span><span class="s1">) to fit with this function &#39;</span> \
                             <span class="s1">&#39;(npar=</span><span class="si">{1}</span><span class="s1">)!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar</span><span class="p">))</span>

<span class="c1">#        print(&#39;Initial guess parameters inside LineProfileFit:&#39;)</span>
<span class="c1">#        print(self.par)</span>
<span class="c1">#        print(self.bounds)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resid</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chi</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="s1">&#39;2-point&#39;</span><span class="p">,</span>
                                                 <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trf&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ValueError: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">OptimizeResult</span><span class="p">(</span><span class="n">success</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>

<span class="c1">#        try:</span>
<span class="c1">#            self.result = optimize.least_squares(self._resid if self.err is None else self._chi,</span>
<span class="c1">#                                                 self.par, bounds=self.bounds, jac=&#39;2-point&#39;,</span>
<span class="c1">#                                                 #method=&#39;lm&#39;, loss=&#39;linear&#39;, verbose=1)</span>
<span class="c1">#                                                 method=&#39;trf&#39;, loss=&#39;linear&#39;, verbose=2)</span>
<span class="c1">#        except:</span>
<span class="c1">#            exc_info = sys.exc_info()</span>
<span class="c1">#            warnings.warn(&#39;Error during fit: {0}:: {1}&#39;.format(exc_info[0], exc_info[1]))</span>
<span class="c1">#            self.result = OptimizeResult(x=self.par, cost=None, fun=None, jac=None, grad=None,</span>
<span class="c1">#                                         optimality=None, active_mask=None, nfev=None, njev=None,</span>
<span class="c1">#                                         status=None, success=False)</span>
<span class="c1">#            return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">construct_covariance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_covariance_matrix</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result: &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance: &#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ElricPar"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricPar">[docs]</a><span class="k">class</span> <span class="nc">ElricPar</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">base_order</span><span class="p">,</span> <span class="n">window_buffer</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">,</span>
                 <span class="n">minimum_snr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">arr_in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;emission_lines&#39;</span><span class="p">,</span> <span class="s1">&#39;base_order&#39;</span><span class="p">,</span> <span class="s1">&#39;window_buffer&#39;</span><span class="p">,</span> <span class="s1">&#39;guess_redshift&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;guess_dispersion&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;pixelmask&#39;</span><span class="p">,</span> <span class="s1">&#39;stellar_continuum&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">base_order</span><span class="p">,</span> <span class="n">window_buffer</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">,</span>
                     <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">pixelmask</span><span class="p">,</span> <span class="n">stellar_continuum</span> <span class="p">]</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>   <span class="mf">25.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">EmissionLineDB</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="n">SpectralPixelMask</span><span class="p">,</span>
                     <span class="n">StellarContinuumModel</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span>


<div class="viewcode-block" id="ElricPar.toheader"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricPar.toheader">[docs]</a>    <span class="k">def</span> <span class="nf">toheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;LPBASEO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;base_order&#39;</span><span class="p">],</span> <span class="s1">&#39;Baseline Legendre polynomial order&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;LPWIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;window_buffer&#39;</span><span class="p">],</span> <span class="s1">&#39;Buffer for fitting window (ang)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="ElricPar.fromheader"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricPar.fromheader">[docs]</a>    <span class="k">def</span> <span class="nf">fromheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;base_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;LPBASEO&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;window_buffer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;LPWIN&#39;</span><span class="p">]</span></div></div>



<div class="viewcode-block" id="TiedLineProfile"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.TiedLineProfile">[docs]</a><span class="k">class</span> <span class="nc">TiedLineProfile</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">base_profile</span><span class="p">,</span> <span class="n">relative_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mean_separation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_stddev</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_profile</span> <span class="o">=</span> <span class="n">base_profile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_flux</span> <span class="o">=</span> <span class="n">relative_flux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_separation</span> <span class="o">=</span> <span class="n">mean_separation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_stddev</span> <span class="o">=</span> <span class="n">relative_stddev</span>


<div class="viewcode-block" id="TiedLineProfile.tie_flux"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.TiedLineProfile.tie_flux">[docs]</a>    <span class="k">def</span> <span class="nf">tie_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">set_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_flux</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">base_profile</span><span class="o">.</span><span class="n">flux</span><span class="p">())</span></div>


<div class="viewcode-block" id="TiedLineProfile.tie_mean"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.TiedLineProfile.tie_mean">[docs]</a>    <span class="k">def</span> <span class="nf">tie_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">set_mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_profile</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">velocity_separation</span><span class="p">)</span></div>


<div class="viewcode-block" id="TiedLineProfile.tie_stddev"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.TiedLineProfile.tie_stddev">[docs]</a>    <span class="k">def</span> <span class="nf">tie_stddev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">set_stddev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_stddev</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">base_profile</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ElricFittingWindow"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricFittingWindow">[docs]</a><span class="k">class</span> <span class="nc">ElricFittingWindow</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    A utility class for the fitting windows used by Elric</span>

<span class="sd">    The class can be instantiated as fully None.</span>

<span class="sd">    Args:</span>
<span class="sd">        nlines (int): (**Optional**) The number of lines to be fit</span>
<span class="sd">            simultaneously.</span>
<span class="sd">        db_indx (numpy.ndarray): (**Optional**) An array with the</span>
<span class="sd">            database index (0-based) of each line to be fit.</span>
<span class="sd">        line_index (numpy.ndarray): (**Optional**) An array with the</span>
<span class="sd">            index numbers, read from the database, of each line to be</span>
<span class="sd">            fit.</span>
<span class="sd">        restwave (numpy.ndarray): (**Optional**) An array with the rest</span>
<span class="sd">            wavelengths of each line to be fit.</span>
<span class="sd">        profile_set (numpy.ndarray): (**Optional**) An array with the</span>
<span class="sd">            profile objects that define the functional form of each</span>
<span class="sd">            line.</span>
<span class="sd">        fixed_par (numpy.ndarray): (**Optional**) An array with the</span>
<span class="sd">            fixed parameters for *all* parameters in the model to be</span>
<span class="sd">            fit.</span>
<span class="sd">        bounds (numpy.ndarray): (**Optional**) A two-column array with</span>
<span class="sd">            the lower (first column) and upper (second column) bounds</span>
<span class="sd">            for the fit parameters.</span>
<span class="sd">        log_bounds (numpy.ndarray): (**Optional**) The range of the</span>
<span class="sd">            boundary should be considered as logarithmic when testing if</span>
<span class="sd">            a parameter is near its boundary.</span>
<span class="sd">        output_model (bool): (**Optional**) Include the best-fitting</span>
<span class="sd">            model in the composite emission-line model for each</span>
<span class="sd">            spectrum.  This is only flagged as true if ALL the emission</span>
<span class="sd">            lines in the fitting window are to be included according to</span>
<span class="sd">            the emission-line database.</span>
<span class="sd">        tied_pairs (numpy.ndarray): (**Optional**) The series of</span>
<span class="sd">            tied profiles (:class:`TiedLineProfile` objects) that are</span>
<span class="sd">            used to tie parameters of the model.</span>
<span class="sd">        tied_funcs (numpy.ndarray): (**Optional**) The member functions</span>
<span class="sd">            of the :class:`TiedLineProfile` objects that should be</span>
<span class="sd">            called *sequentially* to tie model parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">db_indx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">restwave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">profile_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixed_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tied_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tied_funcs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nlines</span> <span class="o">=</span> <span class="n">nlines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_indx</span> <span class="o">=</span> <span class="n">db_indx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_index</span> <span class="o">=</span> <span class="n">line_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restwave</span> <span class="o">=</span> <span class="n">restwave</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span> <span class="o">=</span> <span class="n">profile_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">p</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_par</span> <span class="o">=</span> <span class="n">fixed_par</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_bounds</span> <span class="o">=</span> <span class="n">log_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_model</span> <span class="o">=</span> <span class="n">output_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied_pairs</span> <span class="o">=</span> <span class="n">tied_pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied_funcs</span> <span class="o">=</span> <span class="n">tied_funcs</span>


<div class="viewcode-block" id="ElricFittingWindow.append"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricFittingWindow.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_indx</span><span class="p">,</span> <span class="n">line_index</span><span class="p">,</span> <span class="n">restwave</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">fixed_par</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">log_bounds</span><span class="p">,</span>
               <span class="n">output_model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append another line to the fitting window.  Must be a single line!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that input is for a single line</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_indx</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended index must be a single integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">restwave</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended restwavelength must be a single float.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">lineprofiles</span><span class="o">.</span><span class="n">NCompLineProfile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended profile must have type NCompLineProfile.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_par</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_par</span><span class="p">)</span> <span class="o">!=</span> <span class="n">profile</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended fixed parameter must be a vector with the correct length.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">profile</span><span class="o">.</span><span class="n">npar</span> <span class="ow">or</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended bounds must have shape: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">npar</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">profile</span><span class="o">.</span><span class="n">npar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Appended log_bounds parameter must be a vector of the correct length.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_model</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Flag to output model must be boolean.&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nlines</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_indx</span><span class="p">,</span> <span class="n">db_indx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span> <span class="n">line_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restwave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">restwave</span><span class="p">,</span> <span class="n">restwave</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_par</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_par</span><span class="p">,</span> <span class="n">fixed_par</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_bounds</span><span class="p">,</span> <span class="n">log_bounds</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                       <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_model</span> <span class="o">&amp;=</span> <span class="n">output_model</span></div>


<div class="viewcode-block" id="ElricFittingWindow.reset_init_mean"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricFittingWindow.reset_init_mean">[docs]</a>    <span class="k">def</span> <span class="nf">reset_init_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">newmean</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">set_mean</span><span class="p">(</span><span class="n">newmean</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_par</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">par</span></div>


<div class="viewcode-block" id="ElricFittingWindow.reinit_profiles"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.ElricFittingWindow.reinit_profiles">[docs]</a>    <span class="k">def</span> <span class="nf">reinit_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">assign_par</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span></div></div>


<div class="viewcode-block" id="Elric"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric">[docs]</a><span class="k">class</span> <span class="nc">Elric</span><span class="p">(</span><span class="n">EmissionLineFit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ELRIC: Emission-Line Regression and Inference Class</span>

<span class="sd">    https://en.wikipedia.org/wiki/Edward_Elric</span>

<span class="sd">    Use LineProfileFit to fit the emission-line properties in a set of</span>
<span class="sd">    spectra.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Implement some scheme to penalize multicomponent fits at low S/N</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">wave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emission_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">stellar_continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_order</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_buffer</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">guess_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_dispersion</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">run_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;elric&#39;</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">)</span>
        <span class="c1"># Attributes kept by SpectralFitting:</span>
        <span class="c1">#   fit_type=&#39;emission_line&#39;, bitmask=bitmask, par=None</span>
        <span class="c1"># Attributes kept by EmissionLineFit:</span>
        <span class="c1">#   fit_method=&#39;elric&#39;</span>

        <span class="c1"># Declare the attributes kept for convenience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_dispersion</span> <span class="o">=</span> <span class="n">default_dispersion</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="o">=</span><span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxnc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_buffer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">run_fit</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">wave</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">emission_lines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot run fit without wavelength and flux vectors, and &#39;</span> \
                             <span class="s1">&#39;emission-line database.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                 <span class="n">stellar_continuum</span><span class="o">=</span><span class="n">stellar_continuum</span><span class="p">,</span> <span class="n">base_order</span><span class="o">=</span><span class="n">base_order</span><span class="p">,</span>
                 <span class="n">window_buffer</span><span class="o">=</span><span class="n">window_buffer</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="o">=</span><span class="n">guess_redshift</span><span class="p">,</span>
                 <span class="n">guess_dispersion</span><span class="o">=</span><span class="n">guess_dispersion</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


<div class="viewcode-block" id="Elric._per_fitting_window_dtype"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._per_fitting_window_dtype">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_per_fitting_window_dtype</span><span class="p">(</span><span class="n">nwin</span><span class="p">,</span> <span class="n">max_npar</span><span class="p">,</span> <span class="n">mask_dtype</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the record array data type for the output fits</span>
<span class="sd">        extension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;BINID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">mask_dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;PAR&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;ERR&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;LOBND&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;UPBND&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;FIXED&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
<span class="c1">#                 (&#39;TIED&#39;,numpy.int,(nwin,max_npar)),</span>
                 <span class="p">(</span><span class="s1">&#39;IGNORE&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="n">max_npar</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;CHI2&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;RCHI2&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;RMS&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;RESID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="mi">7</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;FRAC_RMS&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;FRAC_RESID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nwin</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span>
               <span class="p">]</span></div>


<div class="viewcode-block" id="Elric._find_tied_index"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._find_tied_index">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_tied_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Line indices are not unique!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span>
        <span class="n">tied</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tied</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Line indices are not unique!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tied</span><span class="p">)</span> <span class="k">if</span> <span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> \
                    <span class="k">else</span> <span class="n">Elric</span><span class="o">.</span><span class="n">_find_tied_index</span><span class="p">(</span><span class="n">tied</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Elric._set_profile_ties"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._set_profile_ties">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_profile_ties</span><span class="p">(</span><span class="n">base_profiles</span><span class="p">,</span> <span class="n">base_restwave</span><span class="p">,</span> <span class="n">base_fixed_par</span><span class="p">,</span> <span class="n">tied_profiles</span><span class="p">,</span>
                          <span class="n">tied_restwave</span><span class="p">,</span> <span class="n">tied_fixed_par</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
        <span class="n">nprof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_profiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_restwave</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprof</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">tied_profiles</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprof</span> \
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">tied_restwave</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprof</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprof</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nprof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide same length arrays to _tied_funcs.&#39;</span><span class="p">)</span>
        
        <span class="n">tied_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tied_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprof</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="k">continue</span> 
            <span class="n">tied_pars</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">TiedLineProfile</span><span class="p">(</span><span class="n">tied_profiles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">base_profiles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">]</span>
            <span class="n">tied_fixed_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">|=</span> <span class="n">base_fixed_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span> <span class="p">]:</span>
                <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relative_flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">tied_functions</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tie_flux</span> <span class="p">]</span>
                <span class="n">tied_fixed_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">|=</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">fix_flux</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span> <span class="p">]:</span>
                <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean_separation</span> \
                    <span class="o">=</span> <span class="p">(</span><span class="n">tied_restwave</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">base_restwave</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">tied_functions</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tie_mean</span> <span class="p">]</span>
                <span class="n">tied_fixed_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">|=</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">fix_mean</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span> <span class="p">]:</span>
                <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relative_stddev</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">tied_functions</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tie_stddev</span> <span class="p">]</span>
                <span class="n">tied_fixed_par</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">|=</span> <span class="n">tied_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">fix_stddev</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tied_pairs</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tied_functions</span><span class="p">),</span> <span class="n">tied_fixed_par</span></div>


<div class="viewcode-block" id="Elric._line_velocity_offset"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._line_velocity_offset">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_line_velocity_offset</span><span class="p">(</span><span class="n">restwave</span><span class="p">,</span> <span class="n">restwave_primary</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">restwave</span><span class="o">/</span><span class="n">restwave_primary</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="Elric._parse_emission_line_models"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._parse_emission_line_models">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_emission_line_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parse the input emission-line file into a set of windows --- the</span>
<span class="sd">        number of windows is :math:`N_{\rm win}`) --- that are fit for</span>
<span class="sd">        each spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Setup the number of windows to fit based on the primary lines</span>
        <span class="n">primary_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span>
        <span class="n">primary_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">primary_line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission lines to fit: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of fitting windows: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">))</span>

        <span class="c1"># Set up the primary line data using the guess parameters from</span>
        <span class="c1"># the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">_db_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">)[</span><span class="n">primary_line</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">):</span>

            <span class="n">db_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_db_indx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">line_index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">primary_index</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">restwave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">])</span>
            <span class="n">profile_set</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">lineprofiles</span><span class="o">.</span><span class="n">NCompLineProfile</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;ncomp&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">par</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;par&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">profile</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;lineprofiles.&#39;</span>
                                            <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span> <span class="p">])</span>
            <span class="n">fixed_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;fix&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">u</span><span class="p">]</span> \
                                    <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;lobnd&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;hibnd&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                                 <span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">log_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;log_bnd&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">output_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;output_model&#39;</span><span class="p">][</span><span class="n">primary_line</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ElricFittingWindow</span><span class="p">(</span><span class="n">nlines</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">db_indx</span><span class="o">=</span><span class="n">db_indx</span><span class="p">,</span>
                                                        <span class="n">line_index</span><span class="o">=</span><span class="n">line_index</span><span class="p">,</span> <span class="n">restwave</span><span class="o">=</span><span class="n">restwave</span><span class="p">,</span>
                                                        <span class="n">profile_set</span><span class="o">=</span><span class="n">profile_set</span><span class="p">,</span>
                                                        <span class="n">fixed_par</span><span class="o">=</span><span class="n">fixed_par</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                                        <span class="n">log_bounds</span><span class="o">=</span><span class="n">log_bounds</span><span class="p">,</span>
                                                        <span class="n">output_model</span><span class="o">=</span><span class="n">output_model</span><span class="p">)</span>

        <span class="c1"># Return if nothing is tied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Append additional profiles</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">primary_line</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># Basic check</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot tie line to itself!&#39;</span><span class="p">)</span>

            <span class="c1"># Run up the depenency chain to find the primary line</span>
            <span class="c1"># associated with this one</span>
            <span class="n">indx</span><span class="p">,</span> <span class="n">tied_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_tied_index</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">)</span>
            <span class="n">base_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">primary_index</span> <span class="o">==</span> <span class="n">tied_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Append the line to this fitting window</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">base_indx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">],</span>
                                                  <span class="n">lineprofiles</span><span class="o">.</span><span class="n">NCompLineProfile</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;ncomp&#39;</span><span class="p">],</span>
                                                                                <span class="n">par</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;par&#39;</span><span class="p">],</span>
                                                                   <span class="n">profile</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;lineprofiles.&#39;</span>
                                                                                <span class="o">+</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">])),</span>
                                                  <span class="n">e</span><span class="p">[</span><span class="s1">&#39;fix&#39;</span><span class="p">],</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;lobnd&#39;</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;hibnd&#39;</span><span class="p">])</span> <span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                                                  <span class="n">e</span><span class="p">[</span><span class="s1">&#39;log_bnd&#39;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;output_model&#39;</span><span class="p">]))</span>
            <span class="c1"># Set the guess velocity of the profile based on the</span>
            <span class="c1"># velocity relative to the main line</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">base_indx</span><span class="p">]</span><span class="o">.</span><span class="n">reset_init_mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_line_velocity_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">base_indx</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">base_indx</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Finalize by setting up any tied parameters</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Basic debug check</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;DEBUG&#39;</span><span class="p">)</span>

            <span class="c1"># The order is important.  Start with the primary line:</span>
            <span class="n">tied</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">tied</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>              <span class="c1"># Primary line already &quot;tied&quot; to the set</span>
            <span class="c1"># Iterate until all lines are tied</span>
            <span class="k">while</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tied</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span><span class="p">:</span>
                <span class="c1"># Find the indices of lines that are directly tied to</span>
                <span class="c1"># any previously tied lines.  At the beginning, this</span>
                <span class="c1"># only selects lines that are tied to the primary line.</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">([</span>
                            <span class="ow">not</span> <span class="n">tied</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> \
                                            <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">line_index</span><span class="p">[</span><span class="n">tied</span><span class="p">])</span> \
                            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[:]])</span>
                                   <span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># For these lines, find the indices in the list of lines</span>
                <span class="c1"># for this window with their associated lines to tie to</span>
                <span class="n">tied_indx</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[</span><span class="n">indx</span><span class="p">]]]</span>
                <span class="n">profile_indx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">line_index</span><span class="p">[:])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> \
                                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tied_indx</span> <span class="p">]</span>

                <span class="c1"># Run the maing function that sets up the seried of</span>
                <span class="c1"># tying classes/functions and updates the parameters</span>
                <span class="c1"># that should be &quot;fixed&quot; during the fit.</span>
                <span class="n">_tied_pairs</span><span class="p">,</span> <span class="n">_tied_funcs</span><span class="p">,</span> <span class="n">_fixed_par</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_profile_ties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">profile_indx</span><span class="p">],</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="n">profile_indx</span><span class="p">],</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fixed_par</span><span class="p">,</span> <span class="n">profile_indx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fixed_par</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[</span><span class="n">indx</span><span class="p">]],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[</span><span class="n">indx</span><span class="p">]])</span>

                <span class="c1"># Add these to the main output</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tied_pairs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tied_pairs</span><span class="p">,</span>
                                                                 <span class="n">_tied_pairs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tied_funcs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tied_funcs</span><span class="p">,</span>
                                                                 <span class="n">_tied_funcs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fixed_par</span><span class="p">[</span><span class="n">jj</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">_fixed_par</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>

                <span class="c1"># These lines are now tied!</span>
                <span class="n">tied</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Elric._velocity_vectors"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._velocity_vectors">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_velocity_vectors</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">fitting_window</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">(</span><span class="n">wave</span><span class="o">/</span><span class="n">fw</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> \
                            <span class="k">for</span> <span class="n">fw</span> <span class="ow">in</span> <span class="n">fitting_window</span> <span class="p">])</span></div>


<div class="viewcode-block" id="Elric._fit_masks"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._fit_masks">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fit_masks</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">fitting_window</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">window_buffer</span><span class="p">):</span>

        <span class="c1"># Input redshift must be a single value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;redshift must be a single float&#39;</span><span class="p">)</span>

        <span class="n">nwindows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitting_window</span><span class="p">)</span>
        <span class="n">fitting_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                        <span class="n">wave</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fw</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">window_buffer</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">redshift</span><span class="p">),</span>
                                        <span class="n">wave</span><span class="o">&lt;</span><span class="p">(</span><span class="n">fw</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">window_buffer</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">redshift</span><span class="p">))</span> \
                                     <span class="k">for</span> <span class="n">fw</span> <span class="ow">in</span> <span class="n">fitting_window</span> <span class="p">])</span>
<span class="c1">#        print(fitting_mask.shape)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwindows</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fitting_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">|=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                                        <span class="n">wave</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rw</span><span class="o">-</span><span class="n">window_buffer</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">redshift</span><span class="p">),</span>
                                                        <span class="n">wave</span><span class="o">&lt;</span><span class="p">(</span><span class="n">rw</span><span class="o">+</span><span class="n">window_buffer</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">redshift</span><span class="p">))</span> \
                                                <span class="k">for</span> <span class="n">rw</span> <span class="ow">in</span> <span class="n">fitting_window</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span> <span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fitting_mask</span></div>


<span class="c1">#    @staticmethod</span>
<span class="c1">#    def _check_db(emission_lines):</span>
<span class="c1">#</span>
<span class="c1">#        # Check the input type</span>
<span class="c1">#        if not isinstance(emission_lines, EmissionLineDB):</span>
<span class="c1">#            raise TypeError(&#39;Input database must have type EmissionLineDB.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#        # Check the database itself</span>
<span class="c1">#        neml = emission_lines.nsets</span>
<span class="c1">#        for i in range(neml):</span>
<span class="c1">#            profile = eval(emission_lines[&#39;profile&#39;][i])</span>
<span class="c1">#            npar = len(profile.param_names)</span>
<span class="c1">#            if emission_lines[&#39;par&#39;][i].size != npar*emission_lines[&#39;ncomp&#39;][i]:</span>
<span class="c1">#                raise ValueError(&#39;Provided {0} parameters, but expected {1}.&#39;.format(</span>
<span class="c1">#                                  emission_lines[&#39;par&#39;][i].size, npar*emission_lines[&#39;ncomp&#39;][i]))</span>
<span class="c1">#            if emission_lines[&#39;fix&#39;][i].size != npar*emission_lines[&#39;ncomp&#39;][i]:</span>
<span class="c1">#                raise ValueError(&#39;Provided {0} fix flags, but expected {1}.&#39;.format(</span>
<span class="c1">#                                  emission_lines[&#39;fix&#39;][i].size, npar*emission_lines[&#39;ncomp&#39;][i]))</span>
<span class="c1">#            if numpy.any([f not in [0, 1] for f in emission_lines[&#39;fix&#39;][i] ]):</span>
<span class="c1">#                warnings.warn(&#39;Fix values should only be 0 or 1; non-zero values interpreted as 1.&#39;)</span>
<span class="c1">#            if emission_lines[&#39;lobnd&#39;][i].size != npar*emission_lines[&#39;ncomp&#39;][i]:</span>
<span class="c1">#                raise ValueError(&#39;Provided {0} lower bounds, but expected {1}.&#39;.format(</span>
<span class="c1">#                                  emission_lines[&#39;lobnd&#39;][i].size,</span>
<span class="c1">#                                  npar*emission_lines[&#39;ncomp&#39;][i]))</span>
<span class="c1">#            if emission_lines[&#39;hibnd&#39;][i].size != npar*emission_lines[&#39;ncomp&#39;][i]:</span>
<span class="c1">#                raise ValueError(&#39;Provided {0} upper bounds, but expected {1}.&#39;.format(</span>
<span class="c1">#                                  emission_lines[&#39;hibnd&#39;][i].size,</span>
<span class="c1">#                                  npar*emission_lines[&#39;ncomp&#39;][i]))</span>
<span class="c1">#            if emission_lines[&#39;log_bnd&#39;][i].size != npar*emission_lines[&#39;ncomp&#39;][i]:</span>
<span class="c1">#                raise ValueError(&#39;Provided {0} log boundaries designations, but expected &#39;</span>
<span class="c1">#                                 &#39;{1}.&#39;.format(emission_lines[&#39;log_bnd&#39;][i].size,</span>
<span class="c1">#                                               npar*emission_lines[&#39;ncomp&#39;][i]))</span>


<div class="viewcode-block" id="Elric._is_near_bound"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._is_near_bound">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_near_bound</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">lbnd</span><span class="p">,</span> <span class="n">ubnd</span><span class="p">,</span> <span class="n">logbounded</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine of any of the parameters within start and start+npar</span>
<span class="sd">        are &quot;near&quot; an imposed boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        print(&#39;par: &#39;, par)</span>
<span class="c1">#        print(&#39;lbnd: &#39;, lbnd)</span>
        <span class="n">lbounded</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">lbnd</span><span class="p">))</span>
<span class="c1">#        print(&#39;L bounded: &#39;, lbounded)</span>

<span class="c1">#        print(&#39;ubnd: &#39;, ubnd)</span>
        <span class="n">ubounded</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ubnd</span><span class="p">))</span>
<span class="c1">#        print(&#39;U bounded: &#39;, ubounded)</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lbounded</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ubounded</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#            print(&#39;No bounds&#39;)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lbounded</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">ubounded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">par</span> <span class="o">-</span> <span class="n">lbnd</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">)):</span>
<span class="c1">#            print(&#39;Near lower bound&#39;)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">lbounded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ubounded</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubnd</span> <span class="o">-</span> <span class="n">par</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">)):</span>
<span class="c1">#            print(&#39;Near upper bound&#39;)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">ulbounded</span> <span class="o">=</span> <span class="n">lbounded</span> <span class="o">&amp;</span> <span class="n">ubounded</span>
<span class="c1">#        print(&#39;UL bounded&#39;, ulbounded)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ulbounded</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#            print(&#39;None bounded from both sides&#39;)</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="c1">#        print(&#39;log bounded&#39;, logbounded)</span>
<span class="c1">#        print(&#39;UL &amp; log bounded&#39;, ulbounded &amp; logbounded)</span>
<span class="c1">#        print(&#39;UL &amp; not log bounded&#39;, ulbounded &amp; ~logbounded)</span>
        <span class="n">Dp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ulbounded</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">ulbounded</span> <span class="o">&amp;</span> <span class="n">logbounded</span>
        <span class="n">Dp</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ubnd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lbnd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">ulbounded</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">logbounded</span><span class="p">)</span>
        <span class="n">Dp</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ubnd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">-</span> <span class="n">lbnd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">Dp</span><span class="o">*</span><span class="n">rtol</span>
<span class="c1">#        print(tol)</span>
<span class="c1">#        print(tol[ulbounded &amp; logbounded])</span>
<span class="c1">#        print((numpy.ma.log10(par) - numpy.ma.log10(lbnd))[ulbounded &amp; logbounded])</span>
<span class="c1">#        print((numpy.ma.log10(ubnd) - numpy.ma.log10(par))[ulbounded &amp; logbounded])</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">ulbounded</span> <span class="o">&amp;</span> <span class="n">logbounded</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lbnd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span> 
                                        <span class="o">|</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ubnd</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">))):</span>
<span class="c1">#            print(&#39;Near boundary in log&#39;)</span>
            <span class="k">return</span> <span class="kc">True</span>
                            
<span class="c1">#        print(tol[ulbounded &amp; ~logbounded])</span>
<span class="c1">#        print((par - lbnd)[ulbounded &amp; ~logbounded])</span>
<span class="c1">#        print((ubnd - par)[ulbounded &amp; ~logbounded])</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ulbounded</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">logbounded</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">par</span><span class="o">-</span><span class="n">lbnd</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ubnd</span><span class="o">-</span><span class="n">par</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">))):</span>
<span class="c1">#            print(&#39;Near boundary in linear&#39;)</span>
            <span class="k">return</span> <span class="kc">True</span>
<span class="c1">#        print(&#39;Not near boundary&#39;)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1">#        # Check if the parameters are near a boundary</span>
<span class="c1">#        if self.bestfit[i,j].bounded:</span>
<span class="c1">#            model_fit_par[&#39;LOBND&#39;][i,j,:npar] = self.bestfit[i,j].bounds[0]</span>
<span class="c1">#            model_fit_par[&#39;UPBND&#39;][i,j,:npar] = self.bestfit[i,j].bounds[1]</span>
<span class="c1">#            for k in range(npar):</span>
<span class="c1">#                if not numpy.isinf(self.bestfit[i,j].bounds[0][k]) \</span>
<span class="c1">#                        and model_fit_par[&#39;PAR&#39;][i,j,k] - model_fit_par[&#39;ERR&#39;][i,j,k] \</span>
<span class="c1">#                                    &lt;= self.bestfit[i,j].bounds[0][k]:</span>
<span class="c1">#                    near_bound = True</span>
<span class="c1">#                    break</span>
<span class="c1">#                if not numpy.isinf(self.bestfit[i,j].bounds[1][k]) \</span>
<span class="c1">#                        and model_fit_par[&#39;PAR&#39;][i,j,k] + model_fit_par[&#39;ERR&#39;][i,j,k] \</span>
<span class="c1">#                                    &gt;= self.bestfit[i,j].bounds[1][k]:</span>
<span class="c1">#                    near_bound = True</span>
<span class="c1">#                    break</span>

<span class="c1">#            if self.bestfit[i,j].bounded:</span>
<span class="c1">#                if numpy.any(~numpy.isinf(self.bestfit[i,j].bounds[0][pl:pl+nlinepar[k]]) \</span>
<span class="c1">#                                &amp; (model_fit_par[&#39;PAR&#39;][i,j,pl:pl+nlinepar[k]]</span>
<span class="c1">#                                    - model_fit_par[&#39;ERR&#39;][i,j,pl:pl+nlinepar[k]]</span>
<span class="c1">#                                    &lt;= self.bestfit[i,j].bounds[0][pl:pl+nlinepar[k]])):</span>
<span class="c1">#                    model_eml_par[&#39;MASK&#39;][i,emlj] \</span>
<span class="c1">#                            = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][i,emlj], &#39;NEAR_BOUND&#39;)</span>
<span class="c1">#                    near_bound = True</span>
<span class="c1">#                if numpy.any(~numpy.isinf(self.bestfit[i,j].bounds[1][pl:pl+nlinepar[k]]) \</span>
<span class="c1">#                                &amp; (model_fit_par[&#39;PAR&#39;][i,j,pl:pl+nlinepar[k]]</span>
<span class="c1">#                                    + model_fit_par[&#39;ERR&#39;][i,j,pl:pl+nlinepar[k]] \</span>
<span class="c1">#                                    &gt;= self.bestfit[i,j].bounds[1][pl:pl+nlinepar[k]])):</span>
<span class="c1">#                    model_eml_par[&#39;MASK&#39;][i,emlj] \</span>
<span class="c1">#                            = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][i,emlj], &#39;NEAR_BOUND&#39;)</span>
<span class="c1">#                    near_bound = True</span>


<div class="viewcode-block" id="Elric._correct_subeml_par"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._correct_subeml_par">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_correct_subeml_par</span><span class="p">(</span><span class="n">restwave_0</span><span class="p">,</span> <span class="n">restwave_k</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct the parameters fit assuming a rest wavelength of</span>
<span class="sd">        restwave_0, when it&#39;s actually restwave_k.  Input parameters are</span>
<span class="sd">        expected to be flux, velocity, velocity dispersion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">_par</span> <span class="o">=</span> <span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">restwave_k</span><span class="o">/</span><span class="n">restwave_0</span>
        <span class="n">_par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">restwave_0</span><span class="o">*</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">restwave_k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
        <span class="n">_par</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">restwave_0</span><span class="o">/</span><span class="n">restwave_k</span>
        <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_par</span>

        <span class="n">_err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">restwave_k</span><span class="o">/</span><span class="n">restwave_0</span>
        <span class="n">_err</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">restwave_0</span><span class="o">/</span><span class="n">restwave_k</span>
        <span class="n">_err</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">restwave_0</span><span class="o">/</span><span class="n">restwave_k</span>
        <span class="k">return</span> <span class="n">_par</span><span class="p">,</span> <span class="n">_err</span></div>
        

<div class="viewcode-block" id="Elric._assess_and_save_fit"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric._assess_and_save_fit">[docs]</a>    <span class="k">def</span> <span class="nf">_assess_and_save_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assess the result of the LineProfileFit results.</span>

<span class="sd">            - (DONE) Check the success failure</span>
<span class="sd">            - (DONE) Calculate the chi2, rchi2, rms, fractional_rms,</span>
<span class="sd">              residuals, fractional_residuals</span>
<span class="sd">            - (DONE) Compare the fit parameters to the bounds</span>
<span class="sd">            - Check the chi-square and residuals?</span>
<span class="sd">            - Check the velocity offset wrt the input</span>
<span class="sd">            - For multiple lines, check the order of the lines matches</span>
<span class="sd">              the guess parameters</span>
<span class="sd">            - For multiple component lines, check the ordering of the</span>
<span class="sd">              subcomponents</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Instantiate the returned flag that the parameter are near the</span>
        <span class="c1"># imposed boundary; only meaningful if the fit did not fail</span>
        <span class="n">near_bound</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Assign the fitting window</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FIT_INDEX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
<span class="c1">#        print(model_eml_par[&#39;FIT_INDEX&#39;][i,:])</span>

        <span class="c1"># If the parameters are bounded, save the bounds</span>
        <span class="n">npar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">npar</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounded</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;LOBND&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">npar</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;UPBND&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">npar</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Save which parameters were fixed or should be ignored</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;IGNORE&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">npar</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        
<span class="c1">#        include_model = True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                              <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span>
                           <span class="s1">&#39;FIT FAILED: Spec: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1"> (</span><span class="si">{2}</span><span class="s1"> : </span><span class="si">{3}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">]))</span>
            
            <span class="k">return</span> <span class="n">near_bound</span>

        <span class="c1"># Get the full list of parameters (including fixed and tied values)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_assign_par</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">par</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">npar</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[:]</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FIXED&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">npar</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fixed</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FIXED&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">npar</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">npar</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmperr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmperr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FIXED&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])]</span> \
                        <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cov</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                  <span class="s1">&#39;UNDEFINED_COVAR&#39;</span><span class="p">)</span>


<span class="c1">#        print(&#39;PAR: &#39;, model_fit_par[&#39;PAR&#39;][i,j,:npar])</span>
<span class="c1">#        print(&#39;ERR: &#39;, model_fit_par[&#39;ERR&#39;][i,j,:npar])</span>

        <span class="c1"># Get the per-line parameters</span>
        <span class="n">nlinepar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">p</span><span class="o">.</span><span class="n">npar</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span> <span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
            <span class="n">pl</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nlinepar</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span>
            <span class="n">emlj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                   <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment_err</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                                       <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="c1"># Flux unit conversion</span>
<span class="c1">#            print(astropy.constants.c.to(&#39;km/s&#39;).value/self.fitting_window[j].restwave[k])</span>
<span class="c1">#                    /= astropy.constants.c.to(&#39;km/s&#39;).value/self.fitting_window[j].restwave[k]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">]</span> \
                    <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">]</span> \
                    <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                                   <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment_err</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                                       <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                                   <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">moment_err</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                                       <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                                                    <span class="n">err</span><span class="o">=</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>

            <span class="c1"># Correct for the fact that the fit was done using a</span>
            <span class="c1"># velocity vector defined by the primary line</span>
            <span class="c1"># TODO: Need to change how fitting is done so that this is</span>
            <span class="c1"># NOT necessary!</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line_par</span><span class="p">,</span> <span class="n">line_parerr</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_subeml_par</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">restwave</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                   <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">],</span>
                                                                 <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                                 <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]),</span>
                                                   <span class="n">err</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                                                            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">],</span>
                                                            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]))</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">],</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> \
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">line_par</span><span class="p">)</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">],</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> \
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">line_parerr</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounded</span> \
                    <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_near_bound</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;PAR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_bounds</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">pl</span><span class="p">:</span><span class="n">pl</span><span class="o">+</span><span class="n">nlinepar</span><span class="p">[</span><span class="n">k</span><span class="p">]]):</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">]</span> \
                            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">emlj</span><span class="p">],</span> <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>
                <span class="n">near_bound</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1">#        print(&#39;Any line in window near boundary: &#39;, near_bound)</span>
        <span class="k">if</span> <span class="n">near_bound</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                              <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>

        <span class="c1"># Set the fit statistics</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_chi</span><span class="p">(</span><span class="n">par</span><span class="p">)))</span>
<span class="c1">#        print(&#39;CHI2:&#39;, model_fit_par[&#39;CHI2&#39;][i,j])</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;RCHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> \
                                            <span class="o">/</span> <span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">npar</span><span class="p">)</span>
<span class="c1">#        print(&#39;RCHI2:&#39;, model_fit_par[&#39;RCHI2&#39;][i,j])</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">_resid</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;RMS&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">resid</span><span class="p">)))</span>
<span class="c1">#        print(&#39;RMS:&#39;, model_fit_par[&#39;RMS&#39;][i,j])</span>

        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;RESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">resid</span><span class="p">),</span>
                                                    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="c1">#        model_fit_par[&#39;RESID&#39;][i,j] = residual_growth(resid, [0.25, 0.50, 0.75, 0.90, 0.99])</span>
<span class="c1">#        print(&#39;RESID: &#39;, model_fit_par[&#39;RESID&#39;][i,j])</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-4</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frac_resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">/</span><span class="n">fit</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FRAC_RMS&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">frac_resid</span><span class="p">)))</span>
<span class="c1">#            print(&#39;FRMS:&#39;, model_fit_par[&#39;FRAC_RMS&#39;][i,j])</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FRAC_RESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">frac_resid</span><span class="p">),</span>
                                                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.90</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="c1">#                model_fit_par[&#39;FRAC_RESID&#39;][i,j] = residual_growth(frac_resid,</span>
<span class="c1">#                                                               [0.25, 0.50, 0.75, 0.90, 0.99])</span>
<span class="c1">#                print(&#39;FRAC_RESID: &#39;, model_fit_par[&#39;FRAC_RESID&#39;][i,j])</span>

        <span class="k">return</span> <span class="n">near_bound</span></div>


<span class="c1">#    def _instrumental_dispersion_correction(self, model_eml_par):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Determine the instrumental velocity dispersion at the centroids</span>
<span class="c1">#        of the fitted emission lines.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if self.sres is None:</span>
<span class="c1">#            return</span>
<span class="c1">#</span>
<span class="c1">#        interpolator = interpolate.interp1d(self.wave, self.sres, fill_value=&#39;extrapolate&#39;,</span>
<span class="c1">#                                            assume_sorted=True)</span>
<span class="c1">#        restwave = numpy.array([self.emission_lines[&#39;restwave&#39;]]*self.nspec)</span>
<span class="c1">#        cnst = constants()</span>
<span class="c1">#</span>
<span class="c1">#        # Get the instrumental dispersion at each (valid) line center</span>
<span class="c1">#        indx = ~self.bitmask.flagged(model_eml_par[&#39;MASK&#39;],</span>
<span class="c1">#                                     flag=[&#39;INSUFFICIENT_DATA&#39;, &#39;FIT_FAILED&#39;, &#39;NEAR_BOUND&#39;,</span>
<span class="c1">#                                           &#39;UNDEFINED_COVAR&#39; ])</span>
<span class="c1">#        model_eml_par[&#39;SINST&#39;][indx] = astropy.constants.c.to(&#39;km/s&#39;) \</span>
<span class="c1">#                                            / interpolator((model_eml_par[&#39;KIN&#39;][indx,0] </span>
<span class="c1">#                                                        / astropy.constants.c.to(&#39;km/s&#39;).value+1.0)</span>
<span class="c1">#                                                                *restwave[indx])/cnst.sig2fwhm</span>

<span class="c1">#        z = model_eml_par[&#39;KIN&#39;][indx,0] / astropy.constants.c.to(&#39;km/s&#39;).value</span>
<span class="c1">#        pyplot.scatter(restwave[indx]*(1.0+z), model_eml_par[&#39;SINST&#39;][indx], marker=&#39;.&#39;, s=30,</span>
<span class="c1">#                       color=&#39;k&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.scatter(model_eml_par[&#39;SINST&#39;][indx], model_eml_par[&#39;KIN&#39;][indx,1], marker=&#39;.&#39;,</span>
<span class="c1">#                       s=30, color=&#39;k&#39;)</span>
<span class="c1">#        pyplot.show()</span>


<span class="c1"># NEVER TESTED</span>
<span class="c1">#    def _correct_velocity_dispersion(self, model_eml_par):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Use the **previously calculated** instrumental velocity</span>
<span class="c1">#        dispersion to correct the measured velocity dispersions of the</span>
<span class="c1">#        lines to the astrophysical velocity dispersion.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#        # Correct the second moments for the instrumental dispersion</span>
<span class="c1">#        defined = numpy.zeros(indx.shape, dtype=numpy.bool)</span>
<span class="c1">#        defined[indx] = model_eml_par[&#39;SINST&#39;][indx] &lt; model_eml_par[&#39;KIN&#39;][indx,1]</span>
<span class="c1">#        nonzero = numpy.zeros(indx.shape, dtype=numpy.bool)</span>
<span class="c1">#        nonzero[indx] = numpy.absolute(model_eml_par[&#39;SINST&#39;][indx] </span>
<span class="c1">#                                            - model_eml_par[&#39;KIN&#39;][indx,1]) &gt; 0</span>
<span class="c1">#</span>
<span class="c1">##        orig = model_eml_par[&#39;KIN&#39;].copy()</span>
<span class="c1">#</span>
<span class="c1">#        model_eml_par[&#39;KINERR&#39;][nonzero,1] \</span>
<span class="c1">#                    = 2.0*model_eml_par[&#39;KIN&#39;][nonzero,1]*model_eml_par[&#39;KINERR&#39;][nonzero,1]</span>
<span class="c1">#        model_eml_par[&#39;KIN&#39;][nonzero,1] = numpy.square(model_eml_par[&#39;KIN&#39;][nonzero,1]) \</span>
<span class="c1">#                                                - numpy.square(model_eml_par[&#39;SINST&#39;][nonzero])</span>
<span class="c1">#        model_eml_par[&#39;KIN&#39;][nonzero,1] = model_eml_par[&#39;KIN&#39;][nonzero,1] \</span>
<span class="c1">#                            / numpy.sqrt(numpy.absolute(model_eml_par[&#39;KIN&#39;][nonzero,1]))</span>
<span class="c1">#        model_eml_par[&#39;KINERR&#39;][nonzero,1] /= numpy.absolute(2.*model_eml_par[&#39;KIN&#39;][nonzero,1])</span>
<span class="c1">#</span>
<span class="c1">#        # Flag undefined values</span>
<span class="c1">#        model_eml_par[&#39;MASK&#39;][indx &amp; ~defined] \</span>
<span class="c1">#                = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][indx &amp; ~defined], &#39;UNDEFINED_SIGMA&#39;)</span>
<span class="c1">#</span>
<span class="c1">##        flg = self.bitmask.flagged(model_eml_par[&#39;MASK&#39;], flag=&#39;UNDEFINED_SIGMA&#39;)</span>
<span class="c1">##        pyplot.scatter(orig[nonzero &amp; flg,1], model_eml_par[&#39;KIN&#39;][nonzero &amp; flg,1], marker=&#39;.&#39;,</span>
<span class="c1">##                       s=30, color=&#39;0.8&#39;)</span>
<span class="c1">##        pyplot.scatter(orig[nonzero &amp; ~flg,1], model_eml_par[&#39;KIN&#39;][nonzero &amp; ~flg,1], marker=&#39;.&#39;,</span>
<span class="c1">##                       s=30, color=&#39;k&#39;)</span>
<span class="c1">##        pyplot.show()</span>

<div class="viewcode-block" id="Elric.fit_SpatiallyBinnedSpectra"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric.fit_SpatiallyBinnedSpectra">[docs]</a>    <span class="k">def</span> <span class="nf">fit_SpatiallyBinnedSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This is a basic interface that is geared for the DAP that</span>
<span class="sd">        interacts with the rest of the, more general, parts of the</span>
<span class="sd">        class.</span>

<span class="sd">        This should not declare anything to self!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assign the parameters if provided</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Required parameters for LineProfileFit have not been defined.&#39;</span><span class="p">)</span>

        <span class="c1"># SpatiallyBinnedSpectra object always needed</span>
        <span class="k">if</span> <span class="n">binned_spectra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide spectra object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectra</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid SpatiallyBinnedSpectra object!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided SpatiallyBinnedSpectra object is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Continuum accounts for underlying absorption</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">],</span> <span class="n">StellarContinuumModel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid StellarContinuumModel object.&#39;</span><span class="p">)</span>
        <span class="n">continuum</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fill_to_match</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                            <span class="n">missing</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">continuum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">continuum</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided continuum does not match shape of the binned spectra.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">continuum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span>

        <span class="c1"># Get the data arrays to fit</span>
        <span class="n">good_snr</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">above_snr_limit</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">])</span>
        <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">get_spectra_to_fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                              <span class="n">pixelmask</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">],</span>
                                                              <span class="n">select</span><span class="o">=</span><span class="n">good_snr</span><span class="p">)</span>

        <span class="c1"># Return the fitted data</span>
        <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span>
                           <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">sres</span><span class="o">=</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">good_snr</span><span class="p">,:],</span>
                           <span class="n">continuum</span><span class="o">=</span><span class="n">continuum</span><span class="p">[</span><span class="n">good_snr</span><span class="p">,:],</span> <span class="n">base_order</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;base_order&#39;</span><span class="p">],</span>
                           <span class="n">window_buffer</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;window_buffer&#39;</span><span class="p">],</span>
                           <span class="n">guess_redshift</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">],</span>
                           <span class="n">guess_dispersion</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_dispersion&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">],</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span>
                           <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Save the the bin ID numbers indices based on the spectra</span>
        <span class="c1"># selected to be fit</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">]</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">good_snr</span><span class="p">]</span>

        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">]</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">good_snr</span><span class="p">]</span>

        <span class="c1"># Add the equivalent width data</span>
        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">measure_equivalent_width</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span>
                                                 <span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="n">model_eml_par</span><span class="p">,</span>
                                                 <span class="n">redshift</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">good_snr</span><span class="p">],</span>
                                                 <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">)</span>

        <span class="c1"># Only return model and model parameters for the *fitted*</span>
        <span class="c1"># spectra</span>
        <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Elric.fit"><a class="viewcode-back" href="../../../mangadap.proc.elric.html#mangadap.proc.elric.Elric.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">continuum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_order</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_buffer</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">guess_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The flux array is expected to have size Nspec x Nwave.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the length of the spectra, errors, or</span>
<span class="sd">                mask does not match the length of the wavelength array;</span>
<span class="sd">                raised if the wavelength, redshift, or dispersion arrays</span>
<span class="sd">                are not 1D vectors; and raised if the number of</span>
<span class="sd">                redshifts or dispersions is not a single value or the</span>
<span class="sd">                same as the number of input spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># Check the input emission-line database</span>
        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">check_emission_line_database</span><span class="p">(</span><span class="n">emission_lines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span> <span class="o">=</span> <span class="n">emission_lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="o">.</span><span class="n">neml</span>

        <span class="c1"># Prepare the spectra for fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wave</span> <span class="o">=</span> <span class="n">wave</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersion</span> \
                    <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">check_and_prep_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                                           <span class="n">sres</span><span class="o">=</span><span class="n">sres</span><span class="p">,</span> <span class="n">continuum</span><span class="o">=</span><span class="n">continuum</span><span class="p">,</span>
                                                           <span class="n">redshift</span><span class="o">=</span><span class="n">guess_redshift</span><span class="p">,</span>
                                                           <span class="n">dispersion</span><span class="o">=</span><span class="n">guess_dispersion</span><span class="p">,</span>
                                                        <span class="n">default_dispersion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_dispersion</span><span class="p">)</span>
        <span class="c1"># Keep the shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Subtract the continuum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxnc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">subtract_continuum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="p">)</span>
        <span class="c1"># No continuum for any spaxel!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

<span class="c1">#        pyplot.step(self.wave, self.flux[0,:], where=&#39;mid&#39;, color=&#39;k&#39;, lw=0.5, linestyle=&#39;-&#39;)</span>
<span class="c1">#        pyplot.step(self.wave, self.fluxnc[0,:], where=&#39;mid&#39;, color=&#39;g&#39;, lw=0.5, linestyle=&#39;-&#39;)</span>
<span class="c1">#        pyplot.plot(self.wave, self.no_continuum[0,:], color=&#39;r&#39;, lw=0.5, linestyle=&#39;-&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        exit()</span>

        <span class="c1"># Build the emission-line fitting windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_emission_line_models</span><span class="p">()</span>
        <span class="n">max_npar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span> <span class="n">fw</span><span class="o">.</span><span class="n">fixed_par</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">fw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">=</span> <span class="n">base_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_order</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">max_npar</span> <span class="o">+=</span> <span class="n">base_order</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_buffer</span> <span class="o">=</span> <span class="n">window_buffer</span>

        <span class="c1"># Initialize the output arrays</span>
        <span class="c1">#  Model flux:</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">model_base</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1">#  Model mask:</span>
        <span class="n">model_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span><span class="p">],</span>
                                                             <span class="s1">&#39;NOCONTINUUM&#39;</span><span class="p">)</span>

        <span class="c1"># Model parameters and fit quality</span>
        <span class="n">model_fit_par</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span>
                                          <span class="n">Elric</span><span class="o">.</span><span class="n">_per_fitting_window_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">,</span> <span class="n">max_npar</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">()))</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span>

        <span class="c1"># Emission-line parameters</span>
        <span class="n">model_eml_par</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_per_emission_line_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">()))</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="c1"># Do the fit</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_velocity_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">):</span>
<span class="c1">#        for i in range(5):</span>

<span class="c1">#            for j in range(self.nwindows):</span>
<span class="c1">#                print(&#39;Window: {0}/{1}&#39;.format(j+1, self.nwindows))</span>
<span class="c1">#                for p in self.fitting_window[j].profile_set:</span>
<span class="c1">#                    print(p.par)</span>
<span class="c1">#            if not self.quiet:</span>
<span class="c1">#                log_output(self.loggers, 1, logging.INFO, &#39;Fit: {0}/{1}&#39;.format(i+1,self.nspec))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fit: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Get the fitting mask for each emission-line in each window</span>
            <span class="n">fitting_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_masks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">window_buffer</span><span class="p">)</span>

            <span class="c1"># Set the mask for any pixels that are NEVER fit for this</span>
            <span class="c1"># spectrum</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">fitting_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;OUTSIDE_RANGE&#39;</span><span class="p">)</span>

            <span class="n">model_jump</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fm</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_continuum</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fm</span><span class="p">)]</span> \
                        <span class="k">for</span> <span class="n">fm</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">fitting_mask</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">])</span>
            <span class="n">spec_to_fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="k">if</span> <span class="n">mj</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxnc</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> \
                                            <span class="k">for</span> <span class="n">mj</span> <span class="ow">in</span> <span class="n">model_jump</span> <span class="p">])</span>

            <span class="n">cz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

<span class="c1">#            total_near_bound = 0</span>
            <span class="c1"># Fit each window</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwindows</span><span class="p">):</span>
                <span class="c1"># Rest the profile to the initial parameters</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reinit_profiles</span><span class="p">()</span>
<span class="c1">#                print(&#39;Fitting: &#39;, self.emission_lines[&#39;name&#39;][self.fitting_window[j].db_indx])</span>

                <span class="c1"># No observed pixels in fitting window</span>
<span class="c1">#                print(&#39;Sum of fitting mask: {0}&#39;.format(numpy.sum(fitting_mask[j,:])))</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No valid data for fit to line(s) </span><span class="si">{0}</span><span class="s1"> (</span><span class="si">{1}</span><span class="s1">).  &#39;</span>
                                  <span class="s1">&#39;Continuuing&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">]))</span>
                    <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                      <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

<span class="c1">#                w,h = pyplot.figaspect(1)</span>
<span class="c1">#                fig = pyplot.figure(figsize=(1.5*w,1.5*h))</span>
<span class="c1">#                ax = fig.add_axes([0.1, 0.3, 0.8, 0.4])</span>
<span class="c1">#                ax.set_xlim(velocity[j,0], velocity[j,-1])</span>
<span class="c1">#                ax.step(velocity[j,:], spec_to_fit[j,:], where=&#39;mid&#39;, color=&#39;k&#39;, linestyle=&#39;-&#39;,</span>
<span class="c1">#                        lw=0.5)</span>
<span class="c1">#                ax.plot(velocity[j,:], fitting_mask[j,:], color=&#39;r&#39;)</span>
<span class="c1">#                axt = ax.twiny()</span>
<span class="c1">#                axt.set_xlim(self.wave[0], self.wave[-1])</span>
<span class="c1">#                pyplot.show()</span>

                <span class="c1"># Shift the guess velocity based on the redshift and</span>
                <span class="c1"># adjust the guess flux</span>
                <span class="c1"># TODO: Use emission-line moment results for the</span>
                <span class="c1"># guesses, if provided</span>
                <span class="c1"># TODO: Use self.dispersion to set the initial</span>
                <span class="c1"># dispersion guesses?  Currently uses guesses from</span>
                <span class="c1"># emission-line database (see</span>
                <span class="c1"># _parse_emission_line_models)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">):</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">shift_mean</span><span class="p">(</span><span class="n">cz</span><span class="p">)</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#                    print(&#39;guess flux: &#39;, (spec_to_fit[j,vi] if spec_to_fit[j,vi] &gt; 0.1 else 0.1) \</span>
<span class="c1">#                                * numpy.sqrt(2*numpy.pi) * p.moment(order=2))</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_flux</span><span class="p">((</span><span class="n">spec_to_fit</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">vi</span><span class="p">]</span> <span class="k">if</span> <span class="n">spec_to_fit</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">vi</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="k">else</span> <span class="mf">0.1</span><span class="p">)</span> \
                                <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

                <span class="c1"># Setup the guess parameters and bounds</span>
                <span class="n">_guess_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">p</span><span class="o">.</span><span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> \
                                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span> <span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">_fixed_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fixed_par</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#                print(_guess_par)</span>
<span class="c1">#                print(_fixed_par)</span>
<span class="c1">#                print(_bounds)</span>

                <span class="c1"># For individual lines, bound the line mean to be within</span>
                <span class="c1"># the fitting window</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">()</span>
                    <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># For multiple lines, bound the line mean to be within</span>
                <span class="c1"># its own region of the window defined by the +/- 2/3 of</span>
                <span class="c1"># the velocity separation to the nearest line.  These</span>
                <span class="c1"># borders overlap!</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
                        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">())</span> \
                            <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span><span class="o">.</span><span class="n">npar</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]))</span>
                    <span class="n">srt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
                    <span class="n">borders</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                        <span class="n">borders</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">diff</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span>
                                     <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">/</span><span class="mf">3.0</span> <span class="p">]</span>
                    <span class="n">borders</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">borders</span><span class="p">,</span>
                                            <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
                    <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">srt</span><span class="p">]</span>
                    <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">srt</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Add the parameters for the baseline</span>
                <span class="k">if</span> <span class="n">base_order</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">_guess_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_guess_par</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">base_order</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="c1">#                    _guess_par[-base_order-1] = numpy.median(spec_to_fit[j,fitting_mask[j,:]])</span>
<span class="c1">#                    print(0.0, _guess_par[-base_order-1])</span>
<span class="c1">#                    pyplot.scatter(velocity[j,fitting_mask[j,:]], spec_to_fit[j,fitting_mask[j,:]],</span>
<span class="c1">#                                   marker=&#39;.&#39;, s=100, color=&#39;k&#39;)</span>
<span class="c1">#                    y = velocity.copy()[j,fitting_mask[j,:]]</span>
<span class="c1">#                    y[:] = numpy.median(spec_to_fit[j,fitting_mask[j,:]])</span>
<span class="c1">#                    pyplot.plot(velocity[j,fitting_mask[j,:]], y, color=&#39;r&#39;)</span>
<span class="c1">#                    pyplot.show()</span>
<span class="c1">#                    exit()</span>
                    <span class="n">_fixed_par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">fixed_par</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                              <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">base_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
                    <span class="n">_bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_bounds</span><span class="p">,</span>
                          <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">base_order</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Check there is sufficient data to perform the fit</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_to_fit</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span><span class="o">.</span><span class="n">compressed</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">_guess_par</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Insufficient data points (</span><span class="si">{0}</span><span class="s1">) to fit with this function &#39;</span> \
                                  <span class="s1">&#39;(npar=</span><span class="si">{1}</span><span class="s1">)!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="n">spec_to_fit</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span><span class="o">.</span><span class="n">compressed</span><span class="p">()),</span>
                                        <span class="n">_guess_par</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># Flag that the fit was not performed</span>
                    <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                      <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Make sure that the guess is still in the bounds:</span>
                <span class="c1"># TODO: How do I deal with this:</span>
                <span class="c1">#   - throw a warning and adjust the guess</span>
                <span class="c1">#   - as above and include a mask bit</span>
                <span class="c1">#   - don&#39;t perform the fit because it will be bogus</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span> <span class="n">_guess_par</span> <span class="o">&lt;</span> <span class="n">_bounds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">_guess_par</span> <span class="o">&gt;</span> <span class="n">_bounds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Initial guess outside bounds for line(s) </span><span class="si">{0}</span><span class="s1"> (</span><span class="si">{1}</span><span class="s1">).  &#39;</span>
                                  <span class="s1">&#39;Adjusted to center of bounds.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">line_index</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">db_indx</span><span class="p">]))</span>
                    <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># TODO: Get rid of this debugging issue...</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_bounds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">_bounds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]):</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">_bounds</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">()</span>
                        <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">())</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">nlines</span><span class="p">):</span>
                            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean_indx</span><span class="p">())</span> \
                                <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span><span class="o">.</span><span class="n">npar</span>
                                    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]))</span>
                        <span class="n">srt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
                        <span class="n">borders</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">diff</span> <span class="o">=</span> <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                            <span class="n">borders</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">diff</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span>
                                        <span class="n">_guess_par</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">srt</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">/</span><span class="mf">3.0</span> <span class="p">]</span>
                        <span class="n">borders</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">borders</span><span class="p">,</span>
                                                <span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;borders&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">borders</span><span class="p">)</span>
                        <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">srt</span><span class="p">]</span>
                        <span class="n">_bounds</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">srt</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">_bounds</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;WTF&#39;</span><span class="p">)</span>

<span class="c1">#                print(_guess_par)</span>
<span class="c1">#                print(_bounds)</span>
<span class="c1">#                pyplot.errorbar(velocity[j,fitting_mask[j,:]], spec_to_fit[j,fitting_mask[j,:]],</span>
<span class="c1">#                                yerr=_error[i,fitting_mask[j,:]], marker=&#39;.&#39;, color=&#39;k&#39;,</span>
<span class="c1">#                                linestyle=&#39;&#39;, capsize=0)</span>
<span class="c1">#                pyplot.title(&#39;Spec: {0}; Line (set): {1}&#39;.format(i+1,j+1))</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#                print(&#39;N valid pixels: {0}&#39;.format(</span>
<span class="c1">#                                               len(spec_to_fit[j,fitting_mask[j,:]].compressed())))</span>
                
                <span class="c1"># Run the fit</span>
<span class="c1">#                print(&#39;guess par: {0} {1}&#39;.format(i, j))</span>
<span class="c1">#                print(_guess_par)</span>
<span class="c1">#                print(&#39; &#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">LineProfileFit</span><span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,:],</span> <span class="n">spec_to_fit</span><span class="p">[</span><span class="n">j</span><span class="p">,:],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">profile_set</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                                            <span class="n">error</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                                   <span class="n">base_order</span><span class="o">=</span><span class="n">base_order</span><span class="p">,</span>
                                                   <span class="n">mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]),</span>
                                                   <span class="n">par</span><span class="o">=</span><span class="n">_guess_par</span><span class="p">,</span>
                                                   <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">_bounds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">_bounds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span>
                                                   <span class="n">construct_covariance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                                   <span class="c1">#, verbose=2)#, fixed=_fixed_par)</span>
<span class="c1">#                print(&#39;Spec: {0}; Line (set): {1}; Success: {2}&#39;.format(i+1,j+1,</span>
<span class="c1">#                                                                self.bestfit[i,j].result.success))</span>

                <span class="n">near_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assess_and_save_fit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">near_bound</span><span class="p">:</span>
<span class="c1">#                    print(&#39;Flagging mask as near bound&#39;)</span>
                    <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span> \
                            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]],</span> <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>
<span class="c1">#                    total_near_bound += 1</span>

                <span class="c1"># Add the best-fit to the lines to the composite model</span>
                <span class="c1"># for this spectrum</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">output_model</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
                    
                    <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span> \
                            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]],</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">output_model</span> <span class="ow">or</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                      <span class="s1">&#39;EXCLUDED_FROM_MODEL&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitting_window</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">output_model</span> <span class="ow">and</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Get the full model (eventually will only be the</span>
                    <span class="c1"># baseline)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">model_base</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span> \
                            <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]],</span> <span class="n">par</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                    <span class="c1"># Remove the baseline and only get the line profile</span>
                    <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="n">base_order</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">model_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]]</span> \
                            <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">fitting_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]],</span> <span class="n">par</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

<span class="c1">#                if 44 in self.fitting_window[j].line_index:</span>
<span class="c1">#                    pyplot.errorbar(velocity[j,fitting_mask[j,:]], spec_to_fit[j,fitting_mask[j,:]],</span>
<span class="c1">#                                    yerr=self.error[i,fitting_mask[j,:]], marker=&#39;.&#39;, color=&#39;k&#39;,</span>
<span class="c1">#                                    linestyle=&#39;&#39;, capsize=0)</span>
<span class="c1">#                    pyplot.plot(velocity[j,fitting_mask[j,:]],</span>
<span class="c1">#                                self.bestfit[i,j].sample(velocity[j,fitting_mask[j,:]],</span>
<span class="c1">#                                par=self.bestfit[i,j].result.x), linestyle=&#39;-&#39;, color=&#39;g&#39;)</span>
<span class="c1">#                    pyplot.plot(velocity[j,fitting_mask[j,:]],</span>
<span class="c1">#                                self.bestfit[i,j].sample(velocity[j,fitting_mask[j,:]],</span>
<span class="c1">#                                par=_guess_par), linestyle=&#39;-&#39;, color=&#39;r&#39;)</span>
<span class="c1">#                    print(_guess_par)</span>
<span class="c1">#                    print(self.bestfit[i,j].result.x)</span>
<span class="c1">#                    pyplot.title(&#39;Spec: {0}; Line (set): {1}&#39;.format(i+1,j+1))</span>
<span class="c1">#                    pyplot.show()</span>

<span class="c1">#            pyplot.plot(wave, model_flux[i,:], linestyle=&#39;-&#39;, color=&#39;g&#39;)</span>
<span class="c1">#            pyplot.plot(wave, model_base[i,:], linestyle=&#39;-&#39;, color=&#39;r&#39;)</span>
<span class="c1">#            pyplot.show()</span>

<span class="c1">#            print(&#39;Windows with parameters near boundary: {0}&#39;.format(total_near_bound))</span>

            <span class="c1"># Determine the instrumental dispersion correction at the line centers</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:],</span>
                                                     <span class="n">flag</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">,</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">,</span>
                                                           <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">,</span> <span class="s1">&#39;UNDEFINED_COVAR&#39;</span> <span class="p">]))</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">instrumental_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                                              <span class="n">emission_lines</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span>
                                                              <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># With these definitions, the instrumental sigma and the sigma correction are</span>
        <span class="c1"># identical, and the &quot;template&quot; sigma are all zero</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMAINST&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fit: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))</span>
        <span class="c1"># Remove the lines from the full model to just provide the</span>
        <span class="c1"># baseline model</span>
        <span class="n">model_base</span> <span class="o">-=</span> <span class="n">model_flux</span>

<span class="c1">#        pyplot.plot(wave, model_flux[0,:], linestyle=&#39;-&#39;, color=&#39;g&#39;)</span>
<span class="c1">#        pyplot.plot(wave, model_base[0,:], linestyle=&#39;-&#39;, color=&#39;r&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Fits completed in </span><span class="si">{0:.4e}</span><span class="s1"> min.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span></div></div>


</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>