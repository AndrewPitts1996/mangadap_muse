

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.sasuke &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.sasuke</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.sasuke</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements an emission-line fitting class that largely wraps pPXF.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2017, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/sasuke.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import time</span>
<span class="sd">        import os</span>
<span class="sd">        import logging</span>

<span class="sd">        import numpy</span>
<span class="sd">        from scipy import interpolate, fftpack</span>
<span class="sd">        import astropy.constants</span>

<span class="sd">        from ..par.parset import ParSet</span>
<span class="sd">        from ..par.emissionlinedb import EmissionLineDB</span>
<span class="sd">        from ..util.fileio import init_record_array</span>
<span class="sd">        from ..util.log import log_output</span>
<span class="sd">        from ..util.pixelmask import SpectralPixelMask</span>
<span class="sd">        from .spatiallybinnedspectra import SpatiallyBinnedSpectra</span>
<span class="sd">        from .stellarcontinuummodel import StellarContinuumModel</span>
<span class="sd">        from .spectralfitting import EmissionLineFit</span>
<span class="sd">        from .util import sample_growth</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">        Add examples</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **24 May 2017**: Original implementation started by K. Westfall (KBW)</span>
<span class="sd">    | **23 Jun 2017**: (KBW) Documentation; fix error in</span>
<span class="sd">        :func:`Sasuke._save_results`</span>
<span class="sd">    | **08 Sep 2017**: (KBW) Move emission-line template construction to</span>
<span class="sd">        :mod:`mangadap.proc.emissionlinetemplates`. Add</span>
<span class="sd">        `deconstruct_bins` flag to parameters.</span>
<span class="sd">    | **25 Oct 2017**: (KBW) Allow to use reddening fit from pPXF</span>
<span class="sd">    | **02 Feb 2018**: (KBW) Use </span>
<span class="sd">        :func:`mangadap.proc.spectralfitting.EmissionLineFit.select_binned_spectra_to_fit`.</span>
<span class="sd">        Adjust for change to</span>
<span class="sd">        :func:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel.fill_to_match`.</span>
<span class="sd">    | **24 Feb 2018**: (KBW) Allow for a new template library to be</span>
<span class="sd">        used, different from the one used during the stellar continuum</span>
<span class="sd">        fit.</span>
<span class="sd">    | **20 Mar 2018**: (KBW) Corrected flux calculation and inclusion</span>
<span class="sd">        of provided pixel mask.</span>

<span class="sd">.. _numpy.ma.MaskedArray: https://docs.scipy.org/doc/numpy-1.12.0/reference/maskedarray.baseclass.html</span>
<span class="sd">.. _numpy.recarray: https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">fftpack</span>

<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..par.emissionlinedb</span> <span class="k">import</span> <span class="n">EmissionLineDB</span>
<span class="kn">from</span> <span class="nn">..util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span>
<span class="kn">from</span> <span class="nn">..util.filter</span> <span class="k">import</span> <span class="n">interpolate_masked_vector</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">spectrum_velocity_scale</span><span class="p">,</span> <span class="n">spectral_coordinate_step</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">SpectralResolution</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util.constants</span> <span class="k">import</span> <span class="n">DAPConstants</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="k">import</span> <span class="n">lineprofiles</span>
<span class="kn">from</span> <span class="nn">.templatelibrary</span> <span class="k">import</span> <span class="n">TemplateLibrary</span>
<span class="kn">from</span> <span class="nn">.spatiallybinnedspectra</span> <span class="k">import</span> <span class="n">SpatiallyBinnedSpectra</span>
<span class="kn">from</span> <span class="nn">.stellarcontinuummodel</span> <span class="k">import</span> <span class="n">StellarContinuumModel</span>
<span class="kn">from</span> <span class="nn">.spectralfitting</span> <span class="k">import</span> <span class="n">EmissionLineFit</span>
<span class="kn">from</span> <span class="nn">.bandpassfilter</span> <span class="k">import</span> <span class="n">emission_line_equivalent_width</span>
<span class="kn">from</span> <span class="nn">.emissionlinetemplates</span> <span class="k">import</span> <span class="n">EmissionLineTemplates</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">sample_growth</span>
<span class="kn">from</span> <span class="nn">.ppxffit</span> <span class="k">import</span> <span class="n">PPXFModel</span><span class="p">,</span> <span class="n">PPXFFitResult</span><span class="p">,</span> <span class="n">PPXFFit</span>
<span class="kn">from</span> <span class="nn">..contrib.xjmc</span> <span class="k">import</span> <span class="n">emline_fitter_with_ppxf_edit</span>
<span class="kn">from</span> <span class="nn">captools</span> <span class="k">import</span> <span class="n">ppxf</span>

<span class="c1"># For debugging</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<div class="viewcode-block" id="SasukePar"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.SasukePar">[docs]</a><span class="k">class</span> <span class="nc">SasukePar</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class specific to the DAP&#39;s use of Sasuke.</span>

<span class="sd">    This is the object that gets passed to</span>
<span class="sd">    :func:`Sasuke.fit_SpatiallyBinnedSpectra`.  In the DAP, it is</span>
<span class="sd">    instantiated by</span>
<span class="sd">    :func:`mangadap.proc.emissionlinemodel.available_emission_line_modeling_methods`</span>
<span class="sd">    and some of its components are filled by</span>
<span class="sd">    :func:`mangdap.proc.emissionlinemodel.EmissionLineModel._fill_method_par`.</span>

<span class="sd">    The continuum templates can either be the string keyword used to</span>
<span class="sd">    construct the template library, or the template library itself.  If</span>
<span class="sd">    the former, the fit_SpatiallyBinnedSpectra object will construct the</span>
<span class="sd">    template library for later callback.</span>

<span class="sd">    When instantiated, the :class:`mangadap.par.parset.ParSet` objects</span>
<span class="sd">    test that the input objects match the provided dtypes.  See</span>
<span class="sd">    documentation for :class:`mangadap.par.parset.ParSet` for the list</span>
<span class="sd">    of attributes and exceptions raised.</span>

<span class="sd">    Args:</span>
<span class="sd">        stellar_continuum</span>
<span class="sd">            (:class:`mangadap.proc.stellarcontinuummodel.StellarContinuumModel`):</span>
<span class="sd">            The result of the previous fit to the stellar continuum.</span>
<span class="sd">        emission_lines</span>
<span class="sd">            (:class:`mangadap.par.emissionlinedb.EmissionLineDB`):</span>
<span class="sd">            Emission-line database with the details of the lines to be</span>
<span class="sd">            fit.</span>
<span class="sd">        continuum_templates</span>
<span class="sd">            (str, :class:`mangadap.proc.templatelibrary.TemplateLibrary`):</span>
<span class="sd">            (**Optional**) The new continuum template library to use</span>
<span class="sd">            during the emission-line fit.</span>
<span class="sd">        etpl_line_sigma_mode (str): (**Optional**) Mode used to set the</span>
<span class="sd">            instrumental dispersion of the emission-line templates.</span>
<span class="sd">            Mode options are explated by</span>
<span class="sd">            :func:`Sasuke.etpl_line_sigma_options`.  Default is</span>
<span class="sd">            &#39;default&#39;.</span>
<span class="sd">        etpl_line_sigma_min (int,float): (**Optional**) Impose a minimum</span>
<span class="sd">            emission-line sigma by offsetting the nominal trend, in</span>
<span class="sd">            quadrature, to have this minimum value.  Default is 0.</span>
<span class="sd">        guess_redshift (array-like): Single or per-spectrum redshift to</span>
<span class="sd">            use as the initial velocity guess.</span>
<span class="sd">        guess_dispersion (array-like): Single or per-spectrum velocity</span>
<span class="sd">            dispersion to use as the initial guess.</span>
<span class="sd">        minimum_snr (float): Minimum S/N of spectrum to fit.</span>
<span class="sd">        pixelmask (:class:`mangadap.util.pixelmask.SpectralPixelMask`):</span>
<span class="sd">            Mask to apply to all spectra being fit.</span>
<span class="sd">        reject_boxcar (int): Size of the boxcar to use when rejecting</span>
<span class="sd">            fit outliers.</span>
<span class="sd">        bias (float): pPXF bias parameter.  (Irrelevant because gas is</span>
<span class="sd">            currently always fit with moments=2.)</span>
<span class="sd">        moments (int): pPXF moments parameter.  (Irrelevant because gas is</span>
<span class="sd">            currently always fit with moments=2.)</span>
<span class="sd">        degree (int): pPXF degree parameter setting the degree of the</span>
<span class="sd">            additive polynomials to use.</span>
<span class="sd">        mdegree (int): pPXF mdegree parameter setting the degree of the</span>
<span class="sd">            multiplicative polynomials to use.</span>
<span class="sd">        reddening (float): pPXF reddening parameter setting the initial</span>
<span class="sd">            :math:`E(B-V)` to fit, based on a Calzetti law.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stellar_continuum</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">continuum_templates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">etpl_line_sigma_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">etpl_line_sigma_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">guess_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">deconstruct_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">moments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">arr_like</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span> <span class="p">]</span>
        <span class="n">arr_in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        <span class="n">etpl_mode_options</span> <span class="o">=</span> <span class="n">Sasuke</span><span class="o">.</span><span class="n">etpl_line_sigma_options</span><span class="p">()</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;stellar_continuum&#39;</span><span class="p">,</span> <span class="s1">&#39;emission_lines&#39;</span><span class="p">,</span> <span class="s1">&#39;continuum_templates&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;etpl_line_sigma_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;etpl_line_sigma_min&#39;</span><span class="p">,</span> <span class="s1">&#39;velscale_ratio&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;guess_redshift&#39;</span><span class="p">,</span> <span class="s1">&#39;guess_dispersion&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;pixelmask&#39;</span><span class="p">,</span> <span class="s1">&#39;reject_boxcar&#39;</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;moments&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;mdegree&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;reddening&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">stellar_continuum</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">continuum_templates</span><span class="p">,</span> <span class="n">etpl_line_sigma_mode</span><span class="p">,</span>
                     <span class="n">etpl_line_sigma_min</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">,</span>
                     <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">deconstruct_bins</span><span class="p">,</span> <span class="n">pixelmask</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span>
                     <span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">reddening</span> <span class="p">]</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">etpl_mode_options</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">StellarContinuumModel</span><span class="p">,</span> <span class="n">EmissionLineDB</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TemplateLibrary</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span>
                     <span class="nb">int</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">SpectralPixelMask</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">in_fl</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
                        <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>


<div class="viewcode-block" id="SasukePar._check"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.SasukePar._check">[docs]</a>    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;reddening&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot fit both multiplicative polynomials and an extinction curve.&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Sasuke"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke">[docs]</a><span class="k">class</span> <span class="nc">Sasuke</span><span class="p">(</span><span class="n">EmissionLineFit</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use ninja skills and pPXF to fit emission lines.</span>

<span class="sd">    https://en.wikipedia.org/wiki/Sasuke_Uchiha</span>

<span class="sd">    Effectively, **nothing** happens during the instantiation of this</span>
<span class="sd">    object.  Instead, a typical usage of the class when fitting a set of</span>
<span class="sd">    emission lines would be::</span>

<span class="sd">        # Read the emission-line database</span>
<span class="sd">        emldb = EmissionLineDB(&#39;ELPMILES&#39;)</span>
<span class="sd">        # Instantiate the emission-line fitter</span>
<span class="sd">        el_fitter = Sasuke(EmissionLineModelBitMask())</span>
<span class="sd">        # Fit the spectra</span>
<span class="sd">        model_wave, model_flux, model_eml_flux, model_mask, model_fit_par, \</span>
<span class="sd">            model_eml_par = el_fitter.fit(...)</span>

<span class="sd">    See :func:`fit` for the arguments to the main fitting function.</span>

<span class="sd">    The class inherits attributes from</span>
<span class="sd">    :class:`mangadap.proc.spectralfitting.EmissionLineFit` (`fit_type`,</span>
<span class="sd">    `bitmask`, `par`, `fit_method`).  Other attributes are defined upon</span>
<span class="sd">    instantiation and set to None.  This isn&#39;t necessary (attributes can</span>
<span class="sd">    be defined elsewhere in the class methods), but it provides a</span>
<span class="sd">    collation of the class attributes for reference.</span>

<span class="sd">    Args:</span>
<span class="sd">        bitmask (:class:`BitMask`): BitMask object use to flag fit</span>
<span class="sd">            results.  This *must* be provided and should typically be an</span>
<span class="sd">            instantiation of :class:`EmissionLineModelBitMask`; however,</span>
<span class="sd">            it can be any object with :class:`BitMask` as its base</span>
<span class="sd">            class.  The flags set within the main fitting function</span>
<span class="sd">            (:func:`Sasuke.fit`) are: DIDNOTUSE, INSUFFICIENT_DATA,</span>
<span class="sd">            FIT_FAILED, NEAR_BOUND, NO_FIT,</span>
<span class="sd">            :attr:`mangadap.proc.ppxffit.PPXFFit.rej_flag`</span>
<span class="sd">            (PPXF_REJECT), MIN_SIGMA, BAD_SIGMA, and MAXITER.  Also the</span>
<span class="sd">            DAP-specific calling function</span>
<span class="sd">            (:func:`Sasuke.fit_SpatiallyBinnedSpectra`) will also assign</span>
<span class="sd">            bits NON_POSITIVE_CONTINUUM during the equivalent width</span>
<span class="sd">            measurements (see</span>
<span class="sd">            :func:`mangadap.spectralfitting.EmissionLineFit.measure_equivalent_width`).</span>
<span class="sd">        loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">            to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">            using :func:`mangadap.util.log.log_output`.  Default is no</span>
<span class="sd">            logging.  This can be reset in some methods.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress all terminal and logging</span>
<span class="sd">            output.  Default is False.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        loggers (list): List of `logging.Logger`_ objects to log</span>
<span class="sd">            progress; ignored if quiet=True.  Logging is done using</span>
<span class="sd">            :func:`mangadap.util.log.log_output`.</span>
<span class="sd">        quiet (bool): Suppress all terminal and logging output.</span>
<span class="sd">        obj_wave (numpy.ndarray): Wavelength vector for object spectra.</span>
<span class="sd">            Shape is (:math:`N_{\rm pix}`,).</span>
<span class="sd">        obj_flux (`numpy.ma.MaskedArray`_): Object spectra to fit.</span>
<span class="sd">            Shape is (:math:`N_{\rm spec},N_{\rm pix}`).</span>
<span class="sd">        obj_ferr (`numpy.ma.MaskedArray`_): :math:`1\sigma` errors in</span>
<span class="sd">            object spectra.  Shape is (:math:`N_{\rm spec},N_{\rm</span>
<span class="sd">            pix}`).</span>
<span class="sd">        obj_sres (numpy.ndarray): Spectral resolution array for object</span>
<span class="sd">            spectra.  Shape is (:math:`N_{\rm spec},N_{\rm pix}`).</span>
<span class="sd">        nobj (int): Number of object spectra (i.e., :math:`N_{\rm</span>
<span class="sd">            spec}`).</span>
<span class="sd">        npix_obj (int): Number of pixels in each object spectrum (i.e.,</span>
<span class="sd">            :math:`N_{\rm pix}`).</span>
<span class="sd">        input_obj_mask (numpy.ndarray): A copy of the input mask array</span>
<span class="sd">            of the object spectra (boolean array).  Shape is</span>
<span class="sd">            (:math:`N_{\rm spec},N_{\rm pix}`).</span>
<span class="sd">        obj_to_fit (numpy.ndarray): Flag to fit each object spectrum.</span>
<span class="sd">            Instantiating by fully masked spectra in</span>
<span class="sd">            :attr:`input_obj_mask`.  Shape is (:math:`N_{\rm spec}`,).</span>
<span class="sd">        input_cz (numpy.ndarray): Input redshifts (in km/s) for each</span>
<span class="sd">            spectrum.  Shape is (:math:`N_{\rm spec}`,).</span>
<span class="sd">        velscale (float): Velocity scale (km/s) of the object spectra.</span>
<span class="sd">        tpl_wave (numpy.ndarray): Wavelength vector for template spectra.</span>
<span class="sd">            Shape is (:math:`N_{\rm pix,t}`,).</span>
<span class="sd">        tpl_flux (numpy.ndarray): Template spectra to use in fit.</span>
<span class="sd">            Shape is (:math:`N_{\rm tpl},N_{\rm pix,t}`).</span>
<span class="sd">        tpl_to_use (numpy.ndarray): Set of flags used to select the</span>
<span class="sd">            templates used to fit each spectrum.  Shape is</span>
<span class="sd">            (:math:`N_{\rm spec},N_{\rm tpl}`).</span>
<span class="sd">        nstpl (int): Number of stellar templates.</span>
<span class="sd">        ntpl (int): Total number of templates (gas + stars).</span>
<span class="sd">        npix_tpl (int): Number of pixels in template spectra (i.e.,</span>
<span class="sd">            :math:`N_{\rm pix,t}`).</span>
<span class="sd">        tpl_npad (int): Nearest length for FFT, :math:`N_{\rm pad}`</span>
<span class="sd">        tpl_rfft (numpy.ndarray): The complex array with the real FFT of</span>
<span class="sd">            the template spectra.  Shape is (:math:`N_{\rm tpl}, N_{\rm</span>
<span class="sd">            pad}/2 + 1`).</span>
<span class="sd">        matched_resolution (bool): The spectral resolution of the</span>
<span class="sd">            templates is matched to that of the galaxy data.  WARNING:</span>
<span class="sd">            This functionality needs to be checked in relation to the</span>
<span class="sd">            gas templates!</span>
<span class="sd">        velscale_ratio (int): The **integer** ratio between the velocity</span>
<span class="sd">            scale of the pixel in the galaxy data to that of the</span>
<span class="sd">            template data.</span>
<span class="sd">        emldb (:class:`mangadap.par.emissionlinedb.EmissionLineDB&#39;):</span>
<span class="sd">            Emission-line database that is parsed to construct the</span>
<span class="sd">            emission-line templates (see</span>
<span class="sd">            :class:`EmissionLineTemplates`).</span>
<span class="sd">        neml (int): Number of emission lines in the database.</span>
<span class="sd">        fit_eml (numpy.ndarray): Boolean array setting which emission</span>
<span class="sd">            lines are fit.  Shape is (:math:`N_{\rm eml`,).</span>
<span class="sd">        eml_tpli (numpy.ndarray): Integer array with the template that</span>
<span class="sd">            includes each emission line.  Shape is (:math:`N_{\rm eml`,).</span>
<span class="sd">        eml_compi (numpy.ndarray): Integer array with the kinematic</span>
<span class="sd">            component that includes each emission line.  Shape is</span>
<span class="sd">            (:math:`N_{\rm eml`,).</span>
<span class="sd">        ncomp (int): Total number of kinematic components to fit.</span>
<span class="sd">        tpl_comp (numpy.ndarray): The integer kinematic component</span>
<span class="sd">            associated with each template.  Shape is (:math:`N_{\rm</span>
<span class="sd">            tpl},). </span>
<span class="sd">        tpl_vgrp (numpy.ndarray): The integer velocity group associated</span>
<span class="sd">            with each template.  Shape is (:math:`N_{\rm tpl},). </span>
<span class="sd">        tpl_sgrp (numpy.ndarray): The integer sigma group associated</span>
<span class="sd">            with each template.  Shape is (:math:`N_{\rm tpl},). </span>
<span class="sd">        comp_moments (numpy.ndarray): Number of moments for each</span>
<span class="sd">            component.  Moments with negative numbers have fixed</span>
<span class="sd">            kinematics.  Shape is (:math:`N_{\rm comp},).</span>
<span class="sd">        comp_start_kin (numpy.ndarray): Array of lists where each list</span>
<span class="sd">            provdes the starting parameters for the kinematics of each</span>
<span class="sd">            component.  Shape is (:math:`N_{\rm comp},).</span>
<span class="sd">        npar_kin (int): The total number of kinematic parameters, which</span>
<span class="sd">            is just the sum of the absolute value of</span>
<span class="sd">            :attr:`comp_moments`, :math:`N_{\rm kin}`.</span>
<span class="sd">        nfree_kin (int): The total number of *free* kinematic</span>
<span class="sd">            parameters.</span>
<span class="sd">        tied (list): List of lists setting the tied parameters for the</span>
<span class="sd">            fit.  See the TIED parameter in ppxf.  Length is</span>
<span class="sd">            :math:`N_{\rm comp}`.</span>
<span class="sd">        velocity_limits (numpy.ndarray): The upper and lower velocity</span>
<span class="sd">            limits imposed by pPXF.  See</span>
<span class="sd">            :func:`mangadap.proc.ppxffit.PPXFFit.losvd_limits`.</span>
<span class="sd">        sigma_limits (numpy.ndarray): The upper and lower velocity</span>
<span class="sd">            dispersion limits imposed by pPXF.  See</span>
<span class="sd">            :func:`mangadap.proc.ppxffit.PPXFFit.losvd_limits`.</span>
<span class="sd">        gh_limits (numpy.ndarray): The upper and lower limits on *all*</span>
<span class="sd">            higher order Gauss-Hermite moments imposed by pPXF.  See</span>
<span class="sd">            :func:`mangadap.proc.ppxffit.PPXFFit.losvd_limits`.</span>
<span class="sd">        bias (float): pPXF bias parameter.  (Currently irrelevant</span>
<span class="sd">            because gas is currently always fit with moments=2.)</span>
<span class="sd">        degree (int): pPXF degree parameter setting the degree of the</span>
<span class="sd">            additive polynomials to use, :math:`o_{\rm add}`.</span>
<span class="sd">        mdegree (int): pPXF mdegree parameter setting the degree of the</span>
<span class="sd">            multiplicative polynomials to use, :math:`o_{\rm mult}`.</span>
<span class="sd">        reddening (float): pPXF reddening parameter setting the initial</span>
<span class="sd">            :math:`E(B-V)` to fit, based on a Calzetti law.</span>
<span class="sd">        reject_boxcar (int): Size of the boxcar to use when rejecting</span>
<span class="sd">            fit outliers.</span>
<span class="sd">        spectrum_start (numpy.ndarray): Array with the starting index of</span>
<span class="sd">            the pixel in the object spectra to fit (inclusive).  Shape</span>
<span class="sd">            is (:math:`N_{\rm spec}`,).</span>
<span class="sd">        spectrum_end (numpy.ndarray): Array with the ending index of the</span>
<span class="sd">            pixel in the object spectra to fit (exclusive).  Shape is</span>
<span class="sd">            (:math:`N_{\rm spec}`,)</span>
<span class="sd">        dof (int): Degrees of freedom in the fit.</span>
<span class="sd">        base_velocity (numpy.ndarray): The base velocity shift between</span>
<span class="sd">            the template and object spectra because of the difference in</span>
<span class="sd">            their starting wavelength.  Shape is (:math:`N_{\rm</span>
<span class="sd">            spec}`,).</span>

<span class="sd">    .. todo::</span>

<span class="sd">        - :attr:`velocity_limits`, :attr:`sigma_limits`, and</span>
<span class="sd">          :attr:`gh_limits` are **not** passed to ppxf during the fit.</span>
<span class="sd">          They are expected to match what&#39;s in the pPXF code.  Should</span>
<span class="sd">          change the code so that they **are** passed using pPXF&#39;s BOUND</span>
<span class="sd">          keyword.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="c1"># REMOVED</span>
<span class="c1">#        tpl_sres (:class:`mangadap.util.instrument.SpectralResolution`):</span>
<span class="c1">#            Spectral resolution of the template spectra.  All templates</span>
<span class="c1">#            are assumed to have the same spectral resolution.</span>

<span class="c1">#        gas_comp (numpy.ndarray): Boolean array set to True for</span>
<span class="c1">#            emission-line components.  Shape is (:math:`N_{\rm comp}`).</span>
<span class="c1">#        self.gas_comp = None</span>

        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sasuke&#39;</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">)</span>
        <span class="c1"># Attributes kept by SpectralFitting:</span>
        <span class="c1">#   fit_type=&#39;emission_line&#39;, bitmask=bitmask, par=None</span>
        <span class="c1"># Attributes kept by EmissionLineFit:</span>
        <span class="c1">#   fit_method=&#39;sasuke&#39;</span>

        <span class="c1"># Logging and terminal output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># Data to fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waverange</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Data to remap to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remap_sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Template data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.tpl_sres = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gas_tpl</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_tpli</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Kinematic components and tied parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_vgrp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sgrp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_start_kin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfree_kin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Fitting parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.fix_kinematics = False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="Sasuke._per_fit_dtype"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._per_fit_dtype">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_per_fit_dtype</span><span class="p">(</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">nadd</span><span class="p">,</span> <span class="n">nmult</span><span class="p">,</span> <span class="n">nkin</span><span class="p">,</span> <span class="n">mask_dtype</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data type for the result of each pPXF fit.</span>
<span class="sd">        </span>
<span class="sd">        The data are as follows:</span>
<span class="sd">            - ``BINID``: Spectrum ID number.</span>
<span class="sd">            - ``BINID_INDEX``: Index of the spectrum in the list of</span>
<span class="sd">              provided spectra.</span>
<span class="sd">            - ``NEAREST_BIN``: ID of the nearest binned spectrum when</span>
<span class="sd">              deconstructing bins.</span>
<span class="sd">            - ``MASK``: The bitmask value of the fit.  See</span>
<span class="sd">              :func:`_save_results`.</span>
<span class="sd">            - ``BEGPIX``: Same as :attr:`spectrum_start`.</span>
<span class="sd">            - ``ENDPIX``: Same as :attr:`spectrum_end`.</span>
<span class="sd">            - ``NPIXTOT``: Length of spectrum passed to pPXF</span>
<span class="sd">              (``ENDPIX-BEGPIX``)</span>
<span class="sd">            - ``NPIXFIT``: Number of pixels included in the fit</span>
<span class="sd">              (excluding rejected/masked pixels)</span>
<span class="sd">            - ``KINCMP``: The kinematic component assigned to each</span>
<span class="sd">              template.  Shape is (:math:`N_{\rm tpl}`,)</span>
<span class="sd">            - ``VELCMP``: The velocity group assigned to each template.</span>
<span class="sd">              Shape is (:math:`N_{\rm tpl}`,)</span>
<span class="sd">            - ``SIGCMP``: The sigma group assigned to each template.</span>
<span class="sd">              Shape is (:math:`N_{\rm tpl}`,)</span>
<span class="sd">            - ``USETPL``: Flag that the template was used during the</span>
<span class="sd">              fit.  Shape is (:math:`N_{\rm tpl}`,)</span>
<span class="sd">            - ``TPLWGT``: Optimal weight of each template in the fit.</span>
<span class="sd">              Shape is (:math:`N_{\rm tpl}`,)</span>
<span class="sd">            - ``ADDCOEF``: Additive polynomal coefficients.  Shape is</span>
<span class="sd">              (:math:`o_{\rm add}+1`,)</span>
<span class="sd">            - ``APLYMINMAX``: Minimum and maximum of additive</span>
<span class="sd">              polynomial.  Shape is (2,).</span>
<span class="sd">            - ``MULTCOEF``: Multiplicative polynomal coefficients.</span>
<span class="sd">              Shape is (:math:`o_{\rm mult}`,)</span>
<span class="sd">            - ``MPLYMINMAX``: Minimum and maximum of multiplicative</span>
<span class="sd">              polynomial.  Shape is (2,).</span>
<span class="sd">            - ``EBV``: Fitted E(B-V) from pPXF, if applied.</span>
<span class="sd">            - ``KININP``: Initial guess kinematics.  Shape is</span>
<span class="sd">              (:math:`N_{\rm kin}`,)</span>
<span class="sd">            - ``KIN``: Best-fitting kinematics.  Shape is (:math:`N_{\rm</span>
<span class="sd">              kin}`,)</span>
<span class="sd">            - ``KINERR``: Errors in the best-fitting kinematics.  Shape</span>
<span class="sd">              is (:math:`N_{\rm kin}`,)</span>
<span class="sd">            - ``TIEDKIN``: Index of the kinematic parameter to which</span>
<span class="sd">              each parameter is tied.  I.e., TIEDKIN[3] = 1 means that</span>
<span class="sd">              parameter 4 is tied to paramter 2.  Shape is</span>
<span class="sd">              (:math:`N_{\rm kin}`,)</span>
<span class="sd">            - ``CHI2``: Chi-square of the fit</span>
<span class="sd">            - ``RCHI2``: Reduced chi-square (recalculated after pPXF).</span>
<span class="sd">            - ``ROBUST_RCHI2``: Reduced chi-square (returned by pPXF).</span>
<span class="sd">            - ``RMS``: RMS of the fit residuals.</span>
<span class="sd">            - ``ABSRESID``: The minimum, 68%, 95%, and 99% growth, and</span>
<span class="sd">              maximum absolute residual.  Shape is (5,).</span>
<span class="sd">            - ``FRMS``: RMS of the fractional fit residuals, where the</span>
<span class="sd">              fractional residuals are (data-model)/model.</span>
<span class="sd">            - ``FABSRESID``: The minimum, 68%, 95%, and 99% growth, and</span>
<span class="sd">              maximum absolute fractional residual.  Shape is (5,).</span>

<span class="sd">        In :func:`fit`, ``BINID`` and ``BINID_INDEX`` are the same.</span>
<span class="sd">        They are not in :func:`fit_SpatiallyBinnedSpectra`.</span>

<span class="sd">        Args:</span>
<span class="sd">            ntpl (int): Number of templates, :math:`N_{\rm tpl}`.</span>
<span class="sd">            nadd (int): Number of additive polynomial coefficents,</span>
<span class="sd">                :math:`o_{\rm add}+1`.</span>
<span class="sd">            nmult (int): Number of multiplicative polynomial</span>
<span class="sd">                coefficients, :math:`o_{\rm mult}`.</span>
<span class="sd">            nkin (int): Number of kinematic parameters, :math:`N_{\rm</span>
<span class="sd">                kin}`.</span>
<span class="sd">            mask_dtype (dtype): Type for the bitmask variable.  See</span>
<span class="sd">                :func:`mangadap.util.bitmask.BitMask.minimum_dtype`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of tuples with the name and type of each element</span>
<span class="sd">            in the array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;BINID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">mask_dtype</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NPIXTOT&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;KINCMP&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,(</span><span class="n">ntpl</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;VELCMP&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,(</span><span class="n">ntpl</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;SIGCMP&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,(</span><span class="n">ntpl</span><span class="p">,)),</span>
<span class="c1">#                 (&#39;USETPL&#39;,numpy.bool,(ntpl,)),</span>
                 <span class="p">(</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">ntpl</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;TPLWGTERR&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">ntpl</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nadd</span><span class="p">,))</span> <span class="k">if</span> <span class="n">nadd</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;APLYMINMAX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,))</span> <span class="k">if</span> <span class="n">nadd</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;APLYMINMAX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nmult</span><span class="p">,))</span> <span class="k">if</span> <span class="n">nmult</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MPLYMINMAX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">2</span><span class="p">,))</span> <span class="k">if</span> <span class="n">nmult</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;MPLYMINMAX&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;EBV&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;KININP&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nkin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;KIN&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nkin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;KINERR&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="n">nkin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;TIEDKIN&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">,(</span><span class="n">nkin</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;CHI2&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;RCHI2&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
<span class="c1">#                 (&#39;ROBUST_RCHI2&#39;,numpy.float),</span>
                 <span class="p">(</span><span class="s1">&#39;RMS&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ABSRESID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">5</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;FRMS&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;FABSRESID&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,(</span><span class="mi">5</span><span class="p">,))</span>
               <span class="p">]</span> </div>


<div class="viewcode-block" id="Sasuke.etpl_line_sigma_options"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke.etpl_line_sigma_options">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">etpl_line_sigma_options</span><span class="p">():</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Keyword options for the mode used to set the standard deviation</span>
<span class="sd">        of the emission lines the the emission-line templates.  Possible</span>
<span class="sd">        modes are:</span>

<span class="sd">            ``default``: In order of precedence: </span>
<span class="sd">                - Use the spectral resolution of the observed spectra, or</span>
<span class="sd">                - use the spectral resolution of the stellar templates, or</span>
<span class="sd">                - adopt a FWHM of 2 pixels and calculate the resolution</span>
<span class="sd">                  assuming a Gaussian line profile.</span>

<span class="sd">            ``zero``:  The width of all lines is set to 0.  The function</span>
<span class="sd">                from :mod:`mangadap.util.lineprofiles` used to construct</span>
<span class="sd">                the line *must* be able to produce the line if the</span>
<span class="sd">                standard deviation is 0!</span>

<span class="sd">            ``offset``: Apply a quadrature offset of the</span>
<span class="sd">                wavelength-dependent trend of the instrumental</span>
<span class="sd">                dispersion resulting from the ``default`` mode such that</span>
<span class="sd">                the minimum instrumental dispersion is 0.  Note that the</span>
<span class="sd">                minimum dispersion can be set to something other than 0</span>
<span class="sd">                using either the `etpl_line_sigma_min` parameter in</span>
<span class="sd">                :class:`SasukePar` or the keyword argument in</span>
<span class="sd">                :func:`Sasuke.fit`.  If the minimum dispersion is 0, the</span>
<span class="sd">                function from :mod:`mangadap.util.lineprofiles` used to</span>
<span class="sd">                construct the line *must* be able to produce a line with</span>
<span class="sd">                a standard deviation of 0!</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of allowed options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="Sasuke._check_remapping_coordinates"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._check_remapping_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">_check_remapping_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_skyx</span><span class="p">,</span> <span class="n">obj_skyy</span><span class="p">,</span> <span class="n">remap_skyx</span><span class="p">,</span> <span class="n">remap_skyy</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">obj_skyx</span><span class="p">,</span> <span class="n">obj_skyy</span><span class="p">,</span> <span class="n">remap_skyx</span><span class="p">,</span> <span class="n">remap_skyy</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If remapping, must provide all on-sky positions.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_skyx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Object spectra coordinates must be a vector.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_skyx</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Object sky coordinates to not match the number of spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_skyx</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">obj_skyy</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch of object x and y coordinate shapes.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remap_skyx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Remapping coordinates must be a vector.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remap_skyx</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Remapping sky coordinates to not match the number of spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remap_skyx</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">remap_skyy</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch of the remapping x and y coordinate shapes.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_skyx</span><span class="p">,</span> <span class="n">obj_skyy</span><span class="p">,</span> <span class="n">remap_skyx</span><span class="p">,</span> <span class="n">remap_skyy</span></div>


<span class="c1">#    def _run_fit_iteration(self, obj_flux, obj_ferr, obj_to_fit, weight_errors=False,</span>
<span class="c1">#                           component_fits=False, plot=False):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Execute a specific fit iteration.  This is used by</span>
<span class="c1">#        :func:`_fit_all_spectra` to run through as set of fit</span>
<span class="c1">#        iterations.  All spectra in *obj_flux* are fit with a specific</span>
<span class="c1">#        set of ppxf parameters.  Additional iteration modes can be added</span>
<span class="c1">#        by including new arguments to the function.</span>
<span class="c1">#        </span>
<span class="c1">#        Args:</span>
<span class="c1">#            obj_flux (`numpy.ma.MaskedArray`_): Object spectra to fit</span>
<span class="c1">#                **for this iteration**.  Different from</span>
<span class="c1">#                :attr:`obj_flux`.</span>
<span class="c1">#            obj_ferr (`numpy.ma.MaskedArray`_): Error in spectra to fit</span>
<span class="c1">#                **for this iteration**.  Different from</span>
<span class="c1">#                :attr:`obj_flux`.</span>
<span class="c1">#            obj_to_fit (numpy.ndarray): Boolean array to fit each</span>
<span class="c1">#                spectrum.</span>
<span class="c1">#            weight_errors (bool): (**Optional**) Flag to calculate and</span>
<span class="c1">#                assign errors in the weights; see</span>
<span class="c1">#                :class:`mangadap.proc.ppxffit.PPXFFitResult`.</span>
<span class="c1">#            component_fits (bool): (**Optional**) Flag to construct the</span>
<span class="c1">#                optimal fit for each kinematic component.  This is used</span>
<span class="c1">#                to construct the best-fitting emission-line model in</span>
<span class="c1">#                :func:`_emission_line_only_model`; see</span>
<span class="c1">#                :class:`mangadap.proc.ppxffit.PPXFFitResult`.</span>
<span class="c1">#            plot (bool): (**Optional**) Passed to</span>
<span class="c1">#                :class:`mangadap.contrib.ppxf.ppxf` to construct a plot</span>
<span class="c1">#                showing the result **of each fit**.  Should only used</span>
<span class="c1">#                when debugging.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            numpy.ndarray : Array with :math:`N_{\rm spec}` instances of</span>
<span class="c1">#            :class:`mangadap.proc.ppxffit.PPXFFitResult`.</span>
<span class="c1">#</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">##        linear = fix_kinematics and mdegree &lt; 1</span>
<span class="c1">#        linear = False</span>
<span class="c1">#</span>
<span class="c1">#        # Create the object to hold all the fits</span>
<span class="c1">#        result = numpy.empty(self.nobj, dtype=object)</span>
<span class="c1">#</span>
<span class="c1">#        # Fit each spectrum</span>
<span class="c1">#        for i in range(self.nobj):</span>
<span class="c1">#            print(&#39;Running pPXF fit on spectrum: {0}/{1}&#39;.format(i+1,self.nobj), end=&#39;\r&#39;)</span>
<span class="c1">#            # Meant to ignore this spectrum</span>
<span class="c1">#            if not obj_to_fit[i]:</span>
<span class="c1">#                result[i] = None</span>
<span class="c1">#                continue</span>
<span class="c1">#</span>
<span class="c1">#            # Get the pixels to fit for this spectrum</span>
<span class="c1">#            gpm = numpy.where( ~ (obj_flux.mask[i, self.spectrum_start[i]:self.spectrum_end[i]]) )[0]</span>
<span class="c1">#</span>
<span class="c1">#            # Check if there is sufficient data for the fit</span>
<span class="c1">#            ntpl_to_use = numpy.sum(self.tpl_to_use[i,:])</span>
<span class="c1">#            if len(gpm) &lt; self.dof+ntpl_to_use:</span>
<span class="c1">#                if not self.quiet:                                        </span>
<span class="c1">#                    warnings.warn(&#39;Insufficient data points ({0}) to fit spectrum {1}&#39;</span>
<span class="c1">#                                  &#39;(dof={2}).&#39;.format(len(gpm), i+1, self.dof+ntpl_to_use))</span>
<span class="c1">#                # Declare an empty PPXFFitResult</span>
<span class="c1">#                result[i] = PPXFFitResult(self.degree, self.mdegree, self.spectrum_start[i],</span>
<span class="c1">#                                          self.spectrum_end[i], self.tpl_to_use[i,:],</span>
<span class="c1">#                                          None, self.ntpl)</span>
<span class="c1">#                continue</span>
<span class="c1">#</span>
<span class="c1">#            # Clear any existing plot data</span>
<span class="c1">#            if plot:</span>
<span class="c1">#                pyplot.clf()</span>
<span class="c1">#</span>
<span class="c1">#            # Run ppxf</span>
<span class="c1">#            ppxf_fit = ppxf(self.tpl_flux[self.tpl_to_use[i,:],:].T,</span>
<span class="c1">#                            obj_flux.data[i,self.spectrum_start[i]:self.spectrum_end[i]],</span>
<span class="c1">#                            obj_ferr.data[i,self.spectrum_start[i]:self.spectrum_end[i]],</span>
<span class="c1">#                            self.velscale, self.comp_start_kin[i].tolist(), bias=self.bias, </span>
<span class="c1">#                            component=self.tpl_comp[self.tpl_to_use[i,:]], degree=self.degree,</span>
<span class="c1">#                            goodpixels=gpm, linear=linear, mdegree=self.mdegree,</span>
<span class="c1">#                            moments=self.comp_moments, plot=plot, quiet=(not plot),</span>
<span class="c1">#                            templates_rfft=self.tpl_rfft[self.tpl_to_use[i,:],:].T,</span>
<span class="c1">#                            tied=self.tied, velscale_ratio=self.velscale_ratio,</span>
<span class="c1">#                            vsyst=-self.base_velocity[i])</span>
<span class="c1">#            # Save result</span>
<span class="c1">#            result[i] = PPXFFitResult(self.degree, self.mdegree, self.spectrum_start[i],</span>
<span class="c1">#                                      self.spectrum_end[i], self.tpl_to_use[i,:],</span>
<span class="c1">#                                      ppxf_fit, self.ntpl, weight_errors=weight_errors,</span>
<span class="c1">#                                      component_fits=component_fits)</span>
<span class="c1">#</span>
<span class="c1">#            # TODO: check output</span>
<span class="c1">##            if result[i].kin[1] &lt; 0:</span>
<span class="c1">##                result[i].kin[1] = numpy.absolute(result[i].kin[1]) #self.sigma_limits[0]</span>
<span class="c1">##                warnings.warn(&#39;pPXF gives negative dispersion! Change -{0:.4f} to {0:.4f}&#39;.format(</span>
<span class="c1">##                                    result[i].kin[1]))</span>
<span class="c1">#                </span>
<span class="c1">#            if result[i].reached_maxiter() and not self.quiet:</span>
<span class="c1">#                warnings.warn(&#39;pPXF optimizer reached maximum number of iterations for spectrum &#39;</span>
<span class="c1">#                              &#39;{0}.&#39;.format(i+1))</span>
<span class="c1">#            if plot:</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        print(&#39;Running pPXF fit on spectrum: {0}/{0}&#39;.format(self.nobj))</span>
<span class="c1">#        return result</span>


<span class="c1">#    def _fit_all_spectra(self, plot=False): #, plot_file_root=None):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Fit all spectra contained by the class instance</span>
<span class="c1">#        (:attr:`obj_flux`) using an optimized set of iterations.  For</span>
<span class="c1">#        example, see</span>
<span class="c1">#        :func:`mangadap.proc.ppxffit.PPXFFit._fit_all_spectra()`.</span>
<span class="c1">#        </span>
<span class="c1">#        Args:</span>
<span class="c1">#            plot (bool): (**Optional**) Passed to</span>
<span class="c1">#                :class:`mangadap.contrib.ppxf.ppxf` to construct a plot</span>
<span class="c1">#                showing the result of **each fit** during **each fit</span>
<span class="c1">#                iteration**.  Should only used when debugging.</span>
<span class="c1">#        </span>
<span class="c1">#        Returns:</span>
<span class="c1">#            numpy.ndarray : Array with :math:`N_{\rm spec}` instances of</span>
<span class="c1">#            :class:`mangadap.proc.ppxffit.PPXFFitResult`.</span>
<span class="c1">#        </span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        run_rejection = self.reject_boxcar is not None</span>
<span class="c1">#        #---------------------------------------------------------------</span>
<span class="c1">#        # Fit the spectra</span>
<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO,</span>
<span class="c1">#                       &#39;Number of object spectra to fit: {0}/{1}&#39;.format(</span>
<span class="c1">#                            numpy.sum(self.obj_to_fit), len(self.obj_to_fit)))</span>
<span class="c1">#        result = self._run_fit_iteration(self.obj_flux, self.obj_ferr, self.obj_to_fit,</span>
<span class="c1">#                                         weight_errors=(not run_rejection),</span>
<span class="c1">#                                         component_fits=(not run_rejection), plot=plot)</span>
<span class="c1">#        if not run_rejection:</span>
<span class="c1">#            # Only a single fit so return</span>
<span class="c1">#            return result</span>
<span class="c1">#</span>
<span class="c1">#        #---------------------------------------------------------------</span>
<span class="c1">#        # Rejection iteration</span>
<span class="c1">#</span>
<span class="c1">#        # Copy the input as to not overwrite the input masks</span>
<span class="c1">#        obj_flux = self.obj_flux.copy()</span>
<span class="c1">#        obj_ferr = self.obj_ferr.copy()</span>
<span class="c1">#        obj_to_fit = self.obj_to_fit.copy()</span>
<span class="c1">#</span>
<span class="c1">#        # Save which were not fit successfully</span>
<span class="c1">#        obj_to_fit &amp;= numpy.invert(numpy.array([ r is None or r.fit_failed() for r in result ]))</span>
<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO,</span>
<span class="c1">#                       &#39;Number of object spectra to fit (excluding failed fits): {0}/{1}&#39;.format(</span>
<span class="c1">#                            numpy.sum(self.obj_to_fit), len(self.obj_to_fit)))</span>
<span class="c1">#</span>
<span class="c1">#        # Reject model outliers</span>
<span class="c1">#        obj_flux = PPXFFit.reject_model_outliers(obj_flux, result, rescale=False,</span>
<span class="c1">#                                                 local_sigma=True, boxcar=self.reject_boxcar,</span>
<span class="c1">#                                                 loggers=self.loggers, quiet=self.quiet)</span>
<span class="c1">#        obj_ferr[numpy.ma.getmaskarray(obj_flux)] = numpy.ma.masked</span>
<span class="c1">#</span>
<span class="c1">#        # Return results of refit (only ever do one rejection iteration)</span>
<span class="c1">#        return self._run_fit_iteration(obj_flux, obj_ferr, obj_to_fit, weight_errors=True,</span>
<span class="c1">#                                       component_fits=True, plot=plot)</span>
<span class="c1">#</span>
<span class="c1">##        if not self.quiet:</span>
<span class="c1">##            log_output(self.loggers, 1, logging.INFO,</span>
<span class="c1">##                       &#39;Number of object spectra to fit: {0}/{1}&#39;.format(</span>
<span class="c1">##                            numpy.sum(self.obj_to_fit), len(self.obj_to_fit)))</span>
<span class="c1">##        result = self._run_fit_iteration(self.obj_flux, self.obj_ferr, self.obj_to_fit,</span>
<span class="c1">##                                         weight_errors=True,</span>
<span class="c1">##                                         component_fits=True, plot=plot)</span>
<span class="c1">##        return result</span>


<span class="c1">#    def _emission_line_only_model(self, result):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Given the set of :class:`mangadap.proc.ppxf.PPXFFitResult`</span>
<span class="c1">#        instances resulting from the fit to all object spectra,</span>
<span class="c1">#        construct the best-fitting models that only include the model</span>
<span class="c1">#        emission lines.  The :class:`mangadap.proc.ppxf.PPXFFitResult`</span>
<span class="c1">#        instances must have had the best-fitting components constructed</span>
<span class="c1">#        when instantiated (declared with `component_fits=True`); the</span>
<span class="c1">#        &#39;best-fitting components&#39; are the templates weighted and</span>
<span class="c1">#        modified by any fitted multiplicative polynomial.  See</span>
<span class="c1">#        :func:`_run_fit_iteration` and :func:`_save_results`.</span>
<span class="c1">#</span>
<span class="c1">#        Args:</span>
<span class="c1">#            result (numpy.ndarray): An array of</span>
<span class="c1">#                :class:`mangadap.proc.ppxffit.PPXFFitResult` instances</span>
<span class="c1">#                with the result of the fits to each object spectrum.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            `numpy.ma.MaskedArray`_: A masked array with shape</span>
<span class="c1">#            :math:`(N_{\rm spec},N_{\rm pix})` with the best-fitting</span>
<span class="c1">#            emission-line-only model.  All pixels between</span>
<span class="c1">#            :attr:`spectrum_start` and :attr:`spectrum_end` are not</span>
<span class="c1">#            masked.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # Models originally fully masked</span>
<span class="c1">#        model_eml_flux = numpy.ma.MaskedArray(numpy.zeros(self.obj_flux.shape, dtype=float),</span>
<span class="c1">#                                              mask=numpy.ones(self.obj_flux.shape, dtype=bool))</span>
<span class="c1">#        for i in range(self.nobj):</span>
<span class="c1">#            if result[i] is None or result[i].fit_failed():</span>
<span class="c1">#                continue</span>
<span class="c1">#            s = result[i].start</span>
<span class="c1">#            e = result[i].end</span>
<span class="c1">#            # Sum all the emission-line components</span>
<span class="c1">#            model_eml_flux[i,s:e] = numpy.sum(result[i].bestfit_comp[self.gas_comp,:], axis=0)</span>
<span class="c1">#        return model_eml_flux</span>


<div class="viewcode-block" id="Sasuke._is_near_bounds"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._is_near_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">_is_near_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">kin_inp</span><span class="p">,</span> <span class="n">vel_indx</span><span class="p">,</span> <span class="n">sig_indx</span><span class="p">,</span> <span class="n">lbound</span><span class="p">,</span> <span class="n">ubound</span><span class="p">,</span> <span class="n">tol_frac</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=-</span><span class="mf">999.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the kinematics were fit and near the imposed limits.</span>

<span class="sd">        Any value that is close to ``fill_value`` is flagged as not</span>
<span class="sd">        having been fit, presumably because too much/all of the data</span>
<span class="sd">        near the emission line is masked.</span>
<span class="sd">        </span>
<span class="sd">        The definition of &quot;near&quot; is that the velocity and higher moments</span>
<span class="sd">        cannot be closer than the provided fraction of the total width</span>
<span class="sd">        to the boundary.  For the velocity dispersion, the fraction is</span>
<span class="sd">        done in log space.</span>

<span class="sd">        Args:</span>
<span class="sd">            kin (numpy.ndarray): Best-fitting kinematic parameters.</span>
<span class="sd">                Shape should be :math:`(N_{\rm spec},N_{\rm kin})`.</span>
<span class="sd">            kin_inp (numpy.ndarray): The initial guesses for the</span>
<span class="sd">                best-fitting kinematics.  This is needed because the</span>
<span class="sd">                velocity limits are set relative to the input guess.</span>
<span class="sd">                Shape should be :math:`(N_{\rm spec},N_{\rm kin})`.</span>
<span class="sd">            vel_index (numpy.ndarray): Boolean array setting if the</span>
<span class="sd">                parameter is a velocity.  This is needed because the</span>
<span class="sd">                velocity limits are set relative to the input guess.</span>
<span class="sd">            sig_index (numpy.ndarray): Boolean array setting if the</span>
<span class="sd">                parameter is a velocity dispersion.  This is needed</span>
<span class="sd">                because the proximity to the bounds is logarithmic for</span>
<span class="sd">                the velocity dispersion.</span>
<span class="sd">            lbound (numpy.ndarray): Lower bound on each parameter.</span>
<span class="sd">            ubound (numpy.ndarray): Upper bound on each parameter.</span>
<span class="sd">            tol_frac (float): (**Optional**) The fractional tolerance</span>
<span class="sd">                for classifying the returned parameter and near the</span>
<span class="sd">                boundary.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Three boolean arrays that flag if (1) the</span>
<span class="sd">            parameter is near either boundary, (2) the parameter is near</span>
<span class="sd">            the lower boundary, and (3) the parameter is near the</span>
<span class="sd">            fill_value.  The second array is important in case the</span>
<span class="sd">            fitted parameter is a velocity dispersion and that it&#39;s near</span>
<span class="sd">            the lower boundary because it has hit the pixel sampling</span>
<span class="sd">            limit.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">kin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="c1"># Number of spectra fit</span>

        <span class="c1"># Offset velocity: bounded by *deviations* from input value</span>
        <span class="n">_lbound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lbound</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">_ubound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ubound</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">_lbound</span><span class="p">[:,</span><span class="n">vel_indx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kin_inp</span><span class="p">[:,</span><span class="n">vel_indx</span><span class="p">]</span>
        <span class="n">_ubound</span><span class="p">[:,</span><span class="n">vel_indx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kin_inp</span><span class="p">[:,</span><span class="n">vel_indx</span><span class="p">]</span>

        <span class="c1"># Set the tolerance</span>
        <span class="n">Db</span> <span class="o">=</span> <span class="n">_ubound</span><span class="o">-</span><span class="n">_lbound</span>
        <span class="n">Db</span><span class="p">[:,</span><span class="n">sig_indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">_ubound</span><span class="p">[:,</span><span class="n">sig_indx</span><span class="p">])</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">_lbound</span><span class="p">[:,</span><span class="n">sig_indx</span><span class="p">])</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">Db</span><span class="o">*</span><span class="n">tol_frac</span>

        <span class="c1"># Determine if the parameter is near the lower boundary (only</span>
        <span class="c1"># relevant to the sigma) ... </span>
        <span class="n">near_lower_bound</span> <span class="o">=</span> <span class="n">kin</span> <span class="o">-</span> <span class="n">_lbound</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="c1"># and whether it&#39;s close to either</span>
        <span class="n">near_bound</span> <span class="o">=</span> <span class="n">near_lower_bound</span> <span class="o">|</span> <span class="p">(</span><span class="n">_ubound</span> <span class="o">-</span> <span class="n">kin</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># Determine if the parameter is near the fill value indicating</span>
        <span class="c1"># that it was not included in the fit</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-5</span>                      <span class="c1"># !! HARDCODED !!</span>
        <span class="n">no_data</span> <span class="o">=</span> <span class="n">kin</span> <span class="o">-</span> <span class="n">fill_value</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="c1"># If the parameter was not fit, parameter not near any boundary</span>
        <span class="n">near_bound</span><span class="p">[</span><span class="n">no_data</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">near_lower_bound</span><span class="p">[</span><span class="n">no_data</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">#        for k,b,l,f in zip(kin[0], near_bound[0], near_lower_bound[0], no_data[0]):</span>
<span class="c1">#            print(k,b,l,f)</span>

        <span class="c1"># Return the two boundary flags</span>
        <span class="k">return</span> <span class="n">near_bound</span><span class="p">,</span> <span class="n">near_lower_bound</span><span class="p">,</span> <span class="n">no_data</span></div>


<div class="viewcode-block" id="Sasuke._validate_dispersions"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._validate_dispersions">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_dispersions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">400</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the corrected velocity dispersion are in the provided</span>
<span class="sd">        range.</span>

<span class="sd">        (FB) More flagging of kinematic paramters. DOES THIS APPLY TO</span>
<span class="sd">        EMISSION LINES? (KBW): Yes.  The corrected dispsersion must be</span>
<span class="sd">        larger than 0 and less than 400 km/s.  It&#39;s easy to turn this</span>
<span class="sd">        off or change the limits.</span>

<span class="sd">        (KBW) Currently not called...</span>

<span class="sd">        Args:</span>
<span class="sd">            model_eml_par (`numpy.recarray`_): Record array with the</span>
<span class="sd">                parameters measured for each emission line.  See</span>
<span class="sd">                :func:`mangadap.proc.spectralfitting.EmissionLineFit._per_emission_line_dtype`.</span>
<span class="sd">            rng (list): (**Optional**) Two-element list with the minimum</span>
<span class="sd">                and maximum allowed *corrected* velocity dispersion.</span>
<span class="sd">                Measurements outside this range are flagged as</span>
<span class="sd">                ``BAD_SIGMA``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `numpy.recarray`_: Returns the input record array with any</span>
<span class="sd">            additional flags.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_rng</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">_fit_eml</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">_fit_eml</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sigcor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,:,</span><span class="mi">1</span><span class="p">])</span> \
                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">][:,:])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">((</span><span class="n">sigcor</span> <span class="o">&lt;</span> <span class="n">_rng</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">sigcor</span> <span class="o">&gt;</span> <span class="n">_rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="n">_fit_eml</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;BAD_SIGMA&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_eml_par</span></div>


<div class="viewcode-block" id="Sasuke._reset_to_fill_value"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._reset_to_fill_value">[docs]</a>    <span class="k">def</span> <span class="nf">_reset_to_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mf">999.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset all the emission lines masked as having insufficient data</span>
<span class="sd">        to fit to the provided fill value.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The error values are currently reset to 0. by</span>
<span class="sd">            :class:`mangadap.proc.emissionlinemodel.EmissionLineModel.`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMAINST&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMATPL&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTAPLY&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTRFIT&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">model_eml_par</span></div>


<div class="viewcode-block" id="Sasuke._save_results"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke._save_results">[docs]</a>    <span class="k">def</span> <span class="nf">_save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">etpl</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span>
                      <span class="n">model_wgts</span><span class="p">,</span> <span class="n">model_wgts_err</span><span class="p">,</span> <span class="n">model_addcoef</span><span class="p">,</span> <span class="n">model_multcoef</span><span class="p">,</span> <span class="n">model_reddening</span><span class="p">,</span>
                      <span class="n">model_kin_inp</span><span class="p">,</span> <span class="n">model_kin</span><span class="p">,</span> <span class="n">model_kin_err</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span>
                      <span class="n">fill_value</span><span class="o">=-</span><span class="mf">999.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save and assess the results of the ppxf fits.</span>
<span class="sd">        </span>
<span class="sd">        The results are saved both as the direct output from pPXF and</span>
<span class="sd">        after parsing the data into the results for each emission line.</span>
<span class="sd">        The function also assesses the data to set any necessary flags.</span>
<span class="sd">        Much of this is the same as</span>
<span class="sd">        :class:`mangadap.proc.ppxffit.PPXFFit._save_results`.</span>

<span class="sd">        Args:</span>
<span class="sd">            etpl (:class:`EmissionLineTemplates`): The object used to</span>
<span class="sd">                construct and hold the emission-line templates.</span>
<span class="sd">            result (numpy.ndarray): An array of</span>
<span class="sd">                :class:`mangadap.proc.ppxffit.PPXFFitResult` instances</span>
<span class="sd">                with the result of the fits to each object spectrum.</span>
<span class="sd">            model_mask (numpy.ndarray): The array of bitmask values</span>
<span class="sd">                associated with spectral fitting flags.  Shape is</span>
<span class="sd">                :math:`(N_{\rm spec}, N_{\rm pix})`.</span>
<span class="sd">            model_fit_par (`numpy.recarray`_): Record array with the</span>
<span class="sd">                dtype as defined by :func:`_per_fit_dtype` that holds</span>
<span class="sd">                the ppxf output.</span>
<span class="sd">            model_eml_par (`numpy.recarray`_): Record array with the</span>
<span class="sd">                individual emission-line data; see</span>
<span class="sd">                :func:`mangadap.proc.spectralfitting.EmissionLineFit._per_emission_line_dtype`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, numpy.recarray: The function returns: (1) the</span>
<span class="sd">            best-fitting model spectra, (2) the best-fitting</span>
<span class="sd">            emission-line only spectra, (3) the bitmask values, (4) the</span>
<span class="sd">            per spectrum ppxf result, and (5) the per spectrum</span>
<span class="sd">            emission-line parameters.   The first 3 returned objects are</span>
<span class="sd">            of type numpy.ndarray and have shape :math:`(N_{\rm spec},</span>
<span class="sd">            N_{\rm pix})`; the last two are numpy.recarray instances</span>
<span class="sd">            with shape :math:`(N_{\rm spec},)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate some convenience data:</span>
        <span class="c1">#  - Generate vectors with the lower and upper bounds for the</span>
        <span class="c1">#    kinematic parameters (lbound, ubound)</span>
        <span class="c1">#  - Get the list of indices in the flatted kinematics vectors</span>
        <span class="c1">#    with the *unfixed*, *defining* parameters used for each</span>
        <span class="c1">#    kinematic measurement.  These are used to set the</span>
        <span class="c1">#    kinematics and errors for each emission line. (par_indx)</span>
        <span class="c1">#  - Flag parameters that are velocity (vel_indx) and sigma</span>
        <span class="c1">#    components (sig_indx)</span>
        <span class="n">lboundi</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">uboundi</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">lbound</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ubound</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">par_indx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vel_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">sig_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[:</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">nmom</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">par_indx</span> <span class="o">+=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nmom</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmom</span><span class="p">):</span>
                <span class="n">par_indx</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span><span class="o">+</span><span class="n">k</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> \
                                            <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">vel_indx</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sig_indx</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lbound</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">lboundi</span><span class="p">[:</span><span class="n">nmom</span><span class="p">]</span> <span class="p">]</span>
            <span class="n">ubound</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">uboundi</span><span class="p">[:</span><span class="n">nmom</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">lbound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lbound</span><span class="p">))</span>
        <span class="n">ubound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ubound</span><span class="p">))</span>

<span class="c1">#        print(self.tpl_comp)</span>
<span class="c1">#        print(self.tpl_vgrp)</span>
<span class="c1">#        print(self.tpl_sgrp)</span>
<span class="c1">#        print(lbound)</span>
<span class="c1">#        print(ubound)</span>
<span class="c1">#        print(numpy.concatenate(tuple(par_indx)))</span>

        <span class="c1"># Set the model data to masked arrays</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">model_eml_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">model_eml_flux</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">#        pyplot.imshow(numpy.log10(model_flux), origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#        pyplot.colorbar()</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Save the pixel statistics</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXTOT&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate the model residuals, which are masked where the data</span>
        <span class="c1"># were not fit</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">-</span> <span class="n">model_flux</span>
        <span class="n">fractional_residual</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">flux</span> <span class="o">-</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">)</span>
        <span class="c1"># Get the (reduced) chi-square for each spectrum</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">residual</span><span class="o">/</span><span class="n">ferr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Get the (fractional) residual RMS for each spectrum</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;RMS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">residual</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FRMS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fractional_residual</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="c1">#        print(model_fit_par[&#39;CHI2&#39;])</span>

        <span class="c1"># Reduced chi-square</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;RCHI2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">]</span> 
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="c1">#        print(model_fit_par[&#39;RCHI2&#39;])</span>

        <span class="c1"># Save the weights and errors</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_wgts</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGTERR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_wgts_err</span>

        <span class="c1"># The set of gas templates, and the kinematic component,</span>
        <span class="c1"># velocity group, and sigma group associated with each</span>
        <span class="c1"># template are the same for all fits</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINCMP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;VELCMP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_vgrp</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;SIGCMP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_sgrp</span><span class="p">]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TIEDKIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">par_indx</span><span class="p">))]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>

        <span class="c1"># Save the polynomial coefficients</span>
        <span class="n">used_apoly</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">model_addcoef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_addcoef</span>
            <span class="n">used_apoly</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">used_mpoly</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">model_multcoef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_multcoef</span>
            <span class="n">used_mpoly</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">used_ebv</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">model_reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;EBV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_reddening</span>
            <span class="n">used_ebv</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Flattened input and output kinematics</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_kin_inp</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_kin</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_kin_err</span>

        <span class="c1"># Test if the kinematics are near the imposed boundaries.</span>
        <span class="n">near_bound</span><span class="p">,</span> <span class="n">near_lower_bound</span><span class="p">,</span> <span class="n">no_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_near_bounds</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">],</span>
                                                                     <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">],</span>
                                                                     <span class="n">vel_indx</span><span class="p">,</span> <span class="n">sig_indx</span><span class="p">,</span> <span class="n">lbound</span><span class="p">,</span>
                                                                     <span class="n">ubound</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># Flag the fit *globally*</span>
        <span class="c1"># - If the velocity dispersion has hit the lower limit for all</span>
        <span class="c1">#   lines, ONLY flag the value as having a MIN_SIGMA.</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">near_lower_bound</span> <span class="o">&amp;</span> <span class="n">sig_indx</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span>
                                                               <span class="s1">&#39;MIN_SIGMA&#39;</span><span class="p">)</span>

        <span class="c1"># - Otherwise, flag the full fit (parameters and model) as</span>
        <span class="c1">#   NEAR_BOUND if all the parameters are near the boundary but</span>
        <span class="c1">#   not the lower sigma boundary</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="p">(</span><span class="n">near_lower_bound</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sig_indx</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:])</span>
                            <span class="o">|</span> <span class="p">(</span><span class="n">near_bound</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">near_lower_bound</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span>
                                                               <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:],</span> <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>

        <span class="c1"># - If no_data is all true for any one spectrum, the ppxf fitter</span>
        <span class="c1"># should have raised an error.</span>

        <span class="c1"># Convert the velocities from pixel units to cz</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">],</span> <span class="n">_</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">],</span>
                                               <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vel_indx</span><span class="p">)))</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">],</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">],</span>
                                               <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="n">vel_indx</span><span class="p">])</span>

        <span class="c1"># Divvy up the fitted parameters into the result for each</span>
        <span class="c1"># emission line</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">continue</span>
<span class="c1">#            print(self.emldb[&#39;name&#39;][j], self.emldb[&#39;restwave&#39;][j], self.emldb[&#39;flux&#39;][j],</span>
<span class="c1">#                  self.eml_tpli[j], result[i].tplwgt[self.eml_tpli[j]])</span>
<span class="c1">#            pyplot.plot(self.tpl_wave, self.tpl_flux[self.eml_tpli[j],:])</span>
<span class="c1">#            pyplot.show()</span>

            <span class="c1"># The &quot;fit index&quot; is the component of the line</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FIT_INDEX&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># Use the flattened vectors to set the kinematics</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">par_indx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">indx</span><span class="p">]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="n">indx</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># Use the fitted weights to set the gas flux; the</span>
            <span class="c1"># EmissionLineTemplates class constructs each line to have</span>
            <span class="c1"># the flux provided by the emission-line database in the</span>
            <span class="c1"># rest frame.  The ppxf convolution keeps the sum of the</span>
            <span class="c1"># template constant, meaning that the total flux in the line</span>
            <span class="c1"># increases with redshift.</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][:,</span><span class="bp">self</span><span class="o">.</span><span class="n">eml_tpli</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> \
                                            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;FLUXERR&#39;</span><span class="p">][:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGTERR&#39;</span><span class="p">][:,</span><span class="bp">self</span><span class="o">.</span><span class="n">eml_tpli</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> \
                                                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>

            <span class="c1"># Get the bound masks specific to this emission-line (set)</span>
            <span class="c1"># - Determine if the emission-line was part of a rejected</span>
            <span class="c1"># template</span>
            <span class="n">flg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">no_data</span><span class="p">[:,</span><span class="n">indx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                    <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>

            <span class="c1"># - Determine if the velocity dispersion parameter of this</span>
            <span class="c1">#   line has hit the lower limit; if so, ONLY flag the value</span>
            <span class="c1">#   as having a MIN_SIGMA.</span>
            <span class="n">flg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">near_lower_bound</span><span class="p">[:,</span><span class="n">indx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">sig_indx</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                    <span class="s1">&#39;MIN_SIGMA&#39;</span><span class="p">)</span>

            <span class="c1"># - Determine if any of the kinematic parameters are near</span>
            <span class="c1">#   the bound (excluding the lower velocity dispersion</span>
            <span class="c1">#   limit)</span>
            <span class="n">flg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">near_lower_bound</span><span class="p">[:,</span><span class="n">indx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sig_indx</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="n">indx</span><span class="p">])</span>
                                <span class="o">|</span> <span class="p">(</span><span class="n">near_bound</span><span class="p">[:,</span><span class="n">indx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">near_lower_bound</span><span class="p">[:,</span><span class="n">indx</span><span class="p">])),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">flg</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>
                                                                    <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>

        <span class="c1"># Flag the pixels that were not used</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="n">flux</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">flux</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

        <span class="c1"># Mask any lines that were not fit</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">)]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">)],</span>
                                           <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Iterate over each spectrum</span>
        <span class="n">poly_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
        <span class="n">sres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_sres</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>

            <span class="c1"># Get growth statistics for the residuals</span>
            <span class="c1"># TODO: Specifically around the emission lines?</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ABSRESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span>
                                                           <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.68</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;FABSRESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> \
                        <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fractional_residual</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span>
                                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.68</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">used_apoly</span> <span class="ow">or</span> <span class="n">used_mpoly</span> <span class="ow">or</span> <span class="n">used_ebv</span><span class="p">:</span>
                <span class="c1"># Sample the polynomials at the fitted wavelength of</span>
                <span class="c1"># each line</span>
                <span class="n">obswave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> \
                                    <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                                                <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># - Additive polynomial:</span>
                <span class="k">if</span> <span class="n">used_apoly</span><span class="p">:</span>
                    <span class="n">apoly</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">poly_x</span><span class="p">,</span>
                                                             <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">model_addcoef</span><span class="p">[</span><span class="n">i</span><span class="p">,:]))</span>
                    <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;APLYMINMAX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">apoly</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">apoly</span><span class="p">)]</span>
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTAPLY&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> \
                            <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">apoly</span><span class="p">,</span>
                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                                   <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">obswave</span><span class="p">)</span>

                <span class="c1"># - Multiplicative polynomial:</span>
                <span class="k">if</span> <span class="n">used_mpoly</span><span class="p">:</span>
                    <span class="n">mpoly</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">poly_x</span><span class="p">,</span>
                                                             <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">model_multcoef</span><span class="p">[</span><span class="n">i</span><span class="p">,:]))</span>
                    <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MPLYMINMAX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">mpoly</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">mpoly</span><span class="p">)]</span>
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> \
                            <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">mpoly</span><span class="p">,</span>
                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                                   <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">obswave</span><span class="p">)</span>
                <span class="c1">#-------------------------------------------------------</span>
                <span class="c1"># As of version 6.6.5, pPXF no longer applies the</span>
                <span class="c1"># multiplicative polynomial to the gas templates</span>
                <span class="c1"># factor = interpolate.interp1d(self.obj_wave[start:end], mpoly, bounds_error=False,</span>
                <span class="c1">#                              fill_value=1.0, assume_sorted=True)(obswave)</span>
                <span class="c1"># model_eml_par[&#39;FLUX&#39;][i,self.fit_eml] *= factor</span>
                <span class="c1"># model_eml_par[&#39;FLUXERR&#39;][i,self.fit_eml] *= factor</span>
                <span class="c1">#-------------------------------------------------------</span>

                <span class="c1"># - Reddening:</span>
                <span class="k">if</span> <span class="n">used_ebv</span><span class="p">:</span>
                    <span class="n">extcurve</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">reddening_cal00</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_reddening</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTRFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:]</span> \
                            <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">extcurve</span><span class="p">,</span>
                                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                                   <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">obswave</span><span class="p">)</span>

            <span class="c1"># Get the instrumental dispersion in the galaxy data at the</span>
            <span class="c1"># location of the fitted lines</span>
            <span class="c1"># TODO: sres has to be provided!</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMAINST&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">instrumental_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">],</span>
                                                        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Set the instrumental dispersion of the emission line</span>
            <span class="c1"># templates to the output database</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMATPL&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">eml_sigma_inst</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span>

            <span class="c1"># Add the template dispersion into the fitted dispersion to</span>
            <span class="c1"># get the observed dispersion</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
                            <span class="o">*</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                                        <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMATPL&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]))</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># With these definitions, the sigma correction is the same</span>
            <span class="c1"># as the instrumental dispersion; see copy function outside</span>
            <span class="c1"># the loop below</span>

<span class="c1">#            # The dispersion correction is the quadrature difference</span>
<span class="c1">#            # between the instrumental dispersion in the galaxy data to</span>
<span class="c1">#            # the dispersion used when constructing the emission-line</span>
<span class="c1">#            # templates</span>
<span class="c1">#            sigma2corr = numpy.square(sigma_inst) - numpy.square(etpl.eml_sigma_inst[self.fit_eml])</span>
<span class="c1">#            if numpy.any(sigma2corr &lt; 0):</span>
<span class="c1">#                # TODO: Raise an error instead?</span>
<span class="c1">#                print(sigma2corr)</span>
<span class="c1">#                warnings.warn(&#39;Encountered negative sigma corrections!&#39;)</span>
<span class="c1">#            model_eml_par[&#39;SIGMACORR&#39;][i,self.fit_eml] \</span>
<span class="c1">#                            = sigma2corr / numpy.sqrt(numpy.absolute(sigma2corr))</span>

<span class="c1">#            print(model_eml_par[&#39;SIGMACORR&#39;][i,self.fit_eml])</span>
<span class="c1">#            pyplot.scatter(self.emldb[&#39;restwave&#39;][self.fit_eml], sigma_inst,</span>
<span class="c1">#                           marker=&#39;.&#39;, lw=0, s=100)</span>
<span class="c1">#            pyplot.scatter(self.emldb[&#39;restwave&#39;][self.fit_eml], etpl.eml_sigma_inst[self.fit_eml],</span>
<span class="c1">#                           marker=&#39;.&#39;, lw=0, s=100)</span>
<span class="c1">#            pyplot.show()</span>

            <span class="c1">#-----------------------------------------------------------</span>
            <span class="c1"># Set output flags</span>
            <span class="c1"># - No fit was performed</span>
<span class="c1">#            if result[i] is None:</span>
<span class="c1">#                model_mask[i,:] = self.bitmask.turn_on(model_mask[i,:], &#39;NO_FIT&#39;)</span>
<span class="c1">#                continue</span>

            <span class="c1"># - No fit attempted because of insufficient data</span>
<span class="c1">#            if result[i].empty_fit():</span>
<span class="c1">#                model_mask[i,:] = self.bitmask.turn_on(model_mask[i,:], &#39;NO_FIT&#39;)</span>
<span class="c1">#                model_fit_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_fit_par[&#39;MASK&#39;][i],</span>
<span class="c1">#                                                                &#39;INSUFFICIENT_DATA&#39;)</span>
<span class="c1">#                model_eml_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][i],</span>
<span class="c1">#                                                                &#39;INSUFFICIENT_DATA&#39;)</span>
<span class="c1">#                continue</span>

            <span class="c1"># - Fit attempted but failed</span>
<span class="c1">#            if result[i].fit_failed():</span>
<span class="c1">#                model_mask[i,:] = self.bitmask.turn_on(model_mask[i,:], &#39;FIT_FAILED&#39;)</span>
<span class="c1">#                model_fit_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_fit_par[&#39;MASK&#39;][i],</span>
<span class="c1">#                                                                &#39;FIT_FAILED&#39;)</span>
<span class="c1">#                model_eml_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][i],</span>
<span class="c1">#                                                                &#39;FIT_FAILED&#39;)</span>

            <span class="c1"># - Fit successful but hit maximum iterations.</span>
<span class="c1">#            if result[i].reached_maxiter():</span>
<span class="c1">#                model_fit_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_fit_par[&#39;MASK&#39;][i], &#39;MAXITER&#39;)</span>
<span class="c1">#                model_eml_par[&#39;MASK&#39;][i] = self.bitmask.turn_on(model_eml_par[&#39;MASK&#39;][i], &#39;MAXITER&#39;)</span>

            <span class="c1">#-----------------------------------------------------------</span>
            <span class="c1"># Save the model parameters and figures of merit</span>

            <span class="c1"># TODO: FIX THIS</span>
<span class="c1">#            model_fit_par[&#39;USETPL&#39;][i,:] = result[i].tpl_to_use</span>

        <span class="c1"># With the above definitions (starting at line 1274), the</span>
        <span class="c1"># instrumental sigma and the sigma correction are identical</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;SIGMAINST&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Reset any parameters based on insufficient data to the fill_value</span>
        <span class="n">model_eml_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_to_fill_value</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Test if kinematics are reliable</span>
<span class="c1">#        model_eml_par = self._validate_dispersions(model_eml_par)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Return the fitting results</span>
        <span class="c1"># - model_flux: full model fit to the spectra</span>
        <span class="c1"># - model_eml_flux: emission-line only model</span>
        <span class="c1"># - model_mask: Bitmask spectra for the fit</span>
        <span class="c1"># - model_fit_par: The saved results from the ppxf fit</span>
        <span class="c1"># - model_eml_par: The fit results parsed into data for each</span>
        <span class="c1">#   emission line</span>
        <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span></div>



<div class="viewcode-block" id="Sasuke.fit_SpatiallyBinnedSpectra"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke.fit_SpatiallyBinnedSpectra">[docs]</a>    <span class="k">def</span> <span class="nf">fit_SpatiallyBinnedSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This DAP-specific function interprets the DAP-specific classes</span>
<span class="sd">        and constructs call(s) to the general :func:`fit` function to</span>
<span class="sd">        fit the spectra.</span>
<span class="sd">       </span>
<span class="sd">        The format of the calling sequence is dictated by the DAP</span>
<span class="sd">        interface: Any emission-line fitter (e.g.</span>
<span class="sd">        :class:`mangadap.proc.elric.Elric`) must have the same function</span>
<span class="sd">        interface in order to be called within the</span>
<span class="sd">        :class:`mangadap.proc.emissionlinemodel.EmissionLineModel`</span>
<span class="sd">        object.  Because this is a DAP-specific function, it should not</span>
<span class="sd">        declare anything to self.</span>

<span class="sd">        The returned emission-line &quot;baseline&quot; array is set to be the</span>
<span class="sd">        difference between the best-fitting stellar continuum (passed to</span>
<span class="sd">        this function as par[&#39;stellar_continuum&#39;]) and the best-fitting</span>
<span class="sd">        stellar continuum from the combined emission-line and stellar</span>
<span class="sd">        spectra produced by :func:`fit`.  In this way, the best-fitting</span>
<span class="sd">        model for each spectrum is::</span>
<span class="sd">        </span>
<span class="sd">            best_fit_model = par[&#39;stellar_continuum&#39;][&#39;FLUX&#39;].data \</span>
<span class="sd">                                + model_eml_flux + model_eml_base</span>

<span class="sd">        where `model_eml_flux` and `model_eml_base` are the 2nd and 3rd</span>
<span class="sd">        returned objects, respectively.  These are written to the output</span>
<span class="sd">        DAP model LOGCUBE file in the extensions EMLINE and EMLINE_BASE,</span>
<span class="sd">        respectively.</span>

<span class="sd">        Args:</span>
<span class="sd">            binned_spectra</span>
<span class="sd">                (:class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra`):</span>
<span class="sd">                Spectra to fit.</span>
<span class="sd">            par (:class:`SasukePar`): Parameters provided from the DAP</span>
<span class="sd">                to the general Sasuke fitting algorithm (:func:`fit`).</span>
<span class="sd">                Althought technically optional given that it is a</span>
<span class="sd">                keyword parameter, the :class:`SasukePar` parameter must</span>
<span class="sd">                be provided for proper execution of the function.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">                to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">                using :func:`mangadap.util.log.log_output`.  Default is</span>
<span class="sd">                no logging.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.  Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, numpy.recarray: The function returns: (1)</span>
<span class="sd">            wavelength vector of the fitted models, which should match</span>
<span class="sd">            the binned spectra wavelength vector</span>
<span class="sd">            (binned_spectra[&#39;WAVE&#39;].data), (2) the best-fitting</span>
<span class="sd">            emission-line model model spectra, (3) the best-fitting</span>
<span class="sd">            emission-line baseline (see the description above), (4) the</span>
<span class="sd">            bitmask values, (5) the per spectrum ppxf result, and (6)</span>
<span class="sd">            the per spectrum emission-line parameters.   The first</span>
<span class="sd">            object is a numpy.ndarray instance with shape :math:`(N_{\rm</span>
<span class="sd">            pix},)` , the next 3 objects are numpy.ndarray instances</span>
<span class="sd">            with shape :math:`(N_{\rm spec}, N_{\rm pix})`, and the last</span>
<span class="sd">            two are numpy.recarray instances with shape :math:`(N_{\rm</span>
<span class="sd">            spec},)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assign the parameters if provided</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide parameters!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">SasukePar</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input parameters must be an instance of SasukePar.&#39;</span><span class="p">)</span>
        <span class="c1"># SasukePar checks the types of the stellar continuum,</span>
        <span class="c1"># emission-line database, and pixel mask</span>

        <span class="c1"># SpatiallyBinnedSpectra object always needed</span>
        <span class="k">if</span> <span class="n">binned_spectra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide spectra object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectra</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a valid SpatiallyBinnedSpectra object!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided SpatiallyBinnedSpectra object is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Get the data arrays to fit</span>
        <span class="c1"># TODO: May also want to exclude pixels rejected during stellar</span>
        <span class="c1"># kinematics fit</span>
        <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">get_spectra_to_fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                              <span class="n">pixelmask</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">],</span>
                                                              <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">)</span>
        <span class="n">_sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sres</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">interpolate_masked_vector</span><span class="p">(</span><span class="n">_sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>

        <span class="c1"># Get the binned spectra that meet the S/N criterion</span>
        <span class="n">bins_to_fit</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">select_binned_spectra_to_fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span>
                                                                   <span class="n">minimum_snr</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">],</span>
                                                        <span class="n">stellar_continuum</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">])</span>
        <span class="n">nobj</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check if the user wants to switch the templates being used for</span>
        <span class="c1"># the stellar continuum.  The construction of the</span>
        <span class="c1"># TemplateLibrary object must be done inside</span>
        <span class="c1"># self.method[&#39;fitfunc&#39;] !</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;continuum_tpl_key&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;continuum_tpl_key&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stellar_continuum</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library_key&#39;</span><span class="p">]</span> \
                                    <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;continuum_tpl_key&#39;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Request emission-line continuum templates identical to those used&#39;</span>
                              <span class="s1">&#39;during the stellar continuum fitting; selection unnecessary.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get the stellar templates.  If fitting a different set of</span>
        <span class="c1"># templates, the spectral resolution of the new templates must</span>
        <span class="c1"># be matched to the galaxy data and the velocity dispersion used</span>
        <span class="c1"># by the fit must be astrophysical (corrected for any resolution</span>
        <span class="c1"># difference).</span>
        <span class="n">stellar_templates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">matched_resolution</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">],</span> <span class="n">TemplateLibrary</span><span class="p">):</span>
                <span class="c1"># The template library has already been instantiated so</span>
                <span class="c1"># just copy the object.  Assume this means that the</span>
                <span class="c1"># spectral resolution has been matched to the MaNGA</span>
                <span class="c1"># data because otherwise par[&#39;continuum_templates&#39;] is</span>
                <span class="c1"># None.</span>
                <span class="n">stellar_templates</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span>
                <span class="c1"># TODO: Instead test that the spectral resolution of the</span>
                <span class="c1"># template libary has been matched to the MaNGA data?</span>
                <span class="n">matched_resolution</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;velscale_ratio&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise it must be the keyword of the library that</span>
                <span class="c1"># needs to be constructed.</span>

                <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                        <span class="ow">and</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span> \
                            <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library_key&#39;</span><span class="p">]:</span>
                    <span class="c1"># The templates used are the same, so warn the user</span>
                    <span class="c1"># and just copy over the existing template library.</span>
                    <span class="c1"># This maintains the resolution difference</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Request emission-line continuum templates identical to those &#39;</span>
                                  <span class="s1">&#39;used during the stellar continuum fitting.&#39;</span><span class="p">)</span>
                    <span class="n">stellar_templates</span> \
                            <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span>
                    <span class="n">matched_resolution</span> \
                            <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;match_resolution&#39;</span><span class="p">]</span>
                    <span class="n">velscale_ratio</span> \
                            <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;velscale_ratio&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The template library needs to be constructed based</span>
                    <span class="c1"># on the provided keyword</span>
                    <span class="c1"># TODO: The TemplateLibrary object uses the median</span>
                    <span class="c1"># spectral resolution vector when performing the</span>
                    <span class="c1"># resolution match to the MaNGA data.</span>
                    <span class="n">match_resolution</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;velscale_ratio&#39;</span><span class="p">]</span>
                    <span class="n">velocity_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">,:])</span>
                    <span class="c1"># TODO: The dapsrc and analysis_path will return to</span>
                    <span class="c1"># the defaults!</span>
                    <span class="n">stellar_templates</span> \
                            <span class="o">=</span> <span class="n">TemplateLibrary</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">],</span>
                                              <span class="n">velocity_offset</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">,</span>
                                              <span class="n">drpf</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                              <span class="n">match_to_drp_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;continuum_templates&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stellar_templates</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;fitpar&#39;</span><span class="p">][</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span>

        <span class="n">stpl_wave</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_templates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stellar_templates</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">stpl_flux</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_templates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stellar_templates</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Adopting mean spectral resolution of all templates!&#39;</span><span class="p">)</span>
        <span class="n">stpl_sres</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_templates</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stellar_templates</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Get the stellar kinematics</span>
        <span class="n">stellar_velocity</span><span class="p">,</span> <span class="n">stellar_dispersion</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">matched_kinematics</span><span class="p">(</span>
                                                <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">nearest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">,</span>
                                                <span class="n">corrected</span><span class="o">=</span><span class="n">matched_resolution</span><span class="p">)</span>
        <span class="n">stellar_kinematics</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_velocity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">stellar_dispersion</span> <span class="ow">is</span> <span class="kc">None</span> \
                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">stellar_velocity</span><span class="p">,</span> <span class="n">stellar_dispersion</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Set which stellar templates to use for each spectrum</span>
        <span class="c1"># TODO: Template modes:</span>
        <span class="c1">#   - provide all</span>
        <span class="c1">#   - provide non-zero</span>
        <span class="c1">#   - optimal template from each bin</span>
<span class="c1">#        stpl_to_use = None if par[&#39;stellar_continuum&#39;] is None \</span>
<span class="c1">#                        else par[&#39;stellar_continuum&#39;].matched_template_flags(binned_spectra)</span>
        <span class="n">stpl_to_use</span> <span class="o">=</span> <span class="kc">None</span>                  <span class="c1"># Use all templates</span>

        <span class="c1"># TODO: For now can only fit two moments</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Number of gas moments can only be two.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]:</span>
            <span class="c1"># TODO: Only need to refit &quot;bins&quot; that are made up of more</span>
            <span class="c1"># than one spaxel...</span>

            <span class="c1"># Get the individual spaxel data</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">spaxel_flux</span><span class="p">,</span> <span class="n">spaxel_ferr</span> <span class="o">=</span> <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">get_spectra_to_fit</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="p">,</span>
                                                                        <span class="n">pixelmask</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">],</span>
                                                                          <span class="n">error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Apply the Galactic extinction</span>
            <span class="n">spaxel_flux</span><span class="p">,</span> <span class="n">spaxel_ferr</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">galext</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">spaxel_flux</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">spaxel_ferr</span><span class="p">,</span>
                                                                   <span class="n">deredden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># TODO: set minimum_fraction as a keyword.  Set to 0.8 by</span>
            <span class="c1"># default</span>
            <span class="n">spaxel_to_fit</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">check_fgoodpix</span><span class="p">()</span>

            <span class="c1"># Get the spectral resolution:</span>
            <span class="c1"># - stack_sres sets whether or not the spectral resolution</span>
            <span class="c1">#   is determined on a per-spaxel basis or with a single</span>
            <span class="c1">#   vector</span>
            <span class="n">stack_sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;stackpar&#39;</span><span class="p">][</span><span class="s1">&#39;stack_sres&#39;</span><span class="p">]</span>
            <span class="c1"># - prepixel_sres sets if the prepixelized version of the</span>
            <span class="c1">#   LSF measurements were used</span>
            <span class="n">prepixel_sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">method</span><span class="p">[</span><span class="s1">&#39;prepixel_sres&#39;</span><span class="p">]</span>
            <span class="c1"># This pulls out the appropiate spectral resolution</span>
            <span class="n">spaxel_sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">spectral_resolution</span><span class="p">(</span>
                                            <span class="n">ext</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stack_sres</span> <span class="k">else</span> <span class="s1">&#39;SPECRES&#39;</span><span class="p">,</span> <span class="n">toarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">prepixel_sres</span><span class="p">)</span>
            <span class="c1"># Spaxel coordinates; shape is (Nspaxel,)</span>
            <span class="n">spaxel_x</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spaxel_y</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">rdxqa</span><span class="p">[</span><span class="s1">&#39;SPECTRUM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Get the binned coordinates</span>
            <span class="n">bin_x</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bin_y</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SKY_COO&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Return the fits to the individual spaxel data</span>
            <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">obj_ferr</span><span class="o">=</span><span class="n">ferr</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span> <span class="n">obj_sres</span><span class="o">=</span><span class="n">sres</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">guess_redshift</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">],</span>
                               <span class="n">guess_dispersion</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_dispersion&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">],</span>
                               <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">],</span> <span class="n">stpl_wave</span><span class="o">=</span><span class="n">stpl_wave</span><span class="p">,</span>
                               <span class="n">stpl_flux</span><span class="o">=</span><span class="n">stpl_flux</span><span class="p">,</span> <span class="n">stpl_sres</span><span class="o">=</span><span class="n">stpl_sres</span><span class="p">,</span>
                               <span class="n">stpl_to_use</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stpl_to_use</span> <span class="ow">is</span> <span class="kc">None</span> \
                                                <span class="k">else</span> <span class="n">stpl_to_use</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">stellar_kinematics</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_kinematics</span> <span class="ow">is</span> <span class="kc">None</span> \
                                                       <span class="k">else</span> <span class="n">stellar_kinematics</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">etpl_sinst_mode</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;etpl_line_sigma_mode&#39;</span><span class="p">],</span>
                               <span class="n">etpl_sinst_min</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;etpl_line_sigma_min&#39;</span><span class="p">],</span>
                               <span class="n">remap_flux</span><span class="o">=</span><span class="n">spaxel_flux</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:],</span>
                               <span class="n">remap_ferr</span><span class="o">=</span><span class="n">spaxel_ferr</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:],</span>
                               <span class="n">remap_sres</span><span class="o">=</span><span class="n">spaxel_sres</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:],</span>
                               <span class="n">remap_skyx</span><span class="o">=</span><span class="n">spaxel_x</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">],</span>
                               <span class="n">remap_skyy</span><span class="o">=</span><span class="n">spaxel_y</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">],</span> <span class="n">obj_skyx</span><span class="o">=</span><span class="n">bin_x</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">],</span>
                               <span class="n">obj_skyy</span><span class="o">=</span><span class="n">bin_y</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">],</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                               <span class="n">matched_resolution</span><span class="o">=</span><span class="n">matched_resolution</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">],</span>
<span class="c1">#                               degree=-1, mdegree=0,</span>
                               <span class="n">degree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">],</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">],</span>
                               <span class="n">reddening</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;reddening&#39;</span><span class="p">],</span>
                               <span class="c1">#moments=par[&#39;moments&#39;],</span>
                               <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

            <span class="c1"># Convert the index number of the nearest bin to the BIN ID</span>
            <span class="c1"># number</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">]</span> \
                <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">][</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">]]</span>

            <span class="n">model_binid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">model_binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">spaxel_to_fit</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spaxel_to_fit</span><span class="p">))</span>

            <span class="c1"># Add the equivalent width data</span>
<span class="c1">#            redshift = model_eml_par[&#39;KIN&#39;][:,0]/astropy.constants.c.to(&#39;km/s&#39;).value</span>
            <span class="c1"># TODO: Redshift is set to fitted redshift.  Should it use</span>
            <span class="c1"># this or the input guess?</span>
            <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">measure_equivalent_width</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">spaxel_flux</span><span class="p">[</span><span class="n">spaxel_to_fit</span><span class="p">,:],</span>
                                                     <span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="n">model_eml_par</span><span class="p">,</span>
                                                     <span class="c1">#redshift=redshift,</span>
                                                     <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">checkdb</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return the fits to the binned data</span>
            <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">obj_ferr</span><span class="o">=</span><span class="n">ferr</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span> <span class="n">obj_sres</span><span class="o">=</span><span class="n">sres</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">guess_redshift</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">],</span>
                               <span class="n">guess_dispersion</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_dispersion&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">],</span>
                               <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">],</span> <span class="n">stpl_wave</span><span class="o">=</span><span class="n">stpl_wave</span><span class="p">,</span>
                               <span class="n">stpl_flux</span><span class="o">=</span><span class="n">stpl_flux</span><span class="p">,</span> <span class="n">stpl_sres</span><span class="o">=</span><span class="n">stpl_sres</span><span class="p">,</span>
                               <span class="n">stpl_to_use</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stpl_to_use</span> <span class="ow">is</span> <span class="kc">None</span> \
                                                <span class="k">else</span> <span class="n">stpl_to_use</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">stellar_kinematics</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_kinematics</span> <span class="ow">is</span> <span class="kc">None</span> \
                                                       <span class="k">else</span> <span class="n">stellar_kinematics</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                               <span class="n">etpl_sinst_mode</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;etpl_line_sigma_mode&#39;</span><span class="p">],</span>
                               <span class="n">etpl_sinst_min</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;etpl_line_sigma_min&#39;</span><span class="p">],</span>
                               <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                               <span class="n">matched_resolution</span><span class="o">=</span><span class="n">matched_resolution</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">],</span>
<span class="c1">#                               degree=-1, mdegree=0,</span>
                               <span class="n">degree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">],</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">],</span>
                               <span class="n">reddening</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;reddening&#39;</span><span class="p">],</span>
                               <span class="c1">#moments=par[&#39;moments&#39;],</span>
                               <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

            <span class="c1"># Save the the bin ID numbers indices based on the spectra</span>
            <span class="c1"># selected to be fit</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">]</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">bins_to_fit</span><span class="p">]</span>
            <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">]</span>

            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">bins_to_fit</span><span class="p">]</span>
            <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">bins_to_fit</span><span class="p">]</span>

            <span class="c1"># Bin IDs are the same as on input</span>
            <span class="n">model_binid</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Add the equivalent width data</span>
<span class="c1">#            redshift=par[&#39;guess_redshift&#39;][bins_to_fit],</span>
            <span class="c1"># TODO: Redshift is set to fitted redshift.  Should it use</span>
            <span class="c1"># this or the input guess?  Should the EWs be measured in</span>
            <span class="c1"># EmissionLineModel instead?  (Computation not specific to</span>
            <span class="c1"># Sasuke...)</span>
            <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">measure_equivalent_width</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:],</span>
                                                     <span class="n">par</span><span class="p">[</span><span class="s1">&#39;emission_lines&#39;</span><span class="p">],</span> <span class="n">model_eml_par</span><span class="p">,</span>
                                                     <span class="c1">#redshift=redshift,</span>
                                                     <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">checkdb</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Reset the equivalent widths to the fill value.  The error</span>
        <span class="c1"># values are currently reset to 0. by EmissionLineModel.</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BMED&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;RMED&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EWCONT&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EW&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;EWERR&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.</span>

        <span class="c1"># Calculate the &quot;emission-line baseline&quot; as the difference</span>
        <span class="c1"># between the stellar continuum model determined for the</span>
        <span class="c1"># kinematics and the one determined by the optimized</span>
        <span class="c1"># stellar-continuum + emission-line fit:</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;deconstruct_bins&#39;</span><span class="p">]:</span>

                <span class="c1"># Get the stellar continuum.  The model extends over</span>
                <span class="c1"># over regions masked during the fit, but 0 outside the</span>
                <span class="c1"># spectral range of the fit.</span>
                <span class="n">sc_continuum</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fill_to_match</span><span class="p">(</span>
                                                    <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                    <span class="n">missing</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span>

<span class="c1">#                print(type(sc_continuum))</span>
<span class="c1">#                for _i in range(10):</span>
<span class="c1">#                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, sc_continuum.data[_i,:])</span>
<span class="c1">#                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, sc_continuum[_i,:])</span>
<span class="c1">#                    pyplot.show()</span>

                <span class="c1"># Construct the full 3D cube for the stellar continuum</span>
                <span class="n">sc_model_flux</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_cube</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                             <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                             <span class="n">sc_continuum</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>

<span class="c1">#                print(type(sc_model_flux))</span>
<span class="c1">#                print(sc_model_flux.shape)</span>
<span class="c1">#                nx = sc_model_flux.shape[0]</span>
<span class="c1">#                for _i in range(10):</span>
<span class="c1">##                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, sc_model_flux.data[_i,_i,:])</span>
<span class="c1">#                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, sc_model_flux[nx//2+_i-5,nx//2+_i-5,:])</span>
<span class="c1">#                    pyplot.show()</span>

                <span class="c1"># Construct the full 3D cube of the new stellar</span>
                <span class="c1"># continuum from the combined stellar-continuum +</span>
                <span class="c1"># emission-line fit</span>
                <span class="n">el_continuum</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">reconstruct_cube</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">drpf</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                            <span class="n">model_binid</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                            <span class="n">model_flux</span> <span class="o">-</span> <span class="n">model_eml_flux</span><span class="p">)</span>

<span class="c1">#                print(type(el_continuum))</span>
<span class="c1">#                print(el_continuum.shape)</span>
<span class="c1">#                nx = el_continuum.shape[0]</span>
<span class="c1">#                for _i in range(10):</span>
<span class="c1">##                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, el_continuum.data[_i,_i,:])</span>
<span class="c1">#                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, el_continuum[nx//2+_i-5,nx//2+_i-5,:])</span>
<span class="c1">#                    pyplot.show()</span>

                <span class="c1"># Get the difference, restructure it to match the shape</span>
                <span class="c1"># of the emission-line models</span>
                <span class="n">model_eml_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">el_continuum</span> <span class="o">-</span> <span class="n">sc_model_flux</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span><span class="p">)[</span><span class="n">spaxel_to_fit</span><span class="p">,:]</span>
<span class="c1">#                if model_mask is not None:</span>
<span class="c1">#                    model_eml_base[model_mask==0] = 0.0</span>

<span class="c1">#                print(type(model_eml_base))</span>
<span class="c1">#                print(model_eml_base.shape)</span>
<span class="c1">#                for _i in range(10):</span>
<span class="c1">#                    pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, model_eml_base[_i,:])</span>
<span class="c1">#                    pyplot.show()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">el_continuum</span> <span class="o">=</span> <span class="n">model_flux</span> <span class="o">-</span> <span class="n">model_eml_flux</span>
                <span class="n">sc_continuum</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;stellar_continuum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fill_to_match</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                            <span class="n">missing</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">missing_bins</span><span class="p">)</span>
                <span class="n">model_eml_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">el_continuum</span> <span class="o">-</span> <span class="n">sc_continuum</span><span class="p">[</span><span class="n">bins_to_fit</span><span class="p">,:])</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_eml_base</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="c1">#        pyplot.plot(model_wave, flux[spec_to_fit,:][0,:], color=&#39;k&#39;, lw=1, zorder=1)</span>
<span class="c1">#        pyplot.plot(model_wave, stellar_continuum[spec_to_fit,:][0,:], color=&#39;C0&#39;, lw=1.0,</span>
<span class="c1">#                    zorder=2)</span>
<span class="c1">#        pyplot.plot(model_wave, model_eml_flux[0,:], color=&#39;C1&#39;, lw=1.0, zorder=3)</span>
<span class="c1">#        pyplot.plot(model_wave, model_eml_base[0,:], color=&#39;C2&#39;, lw=1.0, zorder=4)</span>
<span class="c1">#        pyplot.plot(model_wave, eml_continuum[0,:], color=&#39;C3&#39;, lw=1.0, zorder=4)</span>
<span class="c1">#        pyplot.show()</span>

<span class="c1">#        print(par[&#39;emission_lines&#39;][&#39;name&#39;])</span>
<span class="c1">#        print(model_eml_par[&#39;FLUX&#39;][0,:])</span>
<span class="c1">#        print(model_eml_par[&#39;FLUXERR&#39;][0,:])</span>
        
        <span class="c1"># Only return model and model parameters for the *fitted*</span>
        <span class="c1"># spectra</span>
<span class="c1">#        print(type(model_eml_flux))</span>
<span class="c1">#        print(type(model_eml_base))</span>
<span class="c1">#        print(type(model_mask))</span>
<span class="c1">#        for _i in range(10):</span>
<span class="c1">#            pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, model_eml_flux[_i,:])</span>
<span class="c1">#            pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, model_eml_base[_i,:])</span>
<span class="c1">#            pyplot.plot(binned_spectra[&#39;WAVE&#39;].data, model_mask[_i,:])</span>
<span class="c1">#            pyplot.show()</span>
        <span class="k">return</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_eml_base</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">,</span>\
                    <span class="n">model_binid</span></div>


<div class="viewcode-block" id="Sasuke.fit"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emission_lines</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">guess_redshift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stpl_wave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stpl_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stpl_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stpl_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stellar_kinematics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">etpl_sinst_mode</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">etpl_sinst_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">remap_flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remap_ferr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">remap_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remap_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remap_skyx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remap_skyy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj_skyx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">obj_skyy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">matched_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">degree</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_velocity_range</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span> <span class="n">alias_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1">#moments=2,</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a set of emission lines using pPXF to all provided spectra.</span>

<span class="sd">        The input flux arrays are expected to be ordered with spectra</span>
<span class="sd">        along **rows**. I.e., to plot the first spectrum in the array,</span>
<span class="sd">        one would do::</span>
<span class="sd">            </span>
<span class="sd">            from matplotlib import pyplot</span>
<span class="sd">            pyplot.plot(obj_wave, obj_flux[0,:])</span>
<span class="sd">            pyplot.show()</span>

<span class="sd">        The function will fit the spectra with or without any provided</span>
<span class="sd">        stellar templates.</span>

<span class="sd">        The body of this function mostly deals with checking the input</span>
<span class="sd">        and setting up the template and object data for use with pPXF.</span>

<span class="sd">        The function is meant to be general, but has only been tested on</span>
<span class="sd">        MaNGA spectra.</span>

<span class="sd">        If the spectral resolution is not matched between the templates</span>
<span class="sd">        and the object spectra, the provided stellar_kinematics is</span>
<span class="sd">        expected to include any resolution difference; i.e., it is</span>
<span class="sd">        **not** the astrophysical velocity dispersion.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - guess_redshift and guess_dispersion are not actually</span>
<span class="sd">              optional.  The function will fail without them!</span>
<span class="sd">            - Allow for moments != 2.</span>
<span class="sd">            - Allow for fixed components to be set from emission-line</span>
<span class="sd">              database</span>
<span class="sd">            - Allow for bounds to be set from emission-line database</span>
<span class="sd">            - Allow to ignore emission-line database tying and just tie</span>
<span class="sd">              all kinematics</span>
<span class="sd">            - Should probably put the emission-line construction in a</span>
<span class="sd">              separate function.</span>

<span class="sd">        Args:</span>
<span class="sd">            emission_lines</span>
<span class="sd">                (:class:`mangadap.par.emissionlinedb.EmissionLineDB`):</span>
<span class="sd">                Emission-line database that is parsed to construct the</span>
<span class="sd">                emission-line templates to fit (see</span>
<span class="sd">                :class:`mangadap.proc.emissionelinetemplates.EmissionLineTemplates`).</span>
<span class="sd">            obj_wave (numpy.ndarray): Wavelength vector for object</span>
<span class="sd">                spectra.  Shape is (:math:`N_{\rm pix}`,).</span>
<span class="sd">            obj_flux (numpy.ndarray): Object spectra to fit.  Can be</span>
<span class="sd">                provided as a `numpy.ma.MaskedArray`_.  Shape is</span>
<span class="sd">                (:math:`N_{\rm spec},N_{\rm pix}`).</span>
<span class="sd">            obj_ferr (numpy.ndarray): (**Optional**) :math:`1\sigma`</span>
<span class="sd">                errors in object spectra.  Can be provided as a</span>
<span class="sd">                `numpy.ma.MaskedArray`_.  Shape is (:math:`N_{\rm</span>
<span class="sd">                spec},N_{\rm pix}`).  If None, the quadrature sum of the</span>
<span class="sd">                fit residuals is used as the fit metric instead of</span>
<span class="sd">                chi-square (all errors are set to unity).</span>
<span class="sd">            obj_mask (numpy.ndarray or</span>
<span class="sd">                :class:`mangadap.util.pixelmask.SpectralPixelMask`):</span>
<span class="sd">                (**Optional**) Boolean array or</span>
<span class="sd">                :class:`mangadap.util.pixelmask.SpectralPixelMask`</span>
<span class="sd">                instance used to censor regions of the spectra to ignore</span>
<span class="sd">                during fitting.</span>
<span class="sd">            obj_sres (numpy.ndarray): (**Optional**) The spectral</span>
<span class="sd">                resolution of the object data.  Can be a single vector</span>
<span class="sd">                for all spectra or one vector per object spectrum.</span>
<span class="sd">            guess_redshift (array-like): (**Optional**) The starting</span>
<span class="sd">                redshift guess.  Can provide a single value for all</span>
<span class="sd">                spectra or one value per spectrum.</span>
<span class="sd">            guess_dispersion (array-like): (**Optional**) The starting</span>
<span class="sd">                velocity dispersion guess.  Can provide a single value</span>
<span class="sd">                for all spectra or one value per spectrum.</span>
<span class="sd">            reject_boxcar (int): (**Optional**) Size of the boxcar to</span>
<span class="sd">                use when rejecting fit outliers.  If None, no rejection</span>
<span class="sd">                iteration is performed.</span>
<span class="sd">            stpl_wave (numpy.ndarray): (**Optional**) Wavelength vector</span>
<span class="sd">                for stellar template spectra.  Shape is (:math:`N_{{\rm</span>
<span class="sd">                pix},\ast}`,).</span>
<span class="sd">            stpl_flux (numpy.ndarray): (**Optional**) Stellar template</span>
<span class="sd">                spectra to use in fit.  Shape is (:math:`N_{{\rm</span>
<span class="sd">                tpl},\ast},N_{{\rm pix},\ast}`).</span>
<span class="sd">            stpl_sres (numpy.ndarray): (**Optional**) Spectral</span>
<span class="sd">                resolution of the stellar template spectra.  All</span>
<span class="sd">                templates are assumed to have the same spectral</span>
<span class="sd">                resolution.  Shape is (:math:`N_{{\rm pix},\ast}`,).</span>
<span class="sd">                This is also used to set the spectral resolution of the</span>
<span class="sd">                emission-line templates.  If not provided, the</span>
<span class="sd">                emission-line templates are constructed with an LSF that</span>
<span class="sd">                has a disperison of 1 pixel.</span>
<span class="sd">            stpl_to_use (numpy.ndarray): (**Optional**) Set of flags</span>
<span class="sd">                used to select the stellar templates used to fit each</span>
<span class="sd">                spectrum.  Shape is (:math:`N_{\rm spec},N_{{\rm</span>
<span class="sd">                tpl},\ast}`).</span>
<span class="sd">            stellar_kinematics (numpy.ndarray): (**Optional**) The</span>
<span class="sd">                kinematics to use for the stellar component.  If the</span>
<span class="sd">                spectral resolution of the templates is different from</span>
<span class="sd">                the galaxy data, the provided stellar velocity</span>
<span class="sd">                dispersions *must* include the the (assumed</span>
<span class="sd">                wavelength-independent) quadrature difference in the</span>
<span class="sd">                template and galaxy instrumental resolutions.  The</span>
<span class="sd">                stellar kinematics are **fixed** for all calls made to</span>
<span class="sd">                ppxf.  Shape is (:math:`N_{\rm spec},N_{{\rm</span>
<span class="sd">                kin},\ast}`).  The shape of this array determines the</span>
<span class="sd">                number of moments assigned to the stellar component.</span>
<span class="sd">            etpl_sinst_mode (str): (**Optional**) Mode used to set the</span>
<span class="sd">                instrumental dispersion of the emission-line templates;</span>
<span class="sd">                see :func:`etpl_line_sigma_options` for the options.</span>
<span class="sd">                Default mode is `default`, imagine that.</span>
<span class="sd">            etpl_sinst_min (str): (**Optional**) Minimum allowed</span>
<span class="sd">                instrumental dispersion value.  If the mode of</span>
<span class="sd">                constructing the instrumental dispersion of the</span>
<span class="sd">                templates results in values that are below this value,</span>
<span class="sd">                the whole function is offset in quadrature such that no</span>
<span class="sd">                value goes below the minimum.  Default is 0 km/s.</span>
<span class="sd">            remap_flux (numpy.ndarray): (**Optional**) Ultimately the</span>
<span class="sd">                spectra to be modeled, if provided.  The nominal usage</span>
<span class="sd">                is, e.g., if the object spectra (`obj_flux`) are binned</span>
<span class="sd">                spaxels, this can be flux arrays of all the spaxels that</span>
<span class="sd">                were used to construct the binned data.  The function</span>
<span class="sd">                would then use a first fit to the binned spectra and a</span>
<span class="sd">                matching between the on-sky positions (see `remap_skyx`,</span>
<span class="sd">                `remap_skyy`, `obj_skyx`, `obj_skyy`) to ultimately fit</span>
<span class="sd">                the individual spaxel data.  See</span>
<span class="sd">                :func:`mangadap.contrib.xjmc.emline_fitter_with_ppxf`.</span>
<span class="sd">                These spectra must be sampled identically to the object</span>
<span class="sd">                spectra (`velscale`) and have the same wavelength vector</span>
<span class="sd">                (`obj_wave`).  Can be provided as a</span>
<span class="sd">                `numpy.ma.MaskedArray`_.  Shape is (:math:`N_{\rm</span>
<span class="sd">                remap},N_{\rm pix}`).</span>
<span class="sd">            remap_ferr (numpy.ndarray): (**Optional**)  The 1-sigma</span>
<span class="sd">                error in `remap_flux`.  Can be provided as a</span>
<span class="sd">                `numpy.ma.MaskedArray`_.  Shape is (:math:`N_{\rm</span>
<span class="sd">                remap},N_{\rm pix}`).</span>
<span class="sd">            remap_mask (numpy.ndarray or</span>
<span class="sd">                :class:`mangadap.util.pixelmask.SpectralPixelMask`):</span>
<span class="sd">                (**Optional**) Boolean array or</span>
<span class="sd">                :class:`mangadap.util.pixelmask.SpectralPixelMask`</span>
<span class="sd">                instance used to censor regions of the remapping spectra</span>
<span class="sd">                to ignore during fitting.</span>
<span class="sd">            remap_sres (numpy.ndarray): (**Optional**)  The spectral</span>
<span class="sd">                resolution of the remapping spectra.  Can be a single</span>
<span class="sd">                vector for all spectra or one vector per object</span>
<span class="sd">                spectrum.</span>
<span class="sd">            remap_skyx (numpy.ndarray): (**Optional**) On-sky x position</span>
<span class="sd">                of the remapping spectra.  Shape is (:math:`N_{\rm</span>
<span class="sd">                remap}`,).</span>
<span class="sd">            remap_skyy (numpy.ndarray): (**Optional**) On-sky y position</span>
<span class="sd">                of the remapping spectra.  Shape is (:math:`N_{\rm</span>
<span class="sd">                remap}`,).</span>
<span class="sd">            obj_skyx (numpy.ndarray): (**Optional**) On-sky x position</span>
<span class="sd">                of the object spectra.  Shape is (:math:`N_{\rm</span>
<span class="sd">                spec}`,).</span>
<span class="sd">            obj_skyy (numpy.ndarray): (**Optional**) On-sky y position</span>
<span class="sd">                of the object spectra.  Shape is (:math:`N_{\rm</span>
<span class="sd">                spec}`,).</span>
<span class="sd">            velscale_ratio (int): (**Optional**) The **integer** ratio</span>
<span class="sd">                between the velocity scale of the pixel in the galaxy</span>
<span class="sd">                data to that of the template data.  If None, set to</span>
<span class="sd">                unity.</span>
<span class="sd">            matched_resolution (bool): (**Optional**) The spectral</span>
<span class="sd">                resolution of the templates is matched to that of the</span>
<span class="sd">                galaxy data.  WARNING: This functionality is never used!</span>
<span class="sd">            waverange (array-like): (**Optional**) Lower and upper</span>
<span class="sd">                wavelength limits to *include* in the fit.  This can be</span>
<span class="sd">                a two-element vector to apply the same limits to all</span>
<span class="sd">                spectra, or a N-spec x 2 array with wavelength ranges</span>
<span class="sd">                for each spectrum to be fit.  Default is to use as much</span>
<span class="sd">                of the spectrum as possible.</span>
<span class="sd">            bias (float): (**Optional**) pPXF bias parameter.</span>
<span class="sd">                (Currently irrelevant because gas is currently always</span>
<span class="sd">                fit with moments=2.)</span>
<span class="sd">            degree (int): (**Optional**) pPXF degree parameter setting</span>
<span class="sd">                the degree of the additive polynomials to use,</span>
<span class="sd">                :math:`o_{\rm add}`.  Default is no polynomial included.</span>
<span class="sd">            mdegree (int): (**Optional**) pPXF mdegree parameter setting</span>
<span class="sd">                the degree of the multiplicative polynomials to use,</span>
<span class="sd">                :math:`o_{\rm mult}`.  Default is no polynomial</span>
<span class="sd">                included.</span>
<span class="sd">            reddening (float): (**Optional**) pPXF reddening parameter</span>
<span class="sd">                used to fit :math:`E(B-V)` assuming a Calzetti law.</span>
<span class="sd">                Cannot be fit simultaneously with multiplicative</span>
<span class="sd">                polynomial.  Must be larger than 0 to start.  Default is</span>
<span class="sd">                not fit.</span>
<span class="sd">            max_velocity_range (float): (**Optional**) Maximum range</span>
<span class="sd">                (+/-) expected for the fitted velocities in km/s.</span>
<span class="sd">                Default is 400 km/s.</span>
<span class="sd">            alias_window (float) : (**Optional**) The window to mask to</span>
<span class="sd">                avoid aliasing near the edges of the spectral range in</span>
<span class="sd">                km/s.  Default is six times *max_velocity_range*.</span>
<span class="sd">            dvtol (float): (**Optional**) The velocity scale of the</span>
<span class="sd">                template spectra and object spectrum must be smaller</span>
<span class="sd">                than this tolerance.  Default is 1e-10.</span>
<span class="sd">            plot (bool): (**Optional**) Show the automatically generated</span>
<span class="sd">                pPXF fit plots for each iterations of each spectrum.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_</span>
<span class="sd">                objects to log progress; ignored if quiet=True.  Logging</span>
<span class="sd">                is done using :func:`mangadap.util.log.log_output`.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray, numpy.recarray: The function returns: (1) the</span>
<span class="sd">            wavelength vector for the model spectra (should be the same</span>
<span class="sd">            as obj_wave), (2) the best-fitting model spectra, (3) the</span>
<span class="sd">            best-fitting emission-line only spectra, (4) the bitmask</span>
<span class="sd">            values, (5) the per spectrum ppxf result, and (6) the per</span>
<span class="sd">            spectrum emission-line parameters.  The first object is a</span>
<span class="sd">            numpy.ndarray instance with shape :math:`(N_{\rm pix},)`,</span>
<span class="sd">            the next 3 objects are numpy.ndarray instances with shape</span>
<span class="sd">            :math:`(N_{\rm spec}, N_{\rm pix})`, and the last two are</span>
<span class="sd">            numpy.recarray instances with shape :math:`(N_{\rm spec},)`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the length of the spectra, errors, or</span>
<span class="sd">                mask does not match the length of the wavelength array;</span>
<span class="sd">                raised if the wavelength, redshift, or dispersion arrays</span>
<span class="sd">                are not 1D vectors; and raised if the number of</span>
<span class="sd">                redshifts or dispersions is not a single value or the</span>
<span class="sd">                same as the number of input spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># The minimum instrumental dispersion of the emission-line</span>
        <span class="c1"># templates cannot be below 0.</span>
        <span class="n">_etpl_sinst_min</span> <span class="o">=</span> <span class="n">etpl_sinst_min</span>
        <span class="k">if</span> <span class="n">_etpl_sinst_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Emission-line template instrumental dispersion must be 0 km/s or &#39;</span>
                          <span class="s1">&#39;higher.  Setting etpl_sinst_min=0.&#39;</span><span class="p">)</span>
            <span class="n">_etpl_sinst_min</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check the input data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="o">=</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="n">obj_sres</span><span class="o">=</span><span class="n">obj_sres</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waverange</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">set_wavelength_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">waverange</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of object spectra to fit: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">))</span>
        <span class="c1"># guess_kin are in &quot;ppxf&quot; velocities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">,</span> <span class="n">guess_kin</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_input_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span>
                                                                  <span class="n">guess_dispersion</span><span class="p">)</span>
<span class="c1">#        print(self.input_cz[0], guess_kin[0,:])</span>
<span class="c1">#        print(numpy.mean(self.input_cz))</span>

        <span class="c1"># Check the remapping data, if provided</span>
        <span class="k">if</span> <span class="n">remap_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_sres</span> \
                        <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">remap_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="o">=</span><span class="n">remap_ferr</span><span class="p">,</span>
                                                <span class="n">obj_sres</span><span class="o">=</span><span class="n">remap_sres</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyy</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_remapping_coordinates</span><span class="p">(</span><span class="n">obj_skyx</span><span class="p">,</span> <span class="n">obj_skyy</span><span class="p">,</span>
                                                            <span class="n">remap_skyx</span><span class="p">,</span> <span class="n">remap_skyy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remap_sres</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_skyy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remap_skyy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Compare pixel scales and set template wavelength vector</span>
        <span class="k">if</span> <span class="n">stpl_wave</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_pixel_scale</span><span class="p">(</span><span class="n">stpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span>
                                                <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span> <span class="o">=</span> <span class="n">stpl_wave</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span> <span class="o">=</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check any input stellar template spectra</span>
        <span class="n">R_to_sinst</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">DAPConstants</span><span class="o">.</span><span class="n">sig2fwhm</span>
        <span class="k">if</span> <span class="n">stpl_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stpl_wave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide wavelengths if providing stellar template fluxes.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="n">tpl_sres</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_templates</span><span class="p">(</span><span class="n">stpl_wave</span><span class="p">,</span> <span class="n">stpl_flux</span><span class="p">,</span> <span class="n">tpl_sres</span><span class="o">=</span><span class="n">stpl_sres</span><span class="p">,</span>
                                              <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Check or instantiate the fit flags</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_template_usage_flags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span><span class="p">,</span> <span class="n">stpl_to_use</span><span class="p">)</span>

            <span class="c1"># etpl_sinst defaults to the instrumental dispersion of the</span>
            <span class="c1"># stellar templates</span>
            <span class="n">etpl_sinst</span> <span class="o">=</span> <span class="n">R_to_sinst</span><span class="o">/</span><span class="n">tpl_sres</span><span class="o">.</span><span class="n">sres</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">etpl_sinst</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: Allow the gas template resolution to be some fraction of</span>
        <span class="c1"># the stellar template resolution?</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Set the emission-line spectral resolution.</span>
        <span class="c1"># - If the object resolution and template resolution are not</span>
        <span class="c1">#   available, use the 2-pixel resolution</span>
        <span class="c1"># - If the object resolution is not available, set to the</span>
        <span class="c1">#   stellar template resolution (i.e., use what is set above)</span>
        <span class="c1"># - If the object resolution is available, set it to the minimum</span>
        <span class="c1">#   object resolution at each wavelength channel.</span>
        <span class="c1"># - Force the instrumental dispersion to 0 if requested by the</span>
        <span class="c1">#   input mode.</span>
        <span class="c1"># - Apply a quardrature offset if the dispersion dips below the</span>
        <span class="c1">#   imposed minimum or if the user requested to offset to the</span>
        <span class="c1">#   minimum.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span> <span class="o">=</span> <span class="n">matched_resolution</span>
        <span class="k">if</span> <span class="n">etpl_sinst</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">etpl_sinst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="o">/</span><span class="n">DAPConstants</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span>
                                          <span class="n">R_to_sinst</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                          <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
            <span class="n">etpl_sinst</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">)</span> 
                                                        <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="c1">#            pyplot.plot(self.obj_wave, interp.y)</span>
<span class="c1">#            pyplot.plot(self.tpl_wave, etpl_sinst)</span>
<span class="c1">#            _etpl_sinst = etpl_sinst.copy()</span>

        <span class="k">if</span> <span class="n">etpl_sinst_mode</span> <span class="o">==</span> <span class="s1">&#39;zero&#39;</span><span class="p">:</span>
            <span class="n">etpl_sinst</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">min_sinst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">etpl_sinst</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">etpl_sinst_mode</span> <span class="o">==</span> <span class="s1">&#39;offset&#39;</span> <span class="ow">and</span> <span class="n">min_sinst</span> <span class="o">&gt;</span> <span class="n">_etpl_sinst_min</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="n">min_sinst</span> <span class="o">&lt;</span> <span class="n">_etpl_sinst_min</span><span class="p">:</span>
            <span class="n">dsigma_inst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">min_sinst</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_etpl_sinst_min</span><span class="p">)</span>
            <span class="n">etpl_sinst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">etpl_sinst</span><span class="p">)</span> <span class="o">-</span> <span class="n">dsigma_inst</span><span class="p">)</span>
            <span class="n">min_sinst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">etpl_sinst</span><span class="p">)</span>
<span class="c1">#            print(min_sinst)</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, etpl_sinst)</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, numpy.sqrt(numpy.square(_etpl_sinst) - numpy.square(etpl_sinst)))</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        exit()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># If provided, check the shapes of the stellar kinematics</span>
        <span class="k">if</span> <span class="n">stellar_kinematics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stellar_kinematics</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided kinematics do not match the number of input object spectra.&#39;</span><span class="p">)</span>
        <span class="n">stellar_moments</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">stellar_kinematics</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stellar_kinematics</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stellar_kinematics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide stellar kinematics if refiting stellar templates.&#39;</span><span class="p">)</span>
        <span class="c1"># Convert velocities from cz to pPXF pixelized velocities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_stellar_kinematics</span> <span class="o">=</span> <span class="n">stellar_kinematics</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_stellar_kinematics</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">revert_velocity</span><span class="p">(</span><span class="n">stellar_kinematics</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                                                  <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Build the emission-line templates; the EmissionLineTemplates</span>
        <span class="c1"># object will check the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="n">emission_lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span>
        <span class="n">etpl</span> <span class="o">=</span> <span class="n">EmissionLineTemplates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">etpl_sinst</span><span class="p">,</span> <span class="n">emldb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">,</span>
                                     <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, numpy.sum(etpl.flux, axis=0))</span>
<span class="c1">#        for i in range(etpl.ntpl):</span>
<span class="c1">#            pyplot.plot(self.tpl_wave, etpl.flux[i,:])</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Report the resolution mode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Emission-line resolution mode: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">etpl_sinst_mode</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Imposed minimum instrumental dispersion: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">etpl_sinst_min</span><span class="p">))</span>

        <span class="c1"># Set the component associated with each emission line emission line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;action&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_tpli</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">tpli</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">etpl</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">etpl</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]])</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Save the basic pPXF parameters</span>
        <span class="c1"># TODO: Use the emission-line database to set the number of</span>
        <span class="c1"># moments to fit to each emission-line component.  For now it is</span>
        <span class="c1"># always moments=2!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">losvd_limits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mdegree</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="o">=</span> <span class="n">reddening</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="mi">2</span>                <span class="c1">#numpy.absolute(moments)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span> <span class="o">=</span> <span class="n">reject_boxcar</span>
<span class="c1">#        self.fix_kinematics = False     #moments &lt; 0</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Compile the template fluxes, components, and velocity and</span>
        <span class="c1"># sigma groups; the gas templates are always appended after the</span>
        <span class="c1"># stellar templates</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_tpl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">etpl</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">flux</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span><span class="n">etpl</span><span class="o">.</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">comp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_vgrp</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">vgrp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sgrp</span> <span class="o">=</span> <span class="n">etpl</span><span class="o">.</span><span class="n">sgrp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">moments</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comp_start_kin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">gk</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="k">for</span> <span class="n">gk</span> <span class="ow">in</span> <span class="n">guess_kin</span> <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_tpl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                        <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">etpl</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="n">etpl</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">,</span>
                                           <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span><span class="n">etpl</span><span class="o">.</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">),</span>
                                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">etpl</span><span class="o">.</span><span class="n">comp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_vgrp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">etpl</span><span class="o">.</span><span class="n">vgrp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sgrp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">etpl</span><span class="o">.</span><span class="n">sgrp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eml_tpli</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eml_compi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_eml</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">stellar_moments</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">moments</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comp_start_kin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="n">gk</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
                                            <span class="k">for</span> <span class="n">sk</span><span class="p">,</span><span class="n">gk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_stellar_kinematics</span><span class="p">,</span> <span class="n">guess_kin</span><span class="p">)</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#        # Set which components are gas components</span>
<span class="c1">#        self.gas_comp = numpy.ones(self.ncomp, dtype=bool)</span>
<span class="c1">#        if self.nstpl &gt; 0:</span>
<span class="c1">#            self.gas_comp[0] = False</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Parse the velocity and sigma groups into tied parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">tpl_index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">):</span>
            <span class="c1"># Do not allow tying to fixed components?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Velocity group of this component</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">[</span><span class="n">tpl_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_vgrp</span> <span class="o">==</span> <span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">parn</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[:</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">parn</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="s1">&#39;p[</span><span class="si">{0}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="c1"># Sigma group of this component</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">[</span><span class="n">tpl_index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_sgrp</span> <span class="o">==</span> <span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">parn</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[:</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span> <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">parn</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="s1">&#39;p[</span><span class="si">{0}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[[</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfree_kin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">])</span>

        <span class="c1"># Get the degrees of freedom (accounting for fixed stellar</span>
        <span class="c1"># component)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfree_kin</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])</span> \
                        <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># Check if tying parameters is needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfree_kin</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[:</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> 
                          <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)</span> <span class="p">]</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Report the input checks/results</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Number of stellar templates: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstpl</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Pixel scale: </span><span class="si">{0}</span><span class="s1"> km/s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Pixel scale ratio: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Dispersion limits: </span><span class="si">{0}</span><span class="s1"> - </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Model degrees of freedom: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of tied parameters: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tied</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nfree_kin</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Emission-line fits remapped to a set of </span><span class="si">{0}</span><span class="s1"> spectra.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span><span class="p">))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the output arrays.  This is done here for many of</span>
        <span class="c1"># these objects only in case PPXFFit.initialize_pixels_to_fit()</span>
        <span class="c1"># fails and the code returns without running the pPXF fitting.</span>
        <span class="c1">#  - Set the output shape and initial mask</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1">#  - Model flux and error (begins fully masked)</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">model_eml_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_eml_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#  - Model parameters and fit quality</span>
        <span class="n">model_fit_par</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_per_fit_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npar_kin</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">()))</span>
        <span class="c1">#  - Model emission-line parameters</span>
        <span class="n">model_eml_par</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_per_emission_line_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neml</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">()))</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;CONTMPLY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the mask and the spectral range to fit for the</span>
        <span class="c1"># input object spectra</span>
        <span class="c1"># TODO: This alters the mask of self.obj_flux!!</span>
        <span class="n">obj_model_mask</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">obj_start</span><span class="p">,</span> <span class="n">obj_end</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">initialize_pixels_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                       <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">obj_mask</span><span class="p">,</span>
                                                       <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                       <span class="n">velocity_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">,</span>
                                                       <span class="n">max_velocity_range</span><span class="o">=</span><span class="n">max_velocity_range</span><span class="p">,</span>
                                                       <span class="n">alias_window</span><span class="o">=</span><span class="n">alias_window</span><span class="p">,</span>
                                                       <span class="n">ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#False,</span>
                                                       <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
        <span class="n">ended_in_error</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">err</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Masking failures in some/all spectra.  Errors are: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">err</span><span class="p">)])[</span><span class="n">ended_in_error</span><span class="p">]))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">obj_model_mask</span><span class="p">,</span> \
                            <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not prepare spectra for fitting!&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the mask and the spectral range to fit for the</span>
        <span class="c1"># remapping spectra</span>
        <span class="c1"># TODO: This alters the mask of self.remap_flux!!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">remap_model_mask</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">remap_start</span><span class="p">,</span> <span class="n">remap_end</span> \
                        <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">initialize_pixels_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                           <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                           <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="c1"># mask=remap_mask,</span>
                                                           <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                        <span class="n">velocity_offset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">),</span>
                                                           <span class="n">max_velocity_range</span><span class="o">=</span><span class="n">max_velocity_range</span><span class="p">,</span>
                                                           <span class="n">alias_window</span><span class="o">=</span><span class="n">alias_window</span><span class="p">,</span>
                                                           <span class="n">ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#False,</span>
                                                           <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
            <span class="n">ended_in_error</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">err</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Masking failures in some/all remapping spectra.  &#39;</span>
                                  <span class="s1">&#39;Errors are: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">err</span><span class="p">)])[</span><span class="n">ended_in_error</span><span class="p">]))</span>
                <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
                <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">remap_model_mask</span><span class="p">,</span> \
                            <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remap_model_mask</span><span class="o">=</span> <span class="kc">None</span>
            <span class="n">remap_start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">remap_end</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the input pixel shift between the object and template</span>
        <span class="c1"># wavelength vectors; interpretted by pPXF as a base velocity</span>
        <span class="c1"># shift between the two.  This is a single number, used for both</span>
        <span class="c1"># the object spectra and the remapping spectra if provided</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">obj_start</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_start</span><span class="p">,</span> <span class="n">remap_start</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">obj_end</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_end</span><span class="p">,</span> <span class="n">remap_end</span><span class="p">))</span>

        <span class="n">model_mask</span> <span class="o">=</span> <span class="n">obj_model_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">remap_model_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span> <span class="o">=</span> <span class="o">-</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                        <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Call the emission line fitter contributed by Xihan Ji and</span>
        <span class="c1"># Michele Cappellari</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="c1">#        warnings.warn(&#39;debugging!&#39;)</span>
<span class="c1">#        self.obj_to_fit[ numpy.arange(self.nobj)[self.obj_to_fit][2:] ] = False</span>

        <span class="c1"># Prep:</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">flux_binned</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ferr_binned</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mask_binned</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">flux_binned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">ferr_binned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">mask_binned</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>

        <span class="c1"># Run the fitter</span>
        <span class="n">model_flux</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">model_eml_flux</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">_model_mask</span><span class="p">,</span> <span class="n">model_wgts</span><span class="p">,</span> \
                <span class="n">model_wgts_err</span><span class="p">,</span> <span class="n">model_addcoef</span><span class="p">,</span> <span class="n">model_multcoef</span><span class="p">,</span> <span class="n">model_reddening</span><span class="p">,</span> <span class="n">model_kin_inp</span><span class="p">,</span> \
                <span class="n">model_kin</span><span class="p">,</span> <span class="n">model_kin_err</span><span class="p">,</span> <span class="n">nearest_bin</span> \
                            <span class="o">=</span> <span class="n">emline_fitter_with_ppxf_edit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">tpl_comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_tpl</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">comp_moments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_start_kin</span><span class="p">,</span>
                                                           <span class="n">tied</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tied</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span>
                                                           <span class="n">mdegree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">,</span>
                                                           <span class="n">reddening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reddening</span><span class="p">,</span>
                                                           <span class="n">reject_boxcar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span><span class="p">,</span>
                                                           <span class="n">vsyst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span>
                                                           <span class="n">tpl_to_use</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">,</span>
                                                           <span class="n">flux_binned</span><span class="o">=</span><span class="n">flux_binned</span><span class="p">,</span>
                                                           <span class="n">noise_binned</span><span class="o">=</span><span class="n">ferr_binned</span><span class="p">,</span>
                                                           <span class="n">mask_binned</span><span class="o">=</span><span class="n">mask_binned</span><span class="p">,</span>
                                                           <span class="n">x_binned</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_skyx</span><span class="p">,</span>
                                                           <span class="n">y_binned</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_skyy</span><span class="p">,</span>
                                                           <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">remap_skyx</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">remap_skyy</span><span class="p">,</span>
                                                           <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="ow">not</span> <span class="n">plot</span><span class="p">)</span>
<span class="c1">#                                                           plot=True, quiet=False)</span>

        <span class="c1"># Construct the bin ID numbers</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;NEAREST_BIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_bin</span>

        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model_eml_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">#        result = self._fit_all_spectra(plot=plot)#, plot_file_root=plot_file_root)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Fits completed in </span><span class="si">{0:.4e}</span><span class="s1"> min.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>

        <span class="c1"># Flag pixels as rejected during fitting; _model_mask is True</span>
        <span class="c1"># where the pixels were fit</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">_model_mask</span><span class="p">)</span>
        <span class="n">model_mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span>
                                                             <span class="n">PPXFFit</span><span class="o">.</span><span class="n">rej_flag</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Save the results</span>
<span class="c1">#        model_flux, model_eml_flux, model_mask, model_fit_par, model_eml_par \</span>
<span class="c1">#                = self._save_results(etpl, result, model_mask, model_fit_par, model_eml_par)</span>

<span class="c1">#        pyplot.imshow(numpy.log10(model_mask), origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="c1">#                      aspect=&#39;auto&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nremap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_flux</span>
            <span class="n">ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_ferr</span>
        <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_results</span><span class="p">(</span><span class="n">etpl</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">ferr</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span>
                                     <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_wgts</span><span class="p">,</span> <span class="n">model_wgts_err</span><span class="p">,</span> <span class="n">model_addcoef</span><span class="p">,</span>
                                     <span class="n">model_multcoef</span><span class="p">,</span> <span class="n">model_reddening</span><span class="p">,</span> <span class="n">model_kin_inp</span><span class="p">,</span> <span class="n">model_kin</span><span class="p">,</span>
                                     <span class="n">model_kin_err</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Sasuke finished&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">model_eml_par</span></div>


<div class="viewcode-block" id="Sasuke.construct_continuum_models"><a class="viewcode-back" href="../../../mangadap.proc.sasuke.html#mangadap.proc.sasuke.Sasuke.construct_continuum_models">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">construct_continuum_models</span><span class="p">(</span><span class="n">emission_lines</span><span class="p">,</span> <span class="n">stpl_wave</span><span class="p">,</span> <span class="n">stpl_flux</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux_shape</span><span class="p">,</span>
                                   <span class="n">model_fit_par</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">deredshift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dispersion_corrections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the continuum models using the provided set of model</span>
<span class="sd">        parameters.</span>
<span class="sd">        </span>
<span class="sd">        This is a wrapper for :class:`PPXFModel`, and very similar to</span>
<span class="sd">        :func:`mangadap.proc.ppxffit.PPXFFit.contruct_models`.</span>

<span class="sd">        The input velocities are expected to be cz, not &quot;ppxf&quot;</span>
<span class="sd">        (pixelized) velocities.</span>

<span class="sd">        If redshift_only is true, the provided dispersion is set to 1e-9</span>
<span class="sd">        km/s, which is numerically identical to 0 (i.e., just shifting</span>
<span class="sd">        the spectrum) in the tested applications.  However, beware that</span>
<span class="sd">        this is a HARDCODED number.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">redshift_only</span> <span class="ow">and</span> <span class="n">dispersion_corrections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;redshift_only and dispersion_corrections are mutually exclusive.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deredshift</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet deredshift models.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check the spectral sampling</span>
        <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">)</span>
                                <span class="o">/</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">stpl_wave</span><span class="p">)))</span>
        <span class="n">_velscale</span><span class="p">,</span> <span class="n">_velscale_ratio</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_pixel_scale</span><span class="p">(</span><span class="n">stpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                             <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">)</span>
        <span class="c1"># Check the input spectra</span>
        <span class="n">obj_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">_obj_wave</span><span class="p">,</span> <span class="n">_obj_flux</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">)</span>
        <span class="n">nobj</span> <span class="o">=</span> <span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_stpl_wave</span><span class="p">,</span> <span class="n">_stpl_flux</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_templates</span><span class="p">(</span><span class="n">stpl_wave</span><span class="p">,</span> <span class="n">stpl_flux</span><span class="p">,</span>
                                                          <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">)</span>
        <span class="n">nstpl</span> <span class="o">=</span> <span class="n">_stpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Construct the emission-line templates, just to determine how</span>
        <span class="c1"># many of them there should be</span>
        <span class="n">etpl</span> <span class="o">=</span> <span class="n">EmissionLineTemplates</span><span class="p">(</span><span class="n">_stpl_wave</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_stpl_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                                     <span class="n">emldb</span><span class="o">=</span><span class="n">emission_lines</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_ntpl</span> <span class="o">=</span> <span class="n">nstpl</span><span class="o">+</span><span class="n">etpl</span><span class="o">.</span><span class="n">ntpl</span>
        <span class="n">ngas_comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">etpl</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        
        <span class="c1"># Check the shape of the input model parameter database</span>
        <span class="k">if</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of model-parameter sets.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">_ntpl</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of weights does not match the number of templates.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the input pixel shift between the object and template</span>
        <span class="c1"># wavelength vectors; interpretted by pPXF as a base velocity</span>
        <span class="c1"># shift between the two.  For Sasuke, start and end should be</span>
        <span class="c1"># the same, but leave it as general.</span>
        <span class="n">vsyst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="n">_stpl_wave</span><span class="p">,</span> <span class="n">_obj_wave</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">],</span> <span class="n">_velscale</span><span class="p">,</span>
                                                         <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">],</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">])])</span>

        <span class="c1"># Get the additive and multiplicative degree of the polynomials</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">degree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">mdegree</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">mdegree</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdegree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">mdegree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Determine what to use for the reddening; assume it is fit if</span>
        <span class="c1"># the multiplicative polynomial is not fit.  Even if neither are</span>
        <span class="c1"># fit, Sasuke sets the reddening to 0 such that the correct</span>
        <span class="c1"># model will be returned</span>
        <span class="n">reddening</span> <span class="o">=</span> <span class="n">mdegree</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Determine the number of stellar kinematic moments.  The number</span>
        <span class="c1"># of gas moments is currently HARD-WIRED to be 2, meaning that</span>
        <span class="c1"># the number stellar kinematic moments is just:</span>
        <span class="n">smoments</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">ngas_comp</span>

        <span class="c1"># Only produce selected models</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>

        <span class="c1"># Instantiate the output model array</span>
        <span class="n">models</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1"># Initially mask everything</span>
        <span class="n">models</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Get the kinematics to use</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()[:,:</span><span class="n">smoments</span><span class="p">]</span>
        <span class="n">kin</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">revert_velocity</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">redshift_only</span><span class="p">:</span>
            <span class="n">kin</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="k">elif</span> <span class="n">dispersion_corrections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kin</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span> 
                                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dispersion_corrections</span><span class="p">))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">)</span>
<span class="c1">#        if deredshift:</span>
<span class="c1">#            kin[:,0] = 0.0</span>

        <span class="c1"># Construct the model for each (selected) object spectrum</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skip</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">ebv</span> <span class="o">=</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;EBV&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">reddening</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing continuum for spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nobj</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># This is redeclared every iteration to allow for the</span>
            <span class="c1"># starting and ending pixels to be different (annoying); as</span>
            <span class="c1"># will the velocity offset; this means that the FFT of the</span>
            <span class="c1"># templates is recalculated at every step...</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">PPXFModel</span><span class="p">(</span><span class="n">_stpl_flux</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                          <span class="n">_obj_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]],</span>
                          <span class="n">_velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="n">moments</span><span class="o">=</span><span class="n">smoments</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="n">ebv</span><span class="p">)</span>

            <span class="n">models</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span><span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> \
                        <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">kin</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:</span><span class="n">nstpl</span><span class="p">],</span>
                            <span class="n">addpoly</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:],</span>
                            <span class="n">multpoly</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">mdegree</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">model_fit_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:],</span>
                            <span class="n">reddening</span><span class="o">=</span><span class="n">ebv</span><span class="p">)</span>

<span class="c1">#            if i == 0 or redshift_only:</span>
<span class="c1">#                pyplot.plot(_obj_wave, _obj_flux[i,:])</span>
<span class="c1">#                pyplot.plot(_obj_wave, models[i,:])</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#                if redshift_only:</span>
<span class="c1">#                    exit()</span>
<span class="c1">#</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing continuum for spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nobj</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">models</span></div></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>