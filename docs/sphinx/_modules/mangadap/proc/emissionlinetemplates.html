

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.emissionlinetemplates &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.emissionlinetemplates</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.emissionlinetemplates</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Class that constructs a set of emission-line templates, primarily for</span>
<span class="sd">use with :class:`mangadap.proc.sasuke.Sasuke`.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2017, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/emissionlinetemplates.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import os</span>
<span class="sd">        import time</span>
<span class="sd">        import logging</span>

<span class="sd">        import numpy</span>
<span class="sd">        from scipy import interpolate</span>

<span class="sd">        import astropy.constants</span>

<span class="sd">        from ..util.instrument import spectrum_velocity_scale, spectral_coordinate_step</span>
<span class="sd">        from ..util.log import log_output</span>
<span class="sd">        from ..util import lineprofiles</span>
<span class="sd">        from .spectralfitting import EmissionLineFit</span>

<span class="sd">*Class usage examples*:</span>

<span class="sd">    To construct emission-line templates, you need a wavelength vector,</span>
<span class="sd">    the instrumental resolution at which to construct the templates, and</span>
<span class="sd">    an emission line database (see</span>
<span class="sd">    :class:`mangadap.par.emissionlinedb.EmissionLineDB`).  A simple</span>
<span class="sd">    construction would be::</span>
<span class="sd">        </span>
<span class="sd">        # Imports</span>
<span class="sd">        import numpy</span>
<span class="sd">        from mangadap.par.emissionlinedb import EmissionLineDB</span>
<span class="sd">        from mangadap.proc.emissionlinetemplates import EmissionLineTemplates</span>

<span class="sd">        wave = numpy.logspace(*(numpy.log10([3600,10300]), 4563)</span>
<span class="sd">        sigma_inst = 30                     # Instrumental resolution in km/s</span>

<span class="sd">        tpl = EmissionLineTemplates(wave, sigma_inst, emldb=EmissionLineDB(&#39;ELPMILES&#39;))</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **08 Sep 2017**: Originally pulled from</span>
<span class="sd">        :mod:`mangadap.proc.sasuke` by K. Westfall (KBW)</span>

<span class="sd">.. _scipy.interpolate.interp1d: https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>

<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">spectrum_velocity_scale</span><span class="p">,</span> <span class="n">spectral_coordinate_step</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="k">import</span> <span class="n">lineprofiles</span>
<span class="kn">from</span> <span class="nn">.spectralfitting</span> <span class="k">import</span> <span class="n">EmissionLineFit</span>

<span class="c1"># For debugging</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<div class="viewcode-block" id="EmissionLineTemplates"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinetemplates.html#mangadap.proc.emissionlinetemplates.EmissionLineTemplates">[docs]</a><span class="k">class</span> <span class="nc">EmissionLineTemplates</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a set of emission-line templates based on an emission-line</span>
<span class="sd">    database, primarily for use in :class:`mangadap.proc.sasuke.Sasuke`.</span>

<span class="sd">    The templates are constructed based on the constraints provided by</span>
<span class="sd">    the emission-line database.  See</span>
<span class="sd">    :class:`mangadap.par.emissionlinedb.EmissionLinePar` for the</span>
<span class="sd">    structure of each row in the database and an explanation for each of</span>
<span class="sd">    its columns.  The selected profile type for each line **must** have</span>
<span class="sd">    a `parameters_from_moments` method that returns the parameters of</span>
<span class="sd">    the line provided the first three moments (moments 0, 1, and 2).</span>

<span class="sd">    Only lines with `action=f` are included in any template.  The array</span>
<span class="sd">    :attr:`tpli` provides the index of the template that contains each</span>
<span class="sd">    line in the emission-line database.  Lines that are not assigned to</span>
<span class="sd">    any template --- either because they do not have `action=f` or their</span>
<span class="sd">    center lies outside the wavelength range in :attr:`wave` --- are</span>
<span class="sd">    given an index of -1.</span>

<span class="sd">    Only lines with `mode=a` (i.e., flux, velocity, and velocity</span>
<span class="sd">    dispersion are all tied) are included in the same template.</span>

<span class="sd">    Lines with tied velocities are assigned the same velocity component</span>
<span class="sd">    (:attr:`vgrp`) and lines with the tied velocity dispersions are</span>
<span class="sd">    assigned the same sigma component (:attr:`sgrp`).</span>

<span class="sd">    .. warning::</span>

<span class="sd">        The construction of templates for use with :class:`Sasuke` does</span>
<span class="sd">        *not* allow one to tie fluxes while leaving the velocities</span>
<span class="sd">        and/or velocity dispersions as independent.</span>

<span class="sd">    Args:</span>
<span class="sd">        wave (array-like): A single wavelength vector with the</span>
<span class="sd">            wavelengths for the template spectra.  The wavelengths are</span>
<span class="sd">            expected to be sample either linearly or geometrically (see</span>
<span class="sd">            :attr:`log`).</span>
<span class="sd">        sigma_inst (float,array-like): The single value or value as a</span>
<span class="sd">            function of wavelength for the instrumental dispersion</span>
<span class="sd">            (km/s) to use for the template construction.</span>
<span class="sd">        log (bool): (**Optional**) Flag that the wavelengths have been</span>
<span class="sd">            sampled geometrically.</span>
<span class="sd">        base (float): (**Optional**) Base for the geometric sampling.</span>
<span class="sd">        emldb (:class:`mangadap.par.emissionlinedb.EmissionLineDB&#39;):</span>
<span class="sd">            (**Optional**) Emission-line database that is parsed to</span>
<span class="sd">            setup which lines to include in the same template because</span>
<span class="sd">            they are modeled as having the same velocity, velocity</span>
<span class="sd">            dispersion and flux ratio.  If not provided, no templates</span>
<span class="sd">            are constructed in instantiation; to build the templates</span>
<span class="sd">            using an existing instantiation, use</span>
<span class="sd">            :func:`build_templates`.</span>
<span class="sd">        flux_density (bool): (**Optional**) Return spectrum in units of</span>
<span class="sd">            flux density (flux per angstrom).  Default is to return the</span>
<span class="sd">            spectrum in units of flux per pixel.</span>
<span class="sd">        loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">            to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">            using :func:`mangadap.util.log.log_output`.  Default is no</span>
<span class="sd">            logging.  This can be reset in some methods.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress all terminal and logging</span>
<span class="sd">            output.  Default is False.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        wave (numpy.ndarray): Array with the wavelength (angstroms) of</span>
<span class="sd">            each pixel for all the constructed templates.  Shape is</span>
<span class="sd">            :math:`N_{\rm pix}`.</span>
<span class="sd">        sigma_inst (`scipy.interpolate.interp1d`_): The object used to</span>
<span class="sd">            interpolate the instrumental dispersion (km/s) at the rest</span>
<span class="sd">            wavelength of each spectral line.</span>
<span class="sd">        log (bool): Flag that the spectrum is sampled geometrically.</span>
<span class="sd">        base (float): Base for the geometric sampling.</span>
<span class="sd">        emldb (:class:`mangadap.par.emissionlinedb.EmissionLineDB`):</span>
<span class="sd">            Database with the emission-line parameters.  Shape is</span>
<span class="sd">            (:math:`N_{\rm pix}`,).</span>
<span class="sd">        ntpl (int): Total number of templates.</span>
<span class="sd">        flux (numpy.ndarray): The template spectra.  Shape is</span>
<span class="sd">            :math:`(N_{\rm tpl},N_{\rm pix})`.</span>
<span class="sd">        tpli (numpy.ndarray): The index of the template containing each</span>
<span class="sd">            emission line.  Any emission-lines with `tpli==-1` means</span>
<span class="sd">            that the emission line was not included in any template,</span>
<span class="sd">            which should only occur for lines with ``action==i` in the</span>
<span class="sd">            database.  Shape is (:math:`N_{\rm eml}`,).</span>
<span class="sd">        comp (numpy.ndarray): The component number assigned to each</span>
<span class="sd">            template.  Templates with the same component number are</span>
<span class="sd">            forced to have the same velocity and velocity dispersion by</span>
<span class="sd">            pPXF.  Shape is (:math:`N_{\rm tpl}`,).</span>
<span class="sd">        vgrp (numpy.ndarray): The velocity group assigned to each</span>
<span class="sd">            template.  Templates in the same velocity group have their</span>
<span class="sd">            velocity parameters tied in pPXF, but the velocity</span>
<span class="sd">            dispersion parameters are independent.  Shape is</span>
<span class="sd">            (:math:`N_{\rm tpl}`,).</span>
<span class="sd">        sgrp (numpy.ndarray): The velocity disperison (sigma) group</span>
<span class="sd">            assigned to each template.  Templates in the same sigma</span>
<span class="sd">            group have their velocity dispersion parameters tied in</span>
<span class="sd">            pPXF, but the velocity parameters are independent.  Shape is</span>
<span class="sd">            (:math:`N_{\rm tpl}`,).</span>
<span class="sd">        eml_sigma_inst (numpy.ndarray): The instrumental dispersion</span>
<span class="sd">            (km/s) at the rest wavelength of each emission line.  This</span>
<span class="sd">            is mostly used to aid the velocity dispersion corrections</span>
<span class="sd">            determined by :class:`Sasuke`.  Shape is (:math:`N_{\rm</span>
<span class="sd">            eml}`,).</span>
<span class="sd">        loggers (list): List of `logging.Logger`_ objects to log</span>
<span class="sd">            progress; ignored if quiet=True.  Logging is done using</span>
<span class="sd">            :func:`mangadap.util.log.log_output`.</span>
<span class="sd">        quiet (bool): Suppress all terminal and logging output.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">sigma_inst</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">emldb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux_density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="o">=</span><span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided wavelengths must be a single vector.&#39;</span><span class="p">)</span>

        <span class="n">_sinst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">sigma_inst</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma_inst</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma_inst</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_sinst</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided sigma_inst must be a single number or a vector with the&#39;</span>
                             <span class="s1">&#39;same length as the wavelength vector.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_inst</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">_sinst</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>

<span class="c1">#        self.dv = numpy.full(self.wave.size, spectrum_velocity_scale(wave), dtype=float) if log \</span>
<span class="c1">#                    else astropy.constants.c.to(&#39;km/s&#39;).value*spectral_coordinate_step(wave)/wave</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="kc">None</span>           <span class="c1"># Original database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_density</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># Templates are in flux per Angstrom, not flux per pixel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Number of templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Template fluxes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Template associated with each emission line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Kinematic component associated with each template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Velocity group associated with each template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span> <span class="o">=</span> <span class="kc">None</span>            <span class="c1"># Sigma group associated with each template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_sigma_inst</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Instrumental dispersion at the center of each line</span>

        <span class="c1"># If emission-line database is provided, use it to build the templates</span>
        <span class="k">if</span> <span class="n">emldb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_templates</span><span class="p">(</span><span class="n">emldb</span><span class="p">,</span> <span class="n">flux_density</span><span class="o">=</span><span class="n">flux_density</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


<div class="viewcode-block" id="EmissionLineTemplates._tied_index"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinetemplates.html#mangadap.proc.emissionlinetemplates.EmissionLineTemplates._tied_index">[docs]</a>    <span class="k">def</span> <span class="nf">_tied_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">primary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index of the line to which this one is tied.</span>
<span class="sd">        </span>
<span class="sd">        The result may be that this line is tied to one that is also</span>
<span class="sd">        tied to a second line.  If that&#39;s the case, the ``primary``</span>
<span class="sd">        keyword can be use to trace the parameter tying back to the</span>
<span class="sd">        independent line.</span>

<span class="sd">        Arg:</span>
<span class="sd">            i (int): The index of the line in the database.</span>
<span class="sd">            primary (bool): (**Optional**) Trace the line tying all the</span>
<span class="sd">                way back to the independent (primary) line.</span>

<span class="sd">        Return:</span>
<span class="sd">            int: The index of the line to which this one is tied.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the primary option is selected and the</span>
<span class="sd">                line does not trace back to a primary line.  This</span>
<span class="sd">                represents a poorly constructed emission-line database</span>
<span class="sd">                and should be avoided!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_rows</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">db_rows</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">primary</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indx</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">db_rows</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">max_iter</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Line </span><span class="si">{0}</span><span class="s1"> (index=</span><span class="si">{1}</span><span class="s1">) does not trace back to a primary line!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">indx</span></div>


<div class="viewcode-block" id="EmissionLineTemplates._parse_emission_line_database"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinetemplates.html#mangadap.proc.emissionlinetemplates.EmissionLineTemplates._parse_emission_line_database">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_emission_line_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the input emission-line database; see</span>
<span class="sd">        :class:`mangadap.par.emissionlinedb.EmissionLinePar`.</span>

<span class="sd">        Only lines with `action=f` are included in any template.  The</span>
<span class="sd">        array :attr:`tpli` provides the index of the template that</span>
<span class="sd">        contains each line in the emission-line database.  Lines that</span>
<span class="sd">        are not assigned to any template --- either because they do not</span>
<span class="sd">        have `action=f` or their center lies outside the wavelength</span>
<span class="sd">        range in :attr:`wave` --- are given an index of -1.</span>

<span class="sd">        Only lines with `mode=a` (i.e., tie flux, velocity, and velocity</span>
<span class="sd">        dispersion) are included in the same template.</span>

<span class="sd">        Lines with tied velocities are assigned the same velocity</span>
<span class="sd">        component (:attr:`vgrp`) and lines with the tied velocity</span>
<span class="sd">        dispersions are assigned the same sigma component</span>
<span class="sd">        (:attr:`sgrp`).</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The construction of templates for use with :class:`Sasuke`</span>
<span class="sd">            does *not* allow one to tie fluxes while leaving the</span>
<span class="sd">            velocities and/or velocity dispersions as independent.</span>

<span class="sd">        This is an entirely internal procedure, taking no arguments and</span>
<span class="sd">        only assigning results to self.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the parsing of the database leaves</span>
<span class="sd">                some templates without an assigned component, velocity</span>
<span class="sd">                group, and/or sigma group.  This implies an error in the</span>
<span class="sd">                construction of the emission-line database, not the code</span>
<span class="sd">                itself.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the list of lines to ignore</span>
        <span class="n">ignore_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;action&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span>

        <span class="c1"># The total number of templates to construct is the number of</span>
        <span class="c1"># lines in the database minus the number of lines with mode=aN</span>
        <span class="n">tied_all</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ignore_line</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tied_all</span><span class="p">)</span>

        <span class="c1"># Initialize the components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        <span class="c1"># All the primary lines go into individual templates, kinematic</span>
        <span class="c1"># components, velocity groups, and sigma groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">primary_line</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">ignore_line</span><span class="p">)</span>
        <span class="n">nprimary</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">primary_line</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">primary_line</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprimary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[:</span><span class="n">nprimary</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprimary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[:</span><span class="n">nprimary</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprimary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[:</span><span class="n">nprimary</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nprimary</span><span class="p">)</span>

        <span class="n">finished</span> <span class="o">=</span> <span class="n">primary_line</span> <span class="o">|</span> <span class="n">ignore_line</span>
        <span class="k">while</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">:</span>
            <span class="c1"># Find the indices of lines that are tied to finished lines</span>
            <span class="n">start_sum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">finished</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">finished</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tied_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">[</span><span class="n">indx</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="n">finished</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Mode=a: Line is part of an existing template</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
                <span class="c1"># Mode=k: Line is part of a different template but an</span>
                <span class="c1"># existing kinematic component</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
                <span class="c1"># Mode=v: Line is part of a different template and</span>
                <span class="c1"># kinematic component with an untied sigma, but tied to</span>
                <span class="c1"># an existing velocity group</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
                <span class="c1"># Mode=s: Line is part of a different template and</span>
                <span class="c1"># kinematic component with an untied velocity, but tied</span>
                <span class="c1"># to an existing sigma group</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>

            <span class="c1"># If the loop ends up with the same number of parsed lines</span>
            <span class="c1"># that it started with, there must be an error in the</span>
            <span class="c1"># construction of the input database.</span>
            <span class="k">if</span> <span class="n">start_sum</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">finished</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to parse the input database.  Check tying parameters.&#39;</span><span class="p">)</span>

        <span class="c1"># Debug:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Templates without an assigned component.  Check the input database.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineTemplates.check_database"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinetemplates.html#mangadap.proc.emissionlinetemplates.EmissionLineTemplates.check_database">[docs]</a>    <span class="k">def</span> <span class="nf">check_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emldb</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the provided emission-line database can be used with</span>
<span class="sd">        the :class:`EmissionLineTemplates` class.  Most checks are</span>
<span class="sd">        performed by</span>
<span class="sd">        :func:`mangadap.proc.spectralfitting.EmissionLineFit.check_emission_line_database`.</span>

<span class="sd">        Additional checks specific to :class:`EmissionLineTemplates`</span>
<span class="sd">        are:</span>
<span class="sd">            - Any lines with mode `w` is treated as `f` and a warning is</span>
<span class="sd">              provided.</span>
<span class="sd">            - The :class:`EmissionLineTemplates` object *cannot* be used</span>
<span class="sd">              with mode `x`; any lines with this mode will cause a</span>
<span class="sd">              ValueError to be raised..</span>

<span class="sd">        This function does *not* check if the initial parameters</span>
<span class="sd">        provided by the database are consistent with other elements in</span>
<span class="sd">        the database because they are not used to construct the</span>
<span class="sd">        templates.</span>

<span class="sd">        Args:</span>
<span class="sd">            emldb (:class:`mangadap.par.emissionlinedb.EmissionLineDB&#39;):</span>
<span class="sd">                Emission-line database.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: Raised if the provided object is not an instance</span>
<span class="sd">                of :class:`mangadap.par.emissionlinedb.EmissionLineDB`.</span>
<span class="sd">            ValueError: Raised if any line has a mode of `x` or if the</span>
<span class="sd">                database does not provide a valid definition for any</span>
<span class="sd">                templates.</span>
<span class="sd">            NameError: Raised if a defined profile type is not known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">EmissionLineFit</span><span class="o">.</span><span class="n">check_emission_line_database</span><span class="p">(</span><span class="n">emldb</span><span class="p">,</span> <span class="n">wave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">check_par</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Check that no lines only tie the fluxes</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot tie only fluxes in an EmissionLineTemplates object.&#39;</span><span class="p">)</span>

        <span class="c1"># Warn user of any lines with mode=w</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]]):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Any line with mode=w treated the same as mode=f.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmissionLineTemplates.build_templates"><a class="viewcode-back" href="../../../mangadap.proc.emissionlinetemplates.html#mangadap.proc.emissionlinetemplates.EmissionLineTemplates.build_templates">[docs]</a>    <span class="k">def</span> <span class="nf">build_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emldb</span><span class="p">,</span> <span class="n">flux_density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the set of templates for a given emission-line database.</span>
<span class="sd">        The function uses the current values in :attr:`wave` and</span>
<span class="sd">        :attr:`sigma_inst`.  Any existing templates from a previous call</span>
<span class="sd">        to :func:`build_templates` or from the object instantiation will</span>
<span class="sd">        be overwritten using the provided emission-line database.</span>

<span class="sd">        See :func:`check_database` for the requirements of the provided</span>
<span class="sd">        emission-line database, and see</span>
<span class="sd">        :func:`_parse_emission_line_database` for how the database is</span>
<span class="sd">        interpretted when constructing the templates.</span>

<span class="sd">        The function constructs and returns the following attributes:</span>
<span class="sd">        :attr:`flux`, :attr:`comp`, :attr:`vgrp`, and :attr:`sgrp` </span>

<span class="sd">        .. todo::</span>

<span class="sd">            - Warn the user if any line is undersampled; i.e., the FWHM</span>
<span class="sd">              of the line is less than 2.1 or sigma &lt; 0.9.</span>

<span class="sd">            - Warn the user if any line grouped in the same template</span>
<span class="sd">              falls outside the spectral range.</span>

<span class="sd">        Args:</span>
<span class="sd">            emldb (:class:`mangadap.par.emissionlinedb.EmissionLineDB&#39;):</span>
<span class="sd">                Emission-line database.</span>
<span class="sd">            flux_density (bool): (**Optional**) Return spectrum in units</span>
<span class="sd">                of flux density (flux per angstrom).  Default is to</span>
<span class="sd">                return the spectrum in units of flux per pixel.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_</span>
<span class="sd">                objects to log progress; ignored if quiet=True.  Logging</span>
<span class="sd">                is done using :func:`mangadap.util.log.log_output`.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Returns 4 arrays: (1) the set of templates</span>
<span class="sd">            with shape :math:`N_{\rm tpl}\times N_{\rm wave}`, (2) the</span>
<span class="sd">            kinematic component assignement for each template, (3) the</span>
<span class="sd">            velocity group associated with each template, and (4) the</span>
<span class="sd">            sigma group assocated with each template.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_density</span> <span class="o">=</span> <span class="n">flux_density</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check the database can be used with this class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_database</span><span class="p">(</span><span class="n">emldb</span><span class="p">)</span>
        <span class="c1"># Save a pointer to the database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span> <span class="o">=</span> <span class="n">emldb</span>
        <span class="c1"># Parse the database for construction of the templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_emission_line_database</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission lines to fit: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission-line templates: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission-line kinematic components: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission-line velocity groups: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of emission-line sigma groups: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Get the instrumental dispersion at the center of each line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eml_sigma_inst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_inst</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">])</span>
<span class="c1">#        pyplot.plot(self.sigma_inst.x, self.sigma_inst.y, lw=2)</span>
<span class="c1">#        pyplot.plot(self.sigma_inst.x, 2.5*astropy.constants.c.to(&#39;km/s&#39;).value/self.sigma_inst.x/2.355)</span>
<span class="c1">#        pyplot.scatter(self.emldb[&#39;restwave&#39;], self.eml_sigma_inst, marker=&#39;.&#39;, s=100, lw=0,</span>
<span class="c1">#                       color=&#39;C2&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Convert from wavelengths to pixel coordinates</span>
        <span class="n">_wave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span>
        <span class="n">_dw</span> <span class="o">=</span> <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
        <span class="n">_restwave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> \
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">]</span>

        <span class="c1"># Rest wavelength in pixel units</span>
        <span class="n">_restwave</span> <span class="o">=</span> <span class="p">(</span><span class="n">_restwave</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">_dw</span>
        <span class="c1"># Flux to pixel units; less accurate when spectrum is</span>
        <span class="c1"># logarithmically binned</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span><span class="n">_dw</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span><span class="o">-</span><span class="n">_dw</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> \
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="n">_dw</span>
        <span class="n">_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">dl</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_density</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;flux&#39;</span><span class="p">]</span>
        <span class="c1"># Dispersion in pixel units</span>
        <span class="n">_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eml_sigma_inst</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;restwave&#39;</span><span class="p">]</span> \
                        <span class="o">/</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">dl</span>

        <span class="c1"># Construct the templates</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">):</span>
            <span class="c1"># Find all the lines associated with this template:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="o">.</span><span class="n">neml</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">tpli</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Add each line to the template</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="c1"># Declare an instance of the desired profile</span>
                <span class="n">profile</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;lineprofiles.&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">emldb</span><span class="p">[</span><span class="s1">&#39;profile&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])()</span>
                <span class="c1"># Use the first three moments of the line to set the</span>
                <span class="c1"># parameters</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">parameters_from_moments</span><span class="p">(</span><span class="n">_flux</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">_restwave</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">_sigma</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="c1">#                print(p)</span>
<span class="c1">#                f = profile(pix, p)</span>
<span class="c1">#                d = numpy.power(self.base, _wave + _dw/2) - numpy.power(self.base, _wave - _dw/2)</span>
<span class="c1">#                print(numpy.sum(d*f))</span>
<span class="c1">#                print(numpy.sum(f))</span>
<span class="c1">#                print(self.eml_sigma_inst[j])</span>
<span class="c1">#                print(numpy.amax(f))</span>
<span class="c1">#                print(numpy.amax(f)/2)</span>
<span class="c1">#                pyplot.plot(self.wave, f)</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#                # Warn the user if the line is undersampled.</span>
<span class="c1">#                srt = numpy.argsort(numpy.absolute(v))</span>
<span class="c1">#                if self.eml_sigma_inst[j]/self.dv[srt[0]] &lt; 0.9:</span>
<span class="c1">#                    warnings.warn(&#39;{0} line is undersampled!&#39;.format(self.emldb[&#39;name&#39;][j]))</span>
                <span class="c1"># Add the line to the flux in this template</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">profile</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

                <span class="c1">#line_spec = profile(pix,p)</span>
                <span class="c1">#line_spec *= (_flux[j]/numpy.sum(line_spec))</span>
                <span class="c1">#print(numpy.sum(line_spec), _flux[j], numpy.sum(line_spec)/_flux[j])</span>
                <span class="c1">#self.flux[i,:] += line_spec</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vgrp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgrp</span></div></div>




</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>