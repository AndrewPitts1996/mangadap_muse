

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.templatelibrary &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.proc.templatelibrary</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.templatelibrary</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Class that reads and prepares template libraries for use in fitting the</span>
<span class="sd">stellar-continuum of a spectrum.  See</span>
<span class="sd">:func:`available_template_libraries` for the list of default template</span>
<span class="sd">libraries.</span>

<span class="sd">The &quot;raw&quot; template libraries are expected to consist of 1D fits files.</span>
<span class="sd">The wavelength sampling can be either linear or logarithmic in</span>
<span class="sd">wavelength.  The reference frame of the template wavelengths must be</span>
<span class="sd">defined as either vacuum or air.  It is expected that the object spectra</span>
<span class="sd">to be fit are calibrated to vacuum wavelengths.  When preparing the</span>
<span class="sd">template spectra for analysis, this class will use</span>
<span class="sd">`pydl.goddard.astro.airtovac`_ to convert the template wavelengths to</span>
<span class="sd">vacuum.  Finally, one can specify that the template library is only</span>
<span class="sd">valid within a certain wavelength range and above a certian flux limit;</span>
<span class="sd">see :class:`TemplateLibraryDef`.</span>

<span class="sd">Preparation of the template library for use in stellar-continuum fitting</span>
<span class="sd">consists of a number of steps as described in the documentation of</span>
<span class="sd">:func:`TemplateLibrary.process_template_library`.</span>

<span class="sd">A template library that has been prepared for analysis is automatically</span>
<span class="sd">written to disk for later recovery.</span>

<span class="sd">Two support classes are also provided.  One is a derived</span>
<span class="sd">:class:`mangadap.par.parset.ParSet` instance that provides the defining</span>
<span class="sd">parameters of a DAP template library.  The second is a derived</span>
<span class="sd">:class:`mangadap.util.bitmask.BitMask` instance that defines the</span>
<span class="sd">bitmasks for the template library spectra.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/templatelibrary.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        import warnings</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import glob</span>
<span class="sd">        import os</span>
<span class="sd">        import time</span>
<span class="sd">        import logging</span>

<span class="sd">        import numpy</span>
<span class="sd">        from scipy import sparse</span>
<span class="sd">        from scipy.interpolate import InterpolatedUnivariateSpline</span>
<span class="sd">        from astropy.io import fits</span>
<span class="sd">        import astropy.constants</span>
<span class="sd">        from pydl.goddard.astro import airtovac</span>

<span class="sd">        from ..util.bitmask import BitMask</span>
<span class="sd">        from ..par.parset import ParSet</span>
<span class="sd">        from ..config.defaults import default_dap_source, default_dap_common_path</span>
<span class="sd">        from ..config.defaults import default_dap_file_name</span>
<span class="sd">        from ..util.log import log_output</span>
<span class="sd">        from ..util.fileio import readfits_1dspec, read_template_spectrum, writefits_1dspec</span>
<span class="sd">        from ..util.instrument import resample1d, resample_vector_npix, SpectralResolution</span>
<span class="sd">        from ..util.instrument import match_spectral_resolution, spectral_coordinate_step</span>
<span class="sd">        from ..util.parser import DefaultConfig</span>
<span class="sd">        from .util import select_proc_method, HDUList_mask_wavelengths</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">    Assuming you have the default directory structure setup, you can do::</span>

<span class="sd">        # Imports</span>
<span class="sd">        from mangadap.drpfits import DRPFits</span>
<span class="sd">        from mangadap.proc.templatelibrary import TemplateLibrary</span>
<span class="sd">        from matplotlib import pyplot</span>

<span class="sd">        # Define the DRP file</span>
<span class="sd">        drpf = DRPFits(7495, 12703, &#39;CUBE&#39;)</span>

<span class="sd">        # Build the template library</span>
<span class="sd">        tpl_lib = TemplateLibrary(&#39;M11MILES&#39;, drpf=drpf, directory_path=&#39;.&#39;)</span>
<span class="sd">        # Writes: ./manga-7495-12703-LOGCUBE_M11-MILES.fits</span>

<span class="sd">        # Plot one of the spectra</span>
<span class="sd">        pyplot.plot(tpl_lib.hdu[&#39;WAVE&#39;].data, tpl_lib.hdu[&#39;FLUX&#39;].data[0,:])</span>
<span class="sd">        pyplot.show()</span>

<span class="sd">    As part of the instantiation of the :class:`TemplateLibrary` object</span>
<span class="sd">    in the above call, the template library is prepared for use in</span>
<span class="sd">    fitting the specified DRP file.  If the required processing has</span>
<span class="sd">    already been done, the instantiation of the :class:`TemplateLibrary`</span>
<span class="sd">    object simply reads the existing file.  If you do not have the</span>
<span class="sd">    default directory structure setup, you&#39;ll need to define the paths</span>
<span class="sd">    to, e.g., the DRP file; see :class:`mangadap.dapfile.dapfile`.</span>

<span class="sd">    If you do not want to process the template (match the spectral</span>
<span class="sd">    resolution and sampling to that of the DRP data), you can force the</span>
<span class="sd">    :class:`TemplateLibrary` object to only provide the &quot;raw&quot; spectra::</span>

<span class="sd">        # Imports</span>
<span class="sd">        from mangadap.proc.templatelibrary import TemplateLibrary</span>
<span class="sd">        from matplotlib import pyplot</span>

<span class="sd">        # Read the raw template library</span>
<span class="sd">        tpl_lib = TemplateLibrary(&#39;M11MILES&#39;, process=False)</span>
<span class="sd">        # Nothing should be written to disk</span>

<span class="sd">        # Plot one of the spectra</span>
<span class="sd">        pyplot.plot(tpl_lib.hdu[&#39;WAVE&#39;].data[0,:], tpl_lib.hdu[&#39;FLUX&#39;].data[0,:])</span>
<span class="sd">        pyplot.show()</span>

<span class="sd">    Note that in the previous example, the wavelength data was already</span>
<span class="sd">    one-dimensional, whereas for the raw library, the wavelength vector</span>
<span class="sd">    can be spectrum-dependent.</span>

<span class="sd">    In the above examples, the user has not provided a list of template</span>
<span class="sd">    libraries, meaning that the default set available to the DAP is</span>
<span class="sd">    used.  The default set is defined in</span>
<span class="sd">    :func:`available_template_libraries`.  If you want to use your own</span>
<span class="sd">    template library, you have to define its parameters using</span>
<span class="sd">    :class:`TemplateLibraryDef`.  Currently, the template library</span>
<span class="sd">    spectra are expected to be 1D fits files with WCS header keywords</span>
<span class="sd">    defining the wavelength solution; see above.  Using an existing DAP</span>
<span class="sd">    library as an example::</span>

<span class="sd">        # Imports</span>
<span class="sd">        from mangadap.proc.templatelibrary import TemplateLibraryDef</span>
<span class="sd">        from mangadap.proc.templatelibrary import TemplateLibrary</span>
<span class="sd">        from mangadap.config.defaults import default_dap_source</span>
<span class="sd">        from matplotlib import pyplot</span>

<span class="sd">        # Define the search string for the library</span>
<span class="sd">        search_str = default_dap_source()+&#39;/data/stellar_templates/miles/*.fits&#39;</span>

<span class="sd">        # Define the template library parameters</span>
<span class="sd">        tpl_par = TemplateLibraryDef(key=&#39;MILES&#39;,    # Unique keyword for the library</span>
<span class="sd">                                file_search=search_str, # Search string</span>
<span class="sd">                                fwhm=2.50,              # FWHM of resolution element (assumed const)</span>
<span class="sd">                                in_vacuum=False,        # Wavelength in vacuum?</span>
<span class="sd">                                wave_limit=numpy.array([ 3575., 7400. ]),   # Range of valid lambda</span>
<span class="sd">                                lower_flux_limit=0.0)   # Lower limit for valid flux</span>

<span class="sd">        # Read the raw template library</span>
<span class="sd">        tpl_lib = TemplateLibrary(&#39;MILES&#39;, tpllib_list=tpl_par, process=False)</span>
<span class="sd">        # Nothing should be written to disk</span>

<span class="sd">        # Plot one of the spectra</span>
<span class="sd">        pyplot.plot(tpl_lib.hdu[&#39;WAVE&#39;].data[0,:], tpl_lib.hdu[&#39;FLUX&#39;].data[0,:])</span>
<span class="sd">        pyplot.show()</span>

<span class="sd">    Note that the keyword you use must be provided both to the parameter</span>
<span class="sd">    set and when instantiating the :class:`TemplateLibrary` object.  In</span>
<span class="sd">    the example above, I have not processed the library, but you can by</span>
<span class="sd">    following a similar approach to the first example.</span>

<span class="sd">    You can also process the spectra to a user-provided resolution and</span>
<span class="sd">    pixel sampling, toggle on/off the renormalization of the library to</span>
<span class="sd">    a mean flux of unity and define various paths if you&#39;re not working</span>
<span class="sd">    within the nominal DAP directory structure.  See the optional</span>
<span class="sd">    instantiation arguments for :class:`TemplateLibrary`.</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **23 Apr 2015**: Implementation begun by K. Westfall (KBW)</span>
<span class="sd">    | **26 May 2015**: (KBW) Added some Sphinx documentation.</span>
<span class="sd">    | **17 Jun 2015**: (KBW) Added flexibility in definition of template</span>
<span class="sd">        libraries from which to choose using the new</span>
<span class="sd">        :class:`TemplateLibraryDef` class.</span>
<span class="sd">    | **23 Jun 2015**: (KBW) Allow user to provided non-DRP input</span>
<span class="sd">        spectra, meaning they need to provide the velocity scale and the</span>
<span class="sd">        wavelength and spectral resolution vectors.  They must also</span>
<span class="sd">        directly set the name of the output processed file.</span>
<span class="sd">    | **01 Feb 2016**: (KBW) Propagated changes to</span>
<span class="sd">        :class:`TemplateLibraryDef` and changed procedure for reading</span>
<span class="sd">        raw template library.</span>
<span class="sd">    | **04 Feb 2016**: (KBW) Converted from</span>
<span class="sd">        :func:`mangadap.util.instrument.log_rebin` to</span>
<span class="sd">        :func:`mangadap.util.instrument.resample_vector`.  Allows input</span>
<span class="sd">        library to be logarithmically sampled and provides a different</span>
<span class="sd">        approach to subsampling spectra.  Implemented other convenience</span>
<span class="sd">        operations, such as selecting a certain wavelength range for the</span>
<span class="sd">        processed library.</span>
<span class="sd">    | **19 May 2016**: (KBW) Added loggers and quiet keyword arguments</span>
<span class="sd">        to :class:`TemplateLibrary`</span>
<span class="sd">    | **22 Jun 2016**: (KBW) Included MILESHC library in documentation.</span>
<span class="sd">        Allow to specify how the resolution and sampling are matched to</span>
<span class="sd">        the DRP data.  The :class:`TemplateLibrary` class should be</span>
<span class="sd">        generalized to make this more transparent (and unnecessary).</span>
<span class="sd">    | **03 Apr 2017**: (KBW) Include arguments for</span>
<span class="sd">        :func:`mangadap.util.instrument.match_spectral_resolution` that</span>
<span class="sd">        specify the minimum sigma in pixels for the convolution kernel</span>
<span class="sd">        and any offset in the resolution required in the call for the</span>
<span class="sd">        template library.  Check that the resampling of the spectrum</span>
<span class="sd">        does not reach the two-pixel resolution limit; flag the spectrum</span>
<span class="sd">        in those regions that do and change the resolution to the two</span>
<span class="sd">        pixel limit.</span>
<span class="sd">    | **30 Aug 2017**: (KBW) Switch from using</span>
<span class="sd">        :func:`mangadap.util.instrument.resample_vector` to</span>
<span class="sd">        :func:`mangadap.util.instrument.resample1d`</span>

<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _pydl.goddard.astro.airtovac: http://pydl.readthedocs.io/en/stable/api/pydl.goddard.astro.airtovac.html#pydl.goddard.astro.airtovac</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="c1">#from scipy.interpolate import InterpolatedUnivariateSpline</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>
<span class="kn">from</span> <span class="nn">pydl.goddard.astro</span> <span class="k">import</span> <span class="n">airtovac</span>

<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_source</span><span class="p">,</span> <span class="n">default_dap_common_path</span>
<span class="kn">from</span> <span class="nn">..config.defaults</span> <span class="k">import</span> <span class="n">default_dap_file_name</span>
<span class="kn">from</span> <span class="nn">..util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">readfits_1dspec</span><span class="p">,</span> <span class="n">read_template_spectrum</span><span class="p">,</span> <span class="n">writefits_1dspec</span><span class="p">,</span> <span class="n">create_symlink</span>
<span class="kn">from</span> <span class="nn">..util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">resample1d</span><span class="p">,</span> <span class="n">resample_vector_npix</span><span class="p">,</span> <span class="n">SpectralResolution</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">match_spectral_resolution</span><span class="p">,</span> <span class="n">spectral_coordinate_step</span>
<span class="kn">from</span> <span class="nn">..util.instrument</span> <span class="k">import</span> <span class="n">spectrum_velocity_scale</span><span class="p">,</span> <span class="n">angstroms_per_pixel</span>
<span class="kn">from</span> <span class="nn">..util.parser</span> <span class="k">import</span> <span class="n">DefaultConfig</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">select_proc_method</span><span class="p">,</span> <span class="n">HDUList_mask_wavelengths</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>

<span class="c1"># Add strict versioning</span>
<span class="c1"># from distutils.version import StrictVersion</span>

<div class="viewcode-block" id="TemplateLibraryDef"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibraryDef">[docs]</a><span class="k">class</span> <span class="nc">TemplateLibraryDef</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class with parameters used to define the template library.</span>
<span class="sd">    See :class:`mangadap.par.parset.ParSet` for attributes.</span>

<span class="sd">    Args:</span>
<span class="sd">        key (str): Keyword to distinguish the template library.</span>
<span class="sd">        file_search (str): Search string used by glob to find the 1D</span>
<span class="sd">            fits spectra to include in the template library.</span>
<span class="sd">        fwhm (int or float): FWHM of the resolution element in</span>
<span class="sd">            angstroms.</span>
<span class="sd">        sres_ext (str): Extension in the fits files with measurements of</span>
<span class="sd">            the spectral resolution as a function of wavelength.</span>
<span class="sd">        in_vacuum (bool): Flag that the wavelengths of the spectra are</span>
<span class="sd">            in vacuum, not air.</span>
<span class="sd">        wave_limit (numpy.ndarray): 2-element array with the starting</span>
<span class="sd">            and ending wavelengths for the valid spectral range of the</span>
<span class="sd">            templates.</span>
<span class="sd">        lower_flux_limit (int or float): Minimum valid flux in the</span>
<span class="sd">            template spectra.</span>
<span class="sd">        log10 (bool): Flag that the template spectra have been binned</span>
<span class="sd">            logarithmically in wavelength.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_search</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sres_ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">in_vacuum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">wave_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower_flux_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
        <span class="c1"># Perform some checks of the input</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>
        
        <span class="n">pars</span> <span class="o">=</span>   <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;file_search&#39;</span><span class="p">,</span> <span class="s1">&#39;fwhm&#39;</span><span class="p">,</span> <span class="s1">&#39;sres_ext&#39;</span><span class="p">,</span> <span class="s1">&#39;in_vacuum&#39;</span><span class="p">,</span>  <span class="s1">&#39;wave_limit&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;lower_flux_limit&#39;</span><span class="p">,</span> <span class="s1">&#39;log10&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>   <span class="n">key</span><span class="p">,</span>   <span class="n">file_search</span><span class="p">,</span>   <span class="n">fwhm</span><span class="p">,</span>   <span class="n">sres_ext</span><span class="p">,</span>   <span class="n">in_vacuum</span><span class="p">,</span>    <span class="n">wave_limit</span><span class="p">,</span>
                          <span class="n">lower_flux_limit</span><span class="p">,</span>   <span class="n">log10</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span>   <span class="nb">str</span><span class="p">,</span>           <span class="nb">str</span><span class="p">,</span>  <span class="n">in_fl</span><span class="p">,</span>        <span class="nb">str</span><span class="p">,</span>        <span class="nb">bool</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                     <span class="n">in_fl</span><span class="p">,</span>    <span class="nb">bool</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span></div>


<div class="viewcode-block" id="validate_spectral_template_config"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.validate_spectral_template_config">[docs]</a><span class="k">def</span> <span class="nf">validate_spectral_template_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Validate the :class:`mangadap.util.parser.DefaultConfig` object with</span>
<span class="sd">    the template library parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        cnfg (:class:`mangadap.util.parser.DefaultConfig`): Object with</span>
<span class="sd">            the template library parameters to validate.</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: Raised if required keyword does not exist.</span>
<span class="sd">        ValueError: Raised if key has unacceptable value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for required keywords</span>
    <span class="n">required_keywords</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;file_search&#39;</span> <span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">all_required</span><span class="p">(</span><span class="n">required_keywords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Keywords </span><span class="si">{0}</span><span class="s1"> must all have valid values.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_keywords</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;fwhm&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnfg</span><span class="o">.</span><span class="n">keyword_specified</span><span class="p">(</span><span class="s1">&#39;sres_ext&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Must provide either </span><span class="se">\&#39;</span><span class="s1">fwhm</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">sres_ext</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="available_template_libraries"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.available_template_libraries">[docs]</a><span class="k">def</span> <span class="nf">available_template_libraries</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the list of library keys, the searchable string of the 1D</span>
<span class="sd">    template library fits files for the template libraries available for</span>
<span class="sd">    use by the DAP, the FWHM of the libraries, and whether or not the</span>
<span class="sd">    wavelengths are in vacuum.</span>

<span class="sd">    The stellar template library files should be a list of 1D fits</span>
<span class="sd">    files, and be associated with one of the following library keys:</span>

<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |                 |   Spectral |         |  Wavelength | Lower |</span>
<span class="sd">    |             KEY |  res (ang) |  Vacuum | Range (ang) | Limit |</span>
<span class="sd">    +=================+============+=========+=============+=======+</span>
<span class="sd">    |        M11MARCS |       2.73 |      No |        full |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |       M11STELIB |       3.40 |      No |        full |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |   M11STELIBZSOL |       3.40 |      No |        full |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |       M11ELODIE |       0.55 |      No |      &lt; 6795 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |        M11MILES |       2.54 |      No | 3550 - 7400 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |           MILES |       2.50 |      No |      &lt; 7400 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |        MILESAVG |       2.50 |      No |      &lt; 7400 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |       MILESTHIN |       2.50 |      No |      &lt; 7400 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |         MILESHC |       2.50 |      No |      &lt; 7400 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |          STELIB |       3.40 |      No |        full |   0.0 |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |         MIUSCAT |       2.51 |      No | 3480 - 9430 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>
<span class="sd">    |     MIUSCATTHIN |       2.51 |      No | 3480 - 9430 |  None |</span>
<span class="sd">    +-----------------+------------+---------+-------------+-------+</span>

<span class="sd">    Args:</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_source`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of</span>
<span class="sd">        :func:`mangadap.proc.templatelibrary.TemplateLibraryDef`</span>
<span class="sd">        objects, each defining a separate template library.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotADirectoryError: Raised if the provided or default</span>
<span class="sd">            *dapsrc* is not a directory.</span>
<span class="sd">        OSError/IOError: Raised if no template configuration files could</span>
<span class="sd">            be found.</span>
<span class="sd">        KeyError: Raised if the template-library keywords are not all</span>
<span class="sd">            unique.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - Add backup function for Python 2.</span>
<span class="sd">        - Somehow add a python call that reads the databases and</span>
<span class="sd">          constructs the table for presentation in sphinx so that the</span>
<span class="sd">          text above doesn&#39;t have to be edited with changes in the</span>
<span class="sd">          available databases.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the source directory exists</span>
    <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotADirectoryError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> does not exist!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">))</span>

    <span class="c1"># Check the configuration files exist</span>
    <span class="n">ini_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">+</span><span class="s1">&#39;/python/mangadap/config/spectral_templates/*.ini&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ini_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Could not find any configuration files in </span><span class="si">{0}</span><span class="s1"> !&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                      <span class="n">dapsrc</span><span class="o">+</span><span class="s1">&#39;/python/mangadap/config/spectral_templates&#39;</span><span class="p">))</span>

    <span class="c1"># Build the list of library definitions</span>
    <span class="n">template_libraries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ini_files</span><span class="p">:</span>
        <span class="c1"># Read and validate the config file</span>
        <span class="n">cnfg</span> <span class="o">=</span> <span class="n">DefaultConfig</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">validate_spectral_template_config</span><span class="p">(</span><span class="n">cnfg</span><span class="p">)</span>

        <span class="c1"># Convert wave_limit and lower_flux_limit to types acceptable by</span>
        <span class="c1"># TemplateLibraryDef</span>
        <span class="n">wave_limit</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getlist</span><span class="p">(</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">wave_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave_limit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify two wavelength limits, can be </span><span class="se">\&#39;</span><span class="s1">None, None</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="c1"># Append the definition of the template library </span>
        <span class="n">template_libraries</span> <span class="o">+=</span> \
            <span class="p">[</span> <span class="n">TemplateLibraryDef</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">file_search</span><span class="o">=</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;file_search&#39;</span><span class="p">],</span>
                                 <span class="n">fwhm</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;fwhm&#39;</span><span class="p">),</span> <span class="n">sres_ext</span><span class="o">=</span><span class="n">cnfg</span><span class="p">[</span><span class="s1">&#39;sres_ext&#39;</span><span class="p">],</span>
                                 <span class="n">in_vacuum</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;in_vacuum&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                 <span class="n">wave_limit</span><span class="o">=</span><span class="n">wave_limit</span><span class="p">,</span>
                                 <span class="n">lower_flux_limit</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;lower_flux_limit&#39;</span><span class="p">),</span>
                                 <span class="n">log10</span><span class="o">=</span><span class="n">cnfg</span><span class="o">.</span><span class="n">getbool</span><span class="p">(</span><span class="s1">&#39;log10&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="p">)</span>
            <span class="p">]</span>

    <span class="c1"># Check the keywords of the libraries are all unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tpl</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">template_libraries</span><span class="p">])</span> <span class="p">))</span> \
            <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">template_libraries</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Template-library keywords are not all unique!&#39;</span><span class="p">)</span>

    <span class="c1"># Return the default list of template libraries</span>
    <span class="k">return</span> <span class="n">template_libraries</span></div>


<div class="viewcode-block" id="TemplateLibraryBitMask"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibraryBitMask">[docs]</a><span class="k">class</span> <span class="nc">TemplateLibraryBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derived class that specifies the mask bits for the template library</span>
<span class="sd">    data.  See :class:`mangadap.util.bitmask.BitMask` for attributes.</span>

<span class="sd">    A list of the bits and meanings are provided by the base class</span>
<span class="sd">    function :func:`mangadap.util.bitmask.BitMask.info`; i.e.,::</span>

<span class="sd">        from mangadap.proc.templatelibrary import TemplateLibraryBitMask</span>
<span class="sd">        t = TemplateLibraryBitMask()</span>
<span class="sd">        t.info()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dapsrc</span> <span class="o">=</span> <span class="n">default_dap_source</span><span class="p">()</span> <span class="k">if</span> <span class="n">dapsrc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dapsrc</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;mangadap&#39;</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">,</span>
                                                     <span class="s1">&#39;bitmasks&#39;</span><span class="p">,</span> <span class="s1">&#39;spectral_template_bits.ini&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="TemplateLibrary"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary">[docs]</a><span class="k">class</span> <span class="nc">TemplateLibrary</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object used to read, store, and prepare template libraries for use</span>
<span class="sd">    in analyzing object spectra.</span>

<span class="sd">    The default list of available libraries provided by the MaNGA DAP</span>
<span class="sd">    defined in :func:`available_template_libraries`.  The user can</span>
<span class="sd">    provide their own library for use with this class provided they are</span>
<span class="sd">    contained in 1D fits spectra, sampled linearly in wavelength with</span>
<span class="sd">    the wavelength coordinates available via the WCS keywords (CRPIX1,</span>
<span class="sd">    CRVAL1, CDELT1), and they have an appropriately defined spectral</span>
<span class="sd">    resolution (FWHM in angstroms that is constant as a function of</span>
<span class="sd">    wavelength).  See :class:`TemplateLibraryDef` and</span>
<span class="sd">    :func:`_build_raw_hdu`.</span>

<span class="sd">    The class is optimized for use in analyzing MaNGA DRP files;</span>
<span class="sd">    however, one can provide the necessary information so that the class</span>
<span class="sd">    can be used with a non-DRP spectrum.  In the latter case, the user</span>
<span class="sd">    must supply the velocity scale of the pixel for the logarithmically</span>
<span class="sd">    resampled template library, and a</span>
<span class="sd">    :class:`mangadap.util.instrument.SpectralResolution` object the</span>
<span class="sd">    defines the instrumental resolution of the spectrum/spectra to be</span>
<span class="sd">    analyzed.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        - below is out of date.</span>
<span class="sd">        - Only works with DRP files that have log-linear wavelength</span>
<span class="sd">          binning!</span>
<span class="sd">        - Allow to process, where process is just to change the</span>
<span class="sd">          sampling or the resolution (not necessarily both).</span>
<span class="sd">        - Need to make this more general, removing all dependence on</span>
<span class="sd">          DRPFits object.  This would simplify the functionality to</span>
<span class="sd">          change how the resolution and sampling matching is specified.</span>

<span class="sd">    On initialization, if the DRP file object is not provided (is None),</span>
<span class="sd">    the default behavior is to read the raw template library if</span>
<span class="sd">    read=True.  If the DRP file is provided, the routine will check for</span>
<span class="sd">    the resolution matched fits file; if it doesn&#39;t exist and read is</span>
<span class="sd">    True, it will prepare the template library for use in analyzing the</span>
<span class="sd">    DRP file and write the prepared library file.  If clobber=True, the</span>
<span class="sd">    preparation and writing of the template library will be done even if</span>
<span class="sd">    the library already exists.</span>

<span class="sd">    Args:</span>
<span class="sd">        library_key (str): Keyword selecting the library to use.</span>
<span class="sd">        tpllib_list (list): (**Optional**) List of</span>
<span class="sd">            :class:`TemplateLibraryDef` objects that define the</span>
<span class="sd">            parameters required to read and interpret a template</span>
<span class="sd">            library.  The *library_key* must select one of the objects</span>
<span class="sd">            in this list.</span>
<span class="sd">        dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">            directory.  If not provided, the default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_source`.</span>
<span class="sd">        drpf (:class:`mangadap.drpfits.DRPFits`): (**Optional**) DRP</span>
<span class="sd">            file (object) with which the template library is associated</span>
<span class="sd">            for analysis</span>
<span class="sd">        match_to_drp_resolution (bool): (**Optional**) Match the</span>
<span class="sd">            spectral resolution of the template library to the</span>
<span class="sd">            resolution provided by the :class:`mangadap.drpfits.DRPFits`</span>
<span class="sd">            object; the latter must be provided for this argument to</span>
<span class="sd">            have any use.</span>
<span class="sd">        velscale_ratio (int): (**Optional**) Resample the template</span>
<span class="sd">            spectra such that the ratio of the pixel scale in the</span>
<span class="sd">            provided :class:`mangadap.drpfits.DRPFits` object is this</span>
<span class="sd">            many times larger than the pixels in the resampled template</span>
<span class="sd">            spectrum.</span>
<span class="sd">        sres (:class:`mangadap.util.instrument.SpectralResolution`):</span>
<span class="sd">            (**Optional**) The object is used simply to access the</span>
<span class="sd">            spectral resolution and associated wavelength coordinate</span>
<span class="sd">            vector needed when matching the spectral resolution of the</span>
<span class="sd">            template library; this is used in place of the attributes in</span>
<span class="sd">            any provided DRP file object.</span>
<span class="sd">        velocity_offset (float): (**Optional**) Velocity offset to use</span>
<span class="sd">            when matching the spectral resolution between the template</span>
<span class="sd">            library and the galaxy spectra.</span>
<span class="sd">        spectral_step (float) : (**Optional**) Target logarithmic</span>
<span class="sd">            (*log*=True) or linear (*log*=False) step in wavelength for</span>
<span class="sd">            the template library.</span>
<span class="sd">        log (bool) : (**Optional**) Flag to force the library to be</span>
<span class="sd">            logarithmically sampled in wavelength.</span>
<span class="sd">        wavelength_range (array-like) : (**Optional**) Force</span>
<span class="sd">            the template library to covert this spectral range.</span>
<span class="sd">            Unobserved spectral regions will be flagged.</span>
<span class="sd">        renormalize (bool) : (**Optional**) After processing,</span>
<span class="sd">            renormalize the flux to unity.</span>
<span class="sd">        dapver (str): (**Optional**) DAP version, which is used to</span>
<span class="sd">            define the default DAP analysis path.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_version`</span>
<span class="sd">        analysis_path (str): (**Optional**) The path to the top level</span>
<span class="sd">            directory containing the DAP output files for a given DRP</span>
<span class="sd">            and DAP version.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">        directory_path (str): (**Optional**) The exact path to the</span>
<span class="sd">            processed template library file.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_common_path`.</span>
<span class="sd">        processed_file (str): (**Optional**) The name of the file</span>
<span class="sd">            containing the prepared template library output file.  The</span>
<span class="sd">            file should be found at</span>
<span class="sd">            :attr:`directory_path`/:attr:`processed_file`.  Default is</span>
<span class="sd">            defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">        process (bool): (**Optional**) If :attr:`drpf` is defined and</span>
<span class="sd">            the prepared template library does not exist, this will</span>
<span class="sd">            process the template library in preparation for use in</span>
<span class="sd">            fitting the provided DRP file.</span>
<span class="sd">        hardcopy (bool): (**Optional**) Flag to keep a hardcopy of the</span>
<span class="sd">            processed template library.  Default is True.</span>
<span class="sd">        symlink_dir (str): (**Optional**) Create a symlink to the file</span>
<span class="sd">            in this directory.  Default is for no symlink.</span>
<span class="sd">        clobber (bool): (**Optional**) If :attr:`drpf` is define and</span>
<span class="sd">            *process* is True, this will clobber any existing processed</span>
<span class="sd">            template library.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        bitmask (BitMask): A BitMask object used to toggle mask values;</span>
<span class="sd">            see :func:`TemplateLibraryBitMask`.</span>
<span class="sd">        library (:class:`TemplateLibraryDef`): Parameter set required to</span>
<span class="sd">            read and prepare the library.</span>
<span class="sd">        file_list (list): The list of files found using `glob.glob`_ and</span>
<span class="sd">            :attr:`file_search`.</span>
<span class="sd">        ntpl (int): Number of template spectra in the library</span>
<span class="sd">        drpf (:class:`mangadap.drpfits.DRPFits`): DRP file (object) with</span>
<span class="sd">            which the template library is associated for analysis</span>
<span class="sd">        sres (:class:`mangadap.util.instrument.SpectralResolution`):</span>
<span class="sd">            The object is used simply to access the spectral resolution</span>
<span class="sd">            and associated wavelength coordinate vector needed when</span>
<span class="sd">            matching the spectral resolution of the template library;</span>
<span class="sd">            this is used in place of the attributes in any provided DRP</span>
<span class="sd">            file object.</span>
<span class="sd">        velocity_offset (float): Velocity offset to use when matching</span>
<span class="sd">            the spectral resolution between the template library and the</span>
<span class="sd">            galaxy spectra.</span>
<span class="sd">        spectral_step (float) : Target logarithmic</span>
<span class="sd">            (:attr:`log10_sampling`=True) or linear</span>
<span class="sd">            (:attr:`log10_sampling`=False) step in wavelength for the</span>
<span class="sd">            template library.</span>
<span class="sd">        log10_sampling (bool): Flag that the processed template library is</span>
<span class="sd">            logarithmically sampled in wavelength.</span>
<span class="sd">        directory_path (str): The exact path to the processed template</span>
<span class="sd">            library file.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_dap_common_path`.</span>
<span class="sd">        processed_file (str): The name of the file containing (to</span>
<span class="sd">            contain) the prepared template library output file.  The</span>
<span class="sd">            file should be found at</span>
<span class="sd">            :attr:`directory_path`/:attr:`processed_file`.</span>
<span class="sd">        processed (bool): Flag that the template library has been</span>
<span class="sd">            prepared for use in the DAP.</span>
<span class="sd">        hardcopy (bool): Flag to keep a hardcopy of the processed</span>
<span class="sd">            template library.</span>
<span class="sd">        symlink_dir (str): Symlink created to the file in this directory</span>
<span class="sd">        hdu (`astropy.io.fits.hdu.hdulist.HDUList`_): HDUList read from</span>
<span class="sd">            the DAP file</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library_key</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drpf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">match_to_drp_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spectral_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">wavelength_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">processed_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># Define the TemplateLibraryBitMask object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">TemplateLibraryBitMask</span><span class="p">(</span><span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="c1"># Define the properties needed to modify the spectral resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sig_pix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_offset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Define the target spectral sampling properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1">#        self.velscale = None</span>
<span class="c1">#        velscale (float): The velocity scale of the spectrum that will</span>
<span class="c1">#            be analyzed with the library; this is used in place of the</span>
<span class="c1">#            attributes in any provided DRP file object.</span>

        <span class="c1"># Define the library</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">library</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_define_library</span><span class="p">(</span><span class="n">library_key</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="n">tpllib_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>

        <span class="c1"># Define the processed file and flag, and the HDUList used to</span>
        <span class="c1"># keep the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span>

        <span class="c1"># Do not read the library</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">read</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Nothing read, by request.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
       
        <span class="c1"># Do not process the library</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">process</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Reading raw library without processing.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_raw</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="c1"># Read and process the library</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_template_library</span><span class="p">(</span><span class="n">drpf</span><span class="o">=</span><span class="n">drpf</span><span class="p">,</span> <span class="n">match_to_drp_resolution</span><span class="o">=</span><span class="n">match_to_drp_resolution</span><span class="p">,</span>
                                      <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">sres</span><span class="o">=</span><span class="n">sres</span><span class="p">,</span>
                                      <span class="n">velocity_offset</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">,</span>
                                      <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">spectral_step</span><span class="o">=</span><span class="n">spectral_step</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                      <span class="n">wavelength_range</span><span class="o">=</span><span class="n">wavelength_range</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="n">renormalize</span><span class="p">,</span>
                                      <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">,</span>
                                      <span class="n">directory_path</span><span class="o">=</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">processed_file</span><span class="o">=</span><span class="n">processed_file</span><span class="p">,</span>
                                      <span class="n">hardcopy</span><span class="o">=</span><span class="n">hardcopy</span><span class="p">,</span> <span class="n">symlink_dir</span><span class="o">=</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span>
                                      <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>


<span class="c1">#    def __del__(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Deconstruct the template library object by ensuring that the</span>
<span class="c1">#        fits file is properly closed.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if self.hdu is None:</span>
<span class="c1">#            return</span>
<span class="c1">#        self.hdu.close()</span>
<span class="c1">#        self.hdu = None</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<div class="viewcode-block" id="TemplateLibrary._define_library"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._define_library">[docs]</a>    <span class="k">def</span> <span class="nf">_define_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library_key</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the library from the provided list.  Used to set</span>
<span class="sd">        :attr:`library`; see</span>
<span class="sd">        :func:`mangadap.proc.util.select_proc_method`.</span>

<span class="sd">        Args:</span>
<span class="sd">            library_key (str): Keyword of the selected library.</span>
<span class="sd">                Available libraries are proved by</span>
<span class="sd">                :func:`available__template_libraries`</span>
<span class="sd">            tpllib_list (list): (**Optional**) List of </span>
<span class="sd">                :class:`TemplateLibraryDef`</span>
<span class="sd">                objects that define the parameters required to read and</span>
<span class="sd">                interpret a template library.</span>
<span class="sd">            dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">                directory.  If not provided, the default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_source`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the details of the selected template library</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">library</span> <span class="o">=</span> <span class="n">select_proc_method</span><span class="p">(</span><span class="n">library_key</span><span class="p">,</span> <span class="n">TemplateLibraryDef</span><span class="p">,</span> <span class="n">method_list</span><span class="o">=</span><span class="n">tpllib_list</span><span class="p">,</span>
                                          <span class="n">available_func</span><span class="o">=</span><span class="n">available_template_libraries</span><span class="p">,</span>
                                          <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._can_set_paths"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._can_set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">_can_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_path</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">processed_file</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Check that the directory_path can be set</span>
        <span class="k">if</span> <span class="n">drpf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot define the default directory path without a DRP file; &#39;</span> \
                                 <span class="s1">&#39;provide a directory path.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check that the processed file can be set</span>
        <span class="k">if</span> <span class="n">drpf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">processed_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot define the default output file name without a DRP file; &#39;</span> \
                                 <span class="s1">&#39;provide a file name for the processed template library.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="TemplateLibrary._set_paths"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">_set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">processed_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the I/O path to the processed template library.  Used to set</span>
<span class="sd">        :attr:`directory_path` and :attr:`processed_file`.  If not</span>
<span class="sd">        provided, the defaults are set using, respectively,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_common_path` and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_dap_file_name`.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory_path (str): The exact path to the DAP template</span>
<span class="sd">                library file.  See :attr:`directory_path`.</span>
<span class="sd">            dapver (str): DAP version.</span>
<span class="sd">            analysis_path (str): The path to the top-level directory</span>
<span class="sd">                containing the DAP output files for a given DRP and DAP</span>
<span class="sd">                version.</span>
<span class="sd">            drpf (:class:`mangadap.drpfits.DRPFits`): The container</span>
<span class="sd">                object of the DRP file that is used to construct the</span>
<span class="sd">                path for the processed template library.</span>
<span class="sd">            processed_file (str): The name of the file with the prepared</span>
<span class="sd">                template library.  See :attr:`processed_file`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use this to raise the necessary exceptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_can_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">processed_file</span><span class="p">)</span>

        <span class="c1"># Set the output directory path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="n">default_dap_common_path</span><span class="p">(</span><span class="n">plate</span><span class="o">=</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="o">=</span><span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span>
                                                      <span class="n">drpver</span><span class="o">=</span><span class="n">drpf</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="n">dapver</span><span class="p">,</span>
                                                      <span class="n">analysis_path</span><span class="o">=</span><span class="n">analysis_path</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">directory_path</span><span class="p">)</span>

        <span class="c1"># Set the output file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span> <span class="o">=</span> <span class="n">default_dap_file_name</span><span class="p">(</span><span class="n">drpf</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="n">drpf</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">])</span> \
                                        <span class="k">if</span> <span class="n">processed_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">processed_file</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="TemplateLibrary._get_file_list"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._get_file_list">[docs]</a>    <span class="k">def</span> <span class="nf">_get_file_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;file_search&#39;</span><span class="p">]))</span></div>


<div class="viewcode-block" id="TemplateLibrary._read_raw"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._read_raw">[docs]</a>    <span class="k">def</span> <span class="nf">_read_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the &#39;raw&#39; versions of the template library; i.e., the</span>
<span class="sd">        library before it has been resolution and sampling matched to a</span>
<span class="sd">        DRP file.</span>

<span class="sd">        The file list read by the search key is sorted for consistency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_file_list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_list</span><span class="p">)</span>
        <span class="n">npix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nchannels</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                            <span class="s1">&#39;Found </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> templates&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                            <span class="s1">&#39;Maximum number of wavelength channels: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">npix</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_raw_hdu</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._get_nchannels"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._get_nchannels">[docs]</a>    <span class="k">def</span> <span class="nf">_get_nchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the maximum number of wavelength channels needed to store</span>
<span class="sd">        all the template spectra in a single array.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - What happens if the spectrum has an empty primary</span>
<span class="sd">              extension?</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Maximum number of pixels used by the listed spectra.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the input template spectra are not</span>
<span class="sd">                one-dimensional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_npix</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fits</span><span class="o">.</span><span class="n">getval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;NAXIS&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> is not one dimensional!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="n">npix</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">getval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;NAXIS1&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_npix</span> <span class="o">&lt;</span> <span class="n">npix</span><span class="p">:</span>
                <span class="n">max_npix</span> <span class="o">=</span> <span class="n">npix</span>
        <span class="k">return</span> <span class="n">max_npix</span></div>


<div class="viewcode-block" id="TemplateLibrary._build_raw_hdu"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._build_raw_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">_build_raw_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npix</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the &quot;raw&quot; template library arrays.  This simply reads the</span>
<span class="sd">        provided list of fits files and puts them into arrays of size</span>
<span class="sd">        :math:`N_{\rm tpl} \times N_{\rm pix}`.</span>

<span class="sd">        This will *force* reading of the data, even if the :attr:`hdu`</span>
<span class="sd">        is already initialized.</span>

<span class="sd">        The :attr:`hdu` will contain the appropriate extensions, but it</span>
<span class="sd">        is important to note that the wavelength vectors will **not**</span>
<span class="sd">        necessarily be the same.  That is, reading of the raw template</span>
<span class="sd">        spectra can accommodate spectra that have different wavelength</span>
<span class="sd">        coordinates.  Any pixels that have no data are masked using the</span>
<span class="sd">        &#39;NO_DATA&#39; bitmask flag; see</span>
<span class="sd">        :func:`TemplateLibraryBitMask`.</span>

<span class="sd">        The spectral resolution is set using :attr:`fwhm`, and the</span>
<span class="sd">        spectral resolution offset is initialized to zero (see</span>
<span class="sd">        :func:`mangadap.util.instrument.GaussianKernelDifference`).</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Currently no errors are saved because none are expected for</span>
<span class="sd">            the template libraries.</span>

<span class="sd">        Args:</span>
<span class="sd">            npix (int): Number of spectral channels for the output</span>
<span class="sd">                arrays</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Closing existing HDUList.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Attempting to build raw data ...&#39;</span><span class="p">)</span>
        <span class="c1"># Allocate the vectors</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
        <span class="n">soff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="c1">#        ivar = numpy.zeros((self.ntpl, npix), dtype=numpy.float64)</span>
<span class="c1">#        ivar[:] = 1.0</span>

        <span class="c1"># Read and save each spectrum and mask the unobserved</span>
        <span class="c1"># wavelengths</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;sres_ext&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wave_</span><span class="p">,</span> <span class="n">flux_</span> <span class="o">=</span> <span class="n">readfits_1dspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log10</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">])</span>
                <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">wave_</span><span class="p">)</span>
                <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">flux_</span><span class="p">)</span>
                <span class="c1"># Set the spectral resolution</span>
                <span class="n">sres</span> <span class="o">=</span> <span class="n">wave</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wave_</span><span class="p">,</span> <span class="n">flux_</span><span class="p">,</span> <span class="n">sres_</span> <span class="o">=</span> <span class="n">read_template_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                             <span class="n">sres_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;sres_ext&#39;</span><span class="p">],</span>
                                                             <span class="n">log10</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">])</span>
                <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">wave_</span><span class="p">)</span>
                <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">flux_</span><span class="p">)</span>
                <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sres_</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">wave_</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">npix</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">wave_</span><span class="o">.</span><span class="n">size</span><span class="p">:],</span><span class="s1">&#39;NO_DATA&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;lower_flux_limit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span> <span class="n">flux_</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;lower_flux_limit&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FLUX_INVALID&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;WAVE_INVALID&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;wave_limit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;WAVE_INVALID&#39;</span><span class="p">)</span>


        <span class="c1"># (Re)Set the HDUList object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_hdu</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">soff</span><span class="p">)</span>

        <span class="c1"># Add some keywords to the header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;TPLPROC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Flag that library has been processed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;... done&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._reset_hdu"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._reset_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">_reset_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">soff</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)Set :attr:`hdu` to a new HDUList object using the input</span>
<span class="sd">        arrays.  Also sets the header items indicating the version of</span>
<span class="sd">        the template reader and the keyword for the library.</span>

<span class="sd">        .. warning:</span>
<span class="sd">            No checking is done concerning the size of each array!</span>

<span class="sd">        Args:</span>
<span class="sd">            wave (numpy.ndarray): Array with the wavelengths of each</span>
<span class="sd">                pixel.</span>
<span class="sd">            flux (numpy.ndarray): Array with the flux in each pixel.</span>
<span class="sd">            mask (numpy.ndarray): Bitmask values for each pixel.</span>
<span class="sd">            sres (numpy.ndarray): Spectral resolution,</span>
<span class="sd">                :math:`R=\lambda/\delta\lambda`, at each pixel.</span>
<span class="sd">            soff (numpy.ndarray): The spectral resolution offset for</span>
<span class="sd">                each spectrum (see</span>
<span class="sd">                :func:`mangadap.util.instrument.GaussianKernelDifference`). </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WAVE&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">sres</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">),</span>
                                  <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">soff</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SIGOFF&#39;</span><span class="p">)</span>
                                <span class="p">])</span>

<span class="c1">#        self.hdu[&#39;PRIMARY&#39;].header[&#39;VDAPTPL&#39;] = (self.version, &#39;Version of DAP template reader&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;LIBKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="s1">&#39;Library identifier&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._wavelength_range"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._wavelength_range">[docs]</a>    <span class="k">def</span> <span class="nf">_wavelength_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the valid wavelength range for each spectrum based on the</span>
<span class="sd">        first and last unmasked pixel; interspersed masked regions are</span>
<span class="sd">        not considered.</span>

<span class="sd">        Args:</span>
<span class="sd">            flag (str or list): (**Optional**) Flags to consider when</span>
<span class="sd">                determining the wavelength range; see</span>
<span class="sd">                :func:`mangadap.util.bitmasks.BitMask.flagged`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Two-element vector with wavelengths of the</span>
<span class="sd">            first and last valid pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">]),</span>
                             <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">])])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._minimum_sampling"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._minimum_sampling">[docs]</a>    <span class="k">def</span> <span class="nf">_minimum_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum sampling of the available wavelength vectors.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float : minimum sampling of all (will just be one if the</span>
<span class="sd">            library has been processed) wavelength vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span>

        <span class="n">nspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">minimum_step</span> <span class="o">=</span> <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                     <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">):</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                            <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">minimum_step</span> <span class="o">&gt;</span> <span class="n">step</span><span class="p">:</span>
                <span class="n">minimum_step</span> <span class="o">=</span> <span class="n">step</span>

        <span class="k">return</span> <span class="n">minimum_step</span></div>


<div class="viewcode-block" id="TemplateLibrary._rebin_masked"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._rebin_masked">[docs]</a>    <span class="k">def</span> <span class="nf">_rebin_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">fullRange</span><span class="p">,</span> <span class="n">rmsk_lim</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the mask value to adopt for a rebinned spectrum by</span>
<span class="sd">        rebinning the mask pixels, setting a masked pixel to unity, and</span>
<span class="sd">        an unmasked pixel to zero.  After rebinning, any pixel with a</span>
<span class="sd">        value of larger than *rmsk_lim* is masked; otherwise it is left</span>
<span class="sd">        unmasked.</span>

<span class="sd">        Although the function can be used with multiple flags, its</span>
<span class="sd">        intended use is to determine which pixels should be masked with</span>
<span class="sd">        a specific flag.</span>

<span class="sd">        Args:</span>
<span class="sd">            i (int): Index of the spectrum to be rebinned.</span>
<span class="sd">            flag (str or list): Flags to consider when determining which</span>
<span class="sd">                pixels to mask; see</span>
<span class="sd">                :func:`mangadap.util.bitmasks.BitMask.flagged`.</span>
<span class="sd">            fullRange (numpy.ndarray): Two-element array with the</span>
<span class="sd">                wavelength range for the rebinned spectrum.</span>
<span class="sd">            rmsk_lim (float): Limit of the rebinned mask value that is</span>
<span class="sd">                allowed before considering the pixel as masked.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: The indices of the pixels in the rebinned spectrum</span>
<span class="sd">            that should be masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask_ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">wave</span><span class="p">,</span> <span class="n">mask_ex</span> <span class="o">=</span> <span class="n">resample1d</span><span class="p">(</span><span class="n">mask_ex</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                   <span class="n">inLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">],</span> <span class="n">newRange</span><span class="o">=</span><span class="n">fullRange</span><span class="p">,</span>
                                   <span class="n">newLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span><span class="p">,</span> <span class="n">newdx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">)</span>

<span class="c1">#        wave, mask_ex = resample_vector(mask_ex, xRange=[self.hdu[&#39;WAVE&#39;].data[i,0],</span>
<span class="c1">#                                                         self.hdu[&#39;WAVE&#39;].data[i,-1]],</span>
<span class="c1">#                                        inLog=self.library[&#39;log10&#39;], newRange=fullRange,</span>
<span class="c1">#                                        newLog=self.log10_sampling, dx=self.spectral_step,</span>
<span class="c1">#                                        conserve=False) # flat=True!</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_ex</span> <span class="o">&gt;</span> <span class="n">rmsk_lim</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary._modify_spectral_resolution"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._modify_spectral_resolution">[docs]</a>    <span class="k">def</span> <span class="nf">_modify_spectral_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the spectral resolution to match the provided</span>
<span class="sd">        :attr:`sres`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Redshift used when matching the spectral resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate to use as an offset of the match to the spectral</span>
        <span class="c1"># resolution.  Used to better match the spectral resolution to</span>
        <span class="c1"># at the *observed* wavelengths of the object spectrum to which</span>
        <span class="c1"># the TemplateLibrary will be fit.</span>
        <span class="n">redshift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_offset</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Mask wavelengths where the spectral resolution will have to be</span>
        <span class="c1"># extrapolated.</span>
        <span class="n">sres_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
        <span class="n">wavelim</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">sres_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">),</span> <span class="n">sres_wave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">)</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">HDUList_mask_wavelengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span> <span class="s1">&#39;SPECRES_EXTRAP&#39;</span><span class="p">,</span> <span class="n">wavelim</span><span class="p">,</span>
                                            <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1">#        oldwave = numpy.copy(self.hdu[&#39;WAVE&#39;].data[0,:]).ravel()</span>
<span class="c1">#        oldflux = numpy.copy(self.hdu[&#39;FLUX&#39;].data[0,:]).ravel()</span>
<span class="c1">#        pyplot.plot(self.hdu[&#39;WAVE&#39;].data[0,:], self.hdu[&#39;FLUX&#39;].data[0,:]) </span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Match the resolution of the templates.  ivar is returned, but</span>
        <span class="c1"># is always None because ivar is not provided to</span>
        <span class="c1"># match_spectral_resolution</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Modifying spectral resolution ... &#39;</span><span class="p">)</span>
<span class="c1">#        print(&#39;min_sig_pix: &#39;, self.min_sig_pix)</span>
<span class="c1">#        print(spectrum_velocity_scale(self.hdu[&#39;WAVE&#39;].data))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SIGOFF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">res_mask</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> \
            <span class="n">match_spectral_resolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sres_wave</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">redshift</span><span class="p">),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="o">.</span><span class="n">sres</span><span class="p">(),</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig_pix</span><span class="p">,</span>
                                      <span class="n">no_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">],</span>
                                      <span class="n">new_log10</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;... done&#39;</span><span class="p">)</span>

        <span class="c1"># Mask any pixels where the template resolution was too low to</span>
        <span class="c1"># match to the galaxy resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">res_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">res_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;SPECRES_LOW&#39;</span><span class="p">)</span>

<span class="c1">#        pyplot.plot(oldwave, oldflux)</span>
<span class="c1">#        pyplot.plot(self.hdu[&#39;WAVE&#39;].data[0,:], self.hdu[&#39;FLUX&#39;].data[0,:], &#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="k">return</span> <span class="n">redshift</span></div>


<div class="viewcode-block" id="TemplateLibrary._process_library"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary._process_library">[docs]</a>    <span class="k">def</span> <span class="nf">_process_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the template library for use in analyzing object</span>
<span class="sd">        spectra.   See :func:`process_template_library`.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            - Add wavelength coordinate WCS information to the</span>
<span class="sd">              appropriate extension headers.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert to vacuum wavelengths</span>
<span class="c1">#        pyplot.plot(self.hdu[&#39;WAVE&#39;].data[0,:], self.hdu[&#39;FLUX&#39;].data[0,:]) </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;in_vacuum&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">airtovac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="c1">#        pyplot.plot(self.hdu[&#39;WAVE&#39;].data[0,:], self.hdu[&#39;FLUX&#39;].data[0,:], &#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>

<span class="c1">#        oldwave = numpy.copy(self.hdu[&#39;WAVE&#39;].data[0,:]).ravel()</span>
<span class="c1">#        oldflux = numpy.copy(self.hdu[&#39;FLUX&#39;].data[0,:]).ravel()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Modify the spectral resolution to a target function, if one</span>
        <span class="c1"># has been provided.</span>
        <span class="n">redshift</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_modify_spectral_resolution</span><span class="p">()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Resample the templates to a logarithmic binning step.</span>
        <span class="c1">#</span>
        <span class="c1"># Typically this will be run to match the sampling of the</span>
        <span class="c1"># template library to that of a set of galaxy spectra to be fit.</span>
        <span class="c1"># However, the sampling can be left alone and this part will</span>
        <span class="c1"># force all the spectra to have the same wavelength range.</span>

        <span class="c1"># The raw spectra are allowed to have wavelength ranges that</span>
        <span class="c1"># differ.  First, determine the wavelength range that encloses</span>
        <span class="c1"># all spectra.  Only ignore pixels that were flagged as having</span>
        <span class="c1"># no data.</span>
        <span class="n">fullRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelength_range</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="s1">&#39;NO_DATA&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">wavelength_range</span> <span class="ow">is</span> <span class="kc">None</span> \
                            <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wavelength_range</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># Get the spectral step if it hasn&#39;t been set yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimum_sampling</span><span class="p">()</span>

        <span class="c1"># Get the number of pixels needed</span>
        <span class="n">npix</span><span class="p">,</span> <span class="n">_fullRange</span> <span class="o">=</span> <span class="n">resample_vector_npix</span><span class="p">(</span><span class="n">outRange</span><span class="o">=</span><span class="n">fullRange</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">,</span>
                                               <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span><span class="p">)</span>

        <span class="c1"># Any pixels without data after resampling are given a value</span>
        <span class="c1"># that is the minimum flux - 100 so that they can be easily</span>
        <span class="c1"># identified afterward.  The minimum flux is:</span>
        <span class="n">min_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="c1"># the observed pixels are</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;NO_DATA&#39;</span><span class="p">))</span>
        
        <span class="c1"># Number of angstroms per pixel</span>
        <span class="n">ang_per_pix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">):</span>
            <span class="n">ang_per_pix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">angstroms_per_pixel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                                   <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">],</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
                                                   <span class="n">regular</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;in_vacuum&#39;</span><span class="p">])</span>
<span class="c1">#        ang_per_pix_nr = angstroms_per_pixel(self.hdu[&#39;WAVE&#39;].data[i,:], log=self.library[&#39;log10&#39;],</span>
<span class="c1">#                                             base=10., regular=False)</span>
<span class="c1">#        pyplot.plot(ang_per_pix[0,:])</span>
<span class="c1">#        pyplot.plot(ang_per_pix_nr)</span>
<span class="c1">#        pyplot.show()</span>
        <span class="c1"># Number of pixels per resolution element</span>
        <span class="n">pix_per_fwhm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">ang_per_pix</span><span class="p">)</span>

        <span class="c1"># Now resample the spectra.  First allocate the arrays</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Matching sampling ... &#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">):</span>
            <span class="c1"># Observed wavelengths</span>
            <span class="n">wave_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># Rebin the observed wavelength range</span>
            <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">resample1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                         <span class="n">x</span><span class="o">=</span><span class="n">wave_in</span><span class="p">,</span> <span class="n">inLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">],</span> <span class="n">newRange</span><span class="o">=</span><span class="n">fullRange</span><span class="p">,</span>
                                         <span class="n">newLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span><span class="p">,</span> <span class="n">newdx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">,</span>
                                         <span class="n">ext_value</span><span class="o">=</span><span class="n">min_flux</span><span class="o">-</span><span class="mf">100.</span><span class="p">)</span>
<span class="c1">#            wave, flux[i,:] = resample_vector(self.hdu[&#39;FLUX&#39;].data[i,observed[i,:]].ravel(),</span>
<span class="c1">#                                              xRange=[wave_in[0], wave_in[-1]],</span>
<span class="c1">#                                              inLog=self.library[&#39;log10&#39;], newRange=fullRange,</span>
<span class="c1">#                                              newLog=self.log10_sampling, dx=self.spectral_step,</span>
<span class="c1">#                                              ext_value=min_flux-100., conserve=False, flat=False)</span>

            <span class="c1"># Find the unobserved pixels, set them to have no flux, and</span>
            <span class="c1"># flag them as having no data</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">&lt;</span> <span class="n">min_flux</span><span class="o">-</span><span class="mf">10.</span><span class="p">)</span>
            <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;NO_DATA&#39;</span><span class="p">)</span>

            <span class="c1"># Resample the spectral resolution by simple interpolation.</span>
            <span class="c1"># Select the good pixels</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">&lt;</span> <span class="n">min_flux</span><span class="o">-</span><span class="mf">10.</span><span class="p">))</span>
            <span class="c1"># and interpolate</span>
            <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)(</span><span class="n">wave</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>

            <span class="c1">#-----------------------------------------------------------</span>
            <span class="c1"># Correct resolution for any resampling that results in</span>
            <span class="c1"># less than 2 pixels per resolution element</span>
            <span class="c1"># Get the number of new pixels combined for each new one</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">npix</span> <span class="o">=</span> <span class="n">resample1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">wave_in</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">x</span><span class="o">=</span><span class="n">wave_in</span><span class="p">,</span>
                                 <span class="n">inLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">],</span> <span class="n">newRange</span><span class="o">=</span><span class="n">fullRange</span><span class="p">,</span>
                                 <span class="n">newLog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span><span class="p">,</span> <span class="n">newdx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">,</span>
                                 <span class="n">conserve</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># and the number of new pixels per resolution element</span>
            <span class="n">_pix_per_fwhm</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                 <span class="n">pix_per_fwhm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                 <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)(</span><span class="n">wave</span><span class="p">)</span> <span class="o">/</span> <span class="n">npix</span>
<span class="c1">#            pyplot.plot(wave_in, pix_per_fwhm[i,observed[i,:]])</span>
<span class="c1">#            pyplot.plot(wave, _pix_per_fwhm)</span>
<span class="c1">#            pyplot.plot(wave, npix)</span>
<span class="c1">#            pyplot.show()</span>

            <span class="n">indx</span> <span class="o">=</span> <span class="n">_pix_per_fwhm</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Resampling has cause resolution below the two pixel limit!&#39;</span><span class="p">)</span>
                <span class="n">_ang_per_pix</span> <span class="o">=</span> <span class="n">angstroms_per_pixel</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
                                                   <span class="n">regular</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">_ang_per_pix</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;SPECRES_2PIXEL&#39;</span><span class="p">)</span>
            <span class="c1">#-----------------------------------------------------------</span>

            <span class="c1"># Rebin the masks, bit-by-bit:</span>
            <span class="c1"># Pixels outside the wavelength limits</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebin_masked</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;WAVE_INVALID&#39;</span><span class="p">,</span> <span class="n">fullRange</span><span class="p">,</span> <span class="n">rmsk_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;WAVE_INVALID&#39;</span><span class="p">)</span>
            <span class="c1"># Pixels below the flux limit</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebin_masked</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;FLUX_INVALID&#39;</span><span class="p">,</span> <span class="n">fullRange</span><span class="p">,</span> <span class="n">rmsk_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;FLUX_INVALID&#39;</span><span class="p">)</span>
            <span class="c1"># Pixels that required an extrapolation of the spectral</span>
            <span class="c1"># resolution</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebin_masked</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;SPECRES_EXTRAP&#39;</span><span class="p">,</span> <span class="n">fullRange</span><span class="p">,</span> <span class="n">rmsk_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;SPECRES_EXTRAP&#39;</span><span class="p">)</span>
            <span class="c1"># Pixels that had a spectral resolution that was too low to</span>
            <span class="c1"># match the galaxy resolution</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rebin_masked</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;SPECRES_LOW&#39;</span><span class="p">,</span> <span class="n">fullRange</span><span class="p">,</span> <span class="n">rmsk_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;SPECRES_LOW&#39;</span><span class="p">)</span>
            
<span class="c1">#            pyplot.plot(oldwave, oldflux)</span>
<span class="c1">#            pyplot.plot(wave, flux[i,:], &#39;g&#39;)</span>
<span class="c1">#            pyplot.show()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;... done&#39;</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;After resampling (target): </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;After resampling (calculated): </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span>
                                                                                        <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

<span class="c1">#        pyplot.plot(oldwave, oldflux)</span>
<span class="c1">#        pyplot.plot(wave, flux[0,:], &#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Normalize the templates to the mean flux value after excluding</span>
        <span class="c1"># any flagged pixels.</span>
        <span class="k">if</span> <span class="n">renormalize</span><span class="p">:</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;All pixels masked.  Unable to renormalize TemplateLibrary.&#39;</span><span class="p">)</span>
                <span class="n">flux_norm</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flux_norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indx</span><span class="p">)])</span>
            <span class="n">flux</span> <span class="o">/=</span> <span class="n">flux_norm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flux_norm</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="c1">#        print(flux_norm)</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.plot(oldwave, oldflux/flux_norm)</span>
<span class="c1">#        pyplot.plot(wave, flux[0,:], &#39;g&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Reset the HDUList object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_hdu</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;SIGOFF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Update the header with the redshift offset, the flux</span>
        <span class="c1"># normalization, and flag the data as having been prepared for</span>
        <span class="c1"># fitting the DRP data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;ZGUESS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">redshift</span><span class="p">,</span><span class="s1">&#39;Redshift used when matching spectral resolution&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;FLXNRM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">flux_norm</span><span class="p">,</span><span class="s1">&#39;Flux normalization&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;TPLPROC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="TemplateLibrary.file_name"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary.file_name">[docs]</a>    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the processed file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span></div>


<div class="viewcode-block" id="TemplateLibrary.file_path"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary.file_path">[docs]</a>    <span class="k">def</span> <span class="nf">file_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full path to the processed file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary.read_raw_template_library"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary.read_raw_template_library">[docs]</a>    <span class="k">def</span> <span class="nf">read_raw_template_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the identified template library.  If all the arguments are</span>
<span class="sd">        the default, the preset attributes from the initialization of</span>
<span class="sd">        the object are used.</span>

<span class="sd">        Args:</span>
<span class="sd">            library_key (str): (**Optional**) Keyword selecting the library</span>
<span class="sd">                to use.</span>
<span class="sd">            tpllib_list (list): (**Optional**) List of</span>
<span class="sd">                :class:`TemplateLibraryDef`</span>
<span class="sd">                objects that define the parameters required to read and</span>
<span class="sd">                interpret a template library.</span>
<span class="sd">            dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">                directory.  If not provided, the default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_source`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">library_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Redefine the library</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_define_library</span><span class="p">(</span><span class="n">library_key</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="n">tpllib_list</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="n">dapsrc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_raw</span><span class="p">()</span></div>


<div class="viewcode-block" id="TemplateLibrary.process_template_library"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary.process_template_library">[docs]</a>    <span class="k">def</span> <span class="nf">process_template_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tpllib_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dapsrc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drpf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">match_to_drp_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">velocity_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">spectral_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">wavelength_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dapver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analysis_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">processed_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hardcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">symlink_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the template library for use in analyzing object</span>
<span class="sd">        spectra.  Primary steps are to:</span>

<span class="sd">            - Read the raw 1D fits files; see :func:`_read_raw`.</span>

<span class="sd">            - Convert the wavelengths to vacuum, if necessary; see</span>
<span class="sd">              :func:`mangadap.util.idlutils.airtovac`.</span>

<span class="sd">            - Mask wavelengths outside the rest wavelength range of the</span>
<span class="sd">              DRP spectrum, due to need to extrapolate these values; see</span>
<span class="sd">              :func:`mangadap.util.bitmasks.HDUList_mask_wavelengths`.</span>

<span class="sd">            - Match the spectral resolution of the template to that of</span>
<span class="sd">              the DRP spectra; see</span>
<span class="sd">              :func:`mangadap.util.instrument.match_spectral_resolution`.</span>

<span class="sd">            - Mask the template pixels where the spectral resolution was</span>
<span class="sd">              too low to match to the DRP spectra; see</span>
<span class="sd">              :func:`mangadap.util.bitmasks.BitMask.turn_on`.</span>

<span class="sd">            - Force a common wavelength range and sampling for all</span>
<span class="sd">              templates, where the sampling is forced to match the</span>
<span class="sd">              sampling of the DRP spectra; see</span>
<span class="sd">              :func:`mangadap.util.instrument.resample_vector_pix`.  The masks</span>
<span class="sd">              are appropriately resampled as well; see</span>
<span class="sd">              :func:`_rebin_masked`.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The routine **does not** check that that an existing</span>
<span class="sd">            processed file or the existing object has been processed</span>
<span class="sd">            using the same DRPFits, velocity_offset, velscale, or sres</span>
<span class="sd">            input.  If unsure, use clobber=True.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>

<span class="sd">            library_key (str): (**Optional**) Keyword selecting the library</span>
<span class="sd">                to use; default is to use existing :attr:`library`.</span>
<span class="sd">            tpllib_list (list): (**Optional**) List of</span>
<span class="sd">                :class:`TemplateLibraryDef`</span>
<span class="sd">                objects that define the parameters required to read and</span>
<span class="sd">                interpret a template library.  Input ignored if</span>
<span class="sd">                *library_key* is None.</span>
<span class="sd">            dapsrc (str): (**Optional**) Root path to the DAP source</span>
<span class="sd">                directory.  If not provided, the default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_source`.</span>
<span class="sd">                Input ignored if *library_key* is None.</span>
<span class="sd">            drpf (:class:`mangadap.drpfits.DRPFits`): (**Optional**) DRP</span>
<span class="sd">                file (object) with which the template library is</span>
<span class="sd">                associated for analysis.  **If not provided**, the user</span>
<span class="sd">                must define *velscale* and *sres* such that the library</span>
<span class="sd">                can be processed; and the user must provide</span>
<span class="sd">                *directory_path* and *processed_file* such that the</span>
<span class="sd">                output file can be written.</span>
<span class="sd">            match_to_drp_resolution (bool): (**Optional**) Match the</span>
<span class="sd">                spectral resolution of the template library to the</span>
<span class="sd">                resolution provided by the</span>
<span class="sd">                :class:`mangadap.drpfits.DRPFits` object; the latter</span>
<span class="sd">                must be provided for this argument to have any use.</span>
<span class="sd">            velscale_ratio (int): (**Optional**) Resample the template</span>
<span class="sd">                spectra such that the ratio of the pixel scale in the</span>
<span class="sd">                provided :class:`mangadap.drpfits.DRPFits` object is</span>
<span class="sd">                this many times larger than the pixels in the resampled</span>
<span class="sd">                template spectrum.</span>
<span class="sd">            sres (:class:`mangadap.util.instrument.SpectralResolution`):</span>
<span class="sd">                (**Optional**) The object is used simply to access the</span>
<span class="sd">                spectral resolution and associated wavelength coordinate</span>
<span class="sd">                vector needed when matching the spectral resolution of</span>
<span class="sd">                the template library.  This takes prededence over the</span>
<span class="sd">                values provided by the DRP file object.</span>
<span class="sd">            velocity_offset (float): (**Optional**) Velocity offset to use</span>
<span class="sd">                when matching the spectral resolution between the</span>
<span class="sd">                template library and the galaxy spectra.</span>
<span class="sd">            spectral_step (float) : (**Optional**) Target logarithmic</span>
<span class="sd">                (*log*=True) or linear (*log*=False) step in wavelength for</span>
<span class="sd">                the template library.</span>
<span class="sd">            log (bool) : (**Optional**) Flag to force the library to be</span>
<span class="sd">                logarithmically sampled in wavelength.</span>
<span class="sd">            wavelength_range (array-like) : (**Optional**) Force the</span>
<span class="sd">                template library to covert this spectral range.  Unobserved</span>
<span class="sd">                spectral regions will be flagged.</span>
<span class="sd">            renormalize (bool) : (**Optional**) After processing, renormalize</span>
<span class="sd">                the flux to unity.</span>
<span class="sd">            dapver (str): (**Optional**) DAP version, which is used to</span>
<span class="sd">                define the default DAP analysis path.  Default is</span>
<span class="sd">                defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_version`</span>
<span class="sd">            analysis_path (str): (**Optional**) The path to the top level</span>
<span class="sd">                directory containing the DAP output files for a given</span>
<span class="sd">                DRP and DAP version.  Default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_analysis_path`.</span>
<span class="sd">            directory_path (str): (**Optional**) The exact path for the</span>
<span class="sd">                processed template library file.  Default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_common_path`.</span>
<span class="sd">            processed_file (str): (**Optional**) The name of the file</span>
<span class="sd">                containing (to contain) the prepared template library</span>
<span class="sd">                output file.  The file should be found at</span>
<span class="sd">                :attr:`directory_path`/:attr:`processed_file`.  Default</span>
<span class="sd">                is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_file_name`.</span>
<span class="sd">            hardcopy (bool): (**Optional**) Flag to keep a hardcopy of</span>
<span class="sd">                the processed template library.  Default is True.</span>
<span class="sd">            symlink_dir (str): (**Optional**) Create a symlink to the</span>
<span class="sd">                file in this directory.  Default is for no symlink.</span>
<span class="sd">            clobber (bool): (**Optional**) Clobber any existing processed</span>
<span class="sd">                library.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the velocity scale, spectral resolution, or</span>
<span class="sd">                file name for the processed data are not define.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - type checking</span>
<span class="sd">            - If a DRP file is provided, the processing to a logarithmic</span>
<span class="sd">              binning is done by default (log=True).  But linearly</span>
<span class="sd">              sampled DRP data are available, so need to have</span>
<span class="sd">              :class:`mangadap.drpfits.DRPFits` return the spectral</span>
<span class="sd">              sampling type.</span>
<span class="sd">            - Documentation needs updating!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># Ignore velscale_ratio if it is set to unity</span>
        <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">velscale_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">drpf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use the DRP file object to set the spectral resolution and</span>
            <span class="c1"># velocity scale to match to.  TODO: Need to update the</span>
            <span class="c1"># matching for &#39;DISP&#39; in new LOGCUBEs?</span>
            <span class="k">if</span> <span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DRP file previously unopened.  Reading now.&#39;</span><span class="p">)</span>
                <span class="n">drpf</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">()</span>

            <span class="c1"># If resolution matching is requested, get the spectral</span>
            <span class="c1"># resolution vector.</span>
            <span class="c1">#   - The procedure requires that the resolution be measured</span>
            <span class="c1">#     without the pixel convolution; however, the PRESPECRES</span>
            <span class="c1">#     extension is not available with all releases of the</span>
            <span class="c1">#     DRP.  So first try to get the prepixelized</span>
            <span class="c1">#     measurements, and then warn the user and get the</span>
            <span class="c1">#     pixelized measuremeents if that fails.</span>
            <span class="c1">#   - The spectral_resolution function returns a full array</span>
            <span class="c1">#     with the spectral resolution for each spectrum by</span>
            <span class="c1">#     default.  Calling it with median=True will only return</span>
            <span class="c1">#     the single vector with the median spectral resolution.</span>
            <span class="k">if</span> <span class="n">match_to_drp_resolution</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">spectral_resolution</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">,</span> <span class="n">toarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">pre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">median</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">spectral_resolution</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">,</span> <span class="n">toarray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">median</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Set log sampling by default, but should instead query</span>
            <span class="c1"># DRPFits to check if the wavelengths are log binned!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="o">=</span> <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">drpf</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Use the provided input values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sres</span> <span class="o">=</span> <span class="n">sres</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span> <span class="o">=</span> <span class="n">log</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="o">=</span> <span class="n">spectral_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_offset</span> <span class="o">=</span> <span class="n">velocity_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sig_pix</span> <span class="o">=</span> <span class="n">min_sig_pix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_offset</span> <span class="o">=</span> <span class="n">no_offset</span>

        <span class="c1"># Adjust for the velocity scale ratio between the template and</span>
        <span class="c1"># object data to be fit</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span> <span class="ow">and</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;velscale_ratio only valid with logarithmically sampled spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span> <span class="o">/=</span> <span class="n">velscale_ratio</span>
<span class="c1">#        print(self.spectral_step)</span>

        <span class="c1"># Set the paths if possible</span>
        <span class="n">directory_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">directory_path</span>
        <span class="n">processed_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span> <span class="k">if</span> <span class="n">processed_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">processed_file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">processed_file</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="c1">#            print(&#39;setting paths&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_paths</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">dapver</span><span class="p">,</span> <span class="n">analysis_path</span><span class="p">,</span> <span class="n">drpf</span><span class="p">,</span> <span class="n">processed_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="o">=</span> <span class="n">hardcopy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="o">=</span> <span class="n">symlink_dir</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Template library output path: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Template library output file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span><span class="p">))</span>

        <span class="c1"># Check that the path for or to the file is defined</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="ow">and</span> <span class="n">ofile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;File path for output file is undefined!&#39;</span><span class="p">)</span>

<span class="c1">#        if not force and self.velocity_offset is not None \</span>
<span class="c1">#           and not numpy.isclose(velocity_offset, self.velocity_offset):</span>
<span class="c1">#            print(&#39;Forcing processing due to change in velocity offset.&#39;)</span>
<span class="c1">#            force = True</span>

        <span class="c1"># Read and use a pre-existing file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">clobber</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Reading existing file&#39;</span><span class="p">)</span>
<span class="c1">#            self.hdu = fits.open(ofile, checksum=self.checksum)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_file_list</span><span class="p">()</span>
<span class="c1">#            self.file_list = glob.glob(self.library[&#39;file_search&#39;])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Make sure the symlink exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">create_symlink</span><span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Warn the user that the file will be overwritten</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">ofile</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Overwriting existing file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_file</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="c1"># Read the raw data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_raw</span><span class="p">()</span>
        <span class="c1"># Process the library</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_library</span><span class="p">(</span><span class="n">wavelength_range</span><span class="o">=</span><span class="n">wavelength_range</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="n">renormalize</span><span class="p">)</span>
        <span class="c1"># Write the fits file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hardcopy</span><span class="p">:</span>
            <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">(),</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">symlink_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symlink_dir</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span></div>


<div class="viewcode-block" id="TemplateLibrary.single_spec_to_fits"><a class="viewcode-back" href="../../../mangadap.proc.templatelibrary.html#mangadap.proc.templatelibrary.TemplateLibrary.single_spec_to_fits">[docs]</a>    <span class="k">def</span> <span class="nf">single_spec_to_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ofile</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write one of the template spectra to a 1D fits file.</span>

<span class="sd">        Output is a one-dimensional fits file with a single extension</span>
<span class="sd">        containing the flux measurements and headers keywords needed to</span>
<span class="sd">        determine the wavelength of each pixel.</span>

<span class="sd">        Args:</span>
<span class="sd">            i (int) : Index of the spectrum in the avaiable list to</span>
<span class="sd">                output.</span>
<span class="sd">            ofile (str) : Name of the file to write</span>
<span class="sd">            clobber (bool) : (**Optional**) Flag to clobber any existing</span>
<span class="sd">                file of the same name.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the selected index is not available.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid index (</span><span class="si">{0}</span><span class="s1">)!  Library contains </span><span class="si">{1}</span><span class="s1"> spectra.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span>
                                                                                        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        <span class="n">log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10_sampling</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="s1">&#39;log10&#39;</span><span class="p">]</span>
        <span class="n">writefits_1dspec</span><span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">log</span> <span class="k">else</span> <span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_step</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span></div></div>


</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>