

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.proc.ppxffit &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="mangadap" href="../../mangadap.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../mangadap.html">mangadap</a> &raquo;</li>
        
      <li>mangadap.proc.ppxffit</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.proc.ppxffit</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements a wrapper class for pPXF.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2015, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/proc/ppxffit.py</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">        Add examples</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **26 Apr 2016**: Moved from spectralfitting.py to its own file by</span>
<span class="sd">        K. Westfall (KBW)</span>
<span class="sd">    | **05 Jul 2016**: (KBW) V6.0.0 of pPXF does not use the oversample</span>
<span class="sd">        keyword given a better solution; see Cappellari (in prep).  This</span>
<span class="sd">        keyword was therefore removed from the parameter set.</span>
<span class="sd">    | **06 Jul 2016**: (KBW) Use v6.0.0 pPXF functions to compute models</span>
<span class="sd">        using new LOSVD kernel functionality.</span>
<span class="sd">    | **10 Oct 2016**: (KBW) Fixed error in calculation of velocity</span>
<span class="sd">        offset between template and object spectra to account for</span>
<span class="sd">        different size pixels.</span>
<span class="sd">    | **31 Oct 2016**: (KBW) Allow the spectral resolution to be a</span>
<span class="sd">        vector per spaxel or a vector per set of input spectra in</span>
<span class="sd">        :func:`PPXFFit.fit`.</span>
<span class="sd">    | **01 Nov 2016**: (KBW) Added new iteration method that does not do</span>
<span class="sd">        a first fit to the global spectrum but does include the</span>
<span class="sd">        rejection iteration.  Allows users to treat each spectrum</span>
<span class="sd">        provided to :func:`PPXFFit.fit` individually.  Fixed goodpixel</span>
<span class="sd">        mask when not first fitting the global spectrum.</span>
<span class="sd">    | **02 Nov 2016**: (KBW) Added ability to limit which templates are</span>
<span class="sd">        fit to each spectrum in :func:`PPXFFit.fit` using usetpl kwarg.</span>
<span class="sd">    | **17 Feb 2017**: (KBW) Included filtering options.  Changed to use</span>
<span class="sd">        ppxf v6.0.4; mpfit object no longer returned, only mpfit status.</span>
<span class="sd">    | **30 Aug 2017**: (KBW) Switch from</span>
<span class="sd">        :func:`mangadap.util.instrument.resample_vector` to</span>
<span class="sd">        :func:`mangadap.util.instrument.resample1d`.</span>
<span class="sd">    | **05 Feb 2018**: (KBW) Added :class:`PPXFModel`.</span>
<span class="sd">    | **22 May 2018**: (KBW) Change import to ppxf package.</span>
<span class="sd">    | **30 Aug 2018**: (KBW) Changed from resample1d to</span>
<span class="sd">        :class:`mangadap.util.sampling.Resample`.</span>

<span class="sd">.. todo::</span>

<span class="sd">    Allow new iteration mode that iteratively fits until the velocity is</span>
<span class="sd">    not up against one of the +/- 2000 km/s limits?  Could be useful for</span>
<span class="sd">    poor redshift guesses.</span>

<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _glob.glob: https://docs.python.org/3.4/library/glob.html</span>
<span class="sd">.. _logging.Logger: https://docs.python.org/3/library/logging.html</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">fftpack</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">ppxf</span> <span class="k">import</span> <span class="n">ppxf</span><span class="p">,</span> <span class="n">capfit</span>

<span class="kn">from</span> <span class="nn">..par.parset</span> <span class="k">import</span> <span class="n">ParSet</span>
<span class="kn">from</span> <span class="nn">..util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">..util.pixelmask</span> <span class="k">import</span> <span class="n">PixelMask</span><span class="p">,</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">..util.fileio</span> <span class="k">import</span> <span class="n">init_record_array</span>
<span class="kn">from</span> <span class="nn">..util.filter</span> <span class="k">import</span> <span class="n">BoxcarFilter</span>
<span class="kn">from</span> <span class="nn">..util.log</span> <span class="k">import</span> <span class="n">log_output</span>
<span class="kn">from</span> <span class="nn">..util.sampling</span> <span class="k">import</span> <span class="n">spectrum_velocity_scale</span><span class="p">,</span> <span class="n">angstroms_per_pixel</span><span class="p">,</span> <span class="n">Resample</span>
<span class="kn">from</span> <span class="nn">..util.resolution</span> <span class="k">import</span> <span class="n">match_spectral_resolution</span><span class="p">,</span> <span class="n">SpectralResolution</span>
<span class="kn">from</span> <span class="nn">..util.constants</span> <span class="k">import</span> <span class="n">DAPConstants</span>
<span class="kn">from</span> <span class="nn">.spatiallybinnedspectra</span> <span class="k">import</span> <span class="n">SpatiallyBinnedSpectra</span>
<span class="kn">from</span> <span class="nn">.templatelibrary</span> <span class="k">import</span> <span class="n">TemplateLibrary</span>
<span class="kn">from</span> <span class="nn">.spectralfitting</span> <span class="k">import</span> <span class="n">StellarKinematicsFit</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">sample_growth</span><span class="p">,</span> <span class="n">optimal_scale</span>
<span class="c1">#from .util import residual_growth, optimal_scale</span>

<span class="c1"># For debugging</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>
<span class="c1">#from ..contrib import ppxf_util</span>

<div class="viewcode-block" id="PPXFFitPar"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitPar">[docs]</a><span class="k">class</span> <span class="nc">PPXFFitPar</span><span class="p">(</span><span class="n">ParSet</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Define a parameter set used by the pPXF fitting method.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        The overlap between this and</span>
<span class="sd">        :class:`mangadap.proc.stellarcontinuummodel.StellarContinuumModelDef`</span>
<span class="sd">        is not well designed.</span>

<span class="sd">    Args:</span>
<span class="sd">        template_library_key (str): Keyword of the library to fit.  See</span>
<span class="sd">            :func:`mangadap.proc.templatelibrary.available_template_libraries`.</span>

<span class="sd">        template_library</span>
<span class="sd">            (:class:`mangadap.proc.templatelibrary.TemplateLibrary`):</span>
<span class="sd">            Object with the spectra in the template library that have</span>
<span class="sd">            been prepared for analysis of the data.</span>

<span class="sd">        guess_redshift (array-like): Initial guess for the redshift</span>
<span class="sd">            (:math:`cz`) of each binned spectrum.</span>

<span class="sd">        guess_dispersion (array-like): Initial guess for the velocity</span>
<span class="sd">            dispersion for each binned spectrum.</span>

<span class="sd">        iteration_mode (str): (**Optional**) Iteration mode to use; see</span>
<span class="sd">            :func:`PPXFFit.iteration_modes`.</span>

<span class="sd">        match_resolution (bool): (**Optional**) Match the spectral</span>
<span class="sd">            resolution of the template to that of the galaxy data.  This</span>
<span class="sd">            is used only when constructing the template library.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        </span>
<span class="sd">        velscale_ratio (int): (**Optional**) The **integer** ratio</span>
<span class="sd">            between the velocity scale of the pixel in the galaxy data</span>
<span class="sd">            to that of the template data.  This is used only when</span>
<span class="sd">            constructing the template library.  Default is None, which</span>
<span class="sd">            is the same as assuming that the velocity scales are</span>
<span class="sd">            identical.</span>
<span class="sd">        </span>
<span class="sd">        minimum_snr (float): (**Optional**) Minimum S/N ratio to include</span>
<span class="sd">            in the fitting.</span>

<span class="sd">        pixelmask (:class:`mangadap.proc.pixelmask.PixelMask`):</span>
<span class="sd">            (**Optional**) Pixel mask to include during the fitting.</span>
<span class="sd">        </span>
<span class="sd">        bias, degree, mdegree, moments: (**Optional**) See</span>
<span class="sd">            :class:`mangadap.contrib.ppxf.ppxf` documentation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template_library_key</span><span class="p">,</span> <span class="n">template_library</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">,</span>
                 <span class="n">iteration_mode</span><span class="o">=</span><span class="s1">&#39;global_template&#39;</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filter_operation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_iterations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">match_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">mdegree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filt_degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filt_mdegree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
        <span class="n">arr_in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span> <span class="c1"># guess kinematics</span>
        <span class="n">in_fl</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="p">]</span>                          <span class="c1"># bias, minimum S/N</span>

        <span class="n">_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_defaults</span><span class="p">()</span>
        
        <span class="n">iter_opt</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">iteration_modes</span><span class="p">()</span>
        <span class="n">moment_opt</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span> <span class="p">]</span>
        <span class="n">filter_operation_opt</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span> <span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span>     <span class="p">[</span> <span class="s1">&#39;template_library_key&#39;</span><span class="p">,</span> <span class="s1">&#39;template_library&#39;</span><span class="p">,</span> <span class="s1">&#39;guess_redshift&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;guess_dispersion&#39;</span><span class="p">,</span> <span class="s1">&#39;iteration_mode&#39;</span><span class="p">,</span> <span class="s1">&#39;reject_boxcar&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_boxcar&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;filter_operation&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_iterations&#39;</span><span class="p">,</span> <span class="s1">&#39;match_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;velscale_ratio&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;minimum_snr&#39;</span><span class="p">,</span> <span class="s1">&#39;pixelmask&#39;</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="s1">&#39;mdegree&#39;</span><span class="p">,</span> <span class="s1">&#39;filt_degree&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;filt_mdegree&#39;</span><span class="p">,</span> <span class="s1">&#39;moments&#39;</span> <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span>   <span class="p">[</span> <span class="n">template_library_key</span><span class="p">,</span> <span class="n">template_library</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">,</span>
                     <span class="n">iteration_mode</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="p">,</span> <span class="n">filter_boxcar</span><span class="p">,</span> <span class="n">filter_operation</span><span class="p">,</span>
                     <span class="n">filter_iterations</span><span class="p">,</span> <span class="n">match_resolution</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">minimum_snr</span><span class="p">,</span> <span class="n">pixelmask</span><span class="p">,</span>
                     <span class="n">bias</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">filt_degree</span><span class="p">,</span> <span class="n">filt_mdegree</span><span class="p">,</span> <span class="n">moments</span> <span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span>  <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">iter_opt</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">filter_operation_opt</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">moment_opt</span> <span class="p">]</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;global_template&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">],</span> <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">],</span> <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">],</span>
                     <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;filt_degree&#39;</span><span class="p">],</span> <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;filt_mdegree&#39;</span><span class="p">],</span> <span class="n">_def</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">dtypes</span> <span class="o">=</span>   <span class="p">[</span> <span class="nb">str</span><span class="p">,</span> <span class="n">TemplateLibrary</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="n">arr_in_fl</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span>
                     <span class="nb">int</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="n">PixelMask</span><span class="p">,</span> <span class="n">in_fl</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span> <span class="p">]</span>

        <span class="n">ParSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
                        <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>


<div class="viewcode-block" id="PPXFFitPar._keyword_defaults"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitPar._keyword_defaults">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_keyword_defaults</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the keyword defaults.  Pulled from</span>
<span class="sd">        :class:`mangadap.contrib.ppxf.ppxf`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        return { &#39;bias&#39;:None, &#39;clean&#39;:False, &#39;degree&#39;:4, &#39;mdegree&#39;:0, &#39;moments&#39;:2, &#39;regul&#39;:0,</span>
<span class="c1">#                 &#39;reddening&#39;:None, &#39;component&#39;:0, &#39;reg_dim&#39;:None }</span>
        <span class="k">return</span> <span class="p">{</span> <span class="s1">&#39;bias&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;mdegree&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;filt_degree&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;filt_mdegree&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                 <span class="s1">&#39;moments&#39;</span><span class="p">:</span><span class="mi">2</span> <span class="p">}</span></div>


<div class="viewcode-block" id="PPXFFitPar._check"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitPar._check">[docs]</a>    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform some preliminary checks on the values of the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_iterations&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;iteration_mode&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;fit_reject_filter&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Only the </span><span class="se">\&#39;</span><span class="s1">fit_reject_filter</span><span class="se">\&#39;</span><span class="s1"> iteration mode includes the filtering &#39;</span>
                          <span class="s1">&#39;iterations.&#39;</span><span class="p">)</span></div>
<span class="c1">#        if self[&#39;filter_iterations&#39;] &gt; 0 and not self[&#39;mdegree&#39;] &gt; 0:</span>
<span class="c1">#            raise ValueError(&#39;If filtering, the multiplicative polynomial must have a non-zero&#39;</span>
<span class="c1">#                             &#39; order (mdegree &gt; 0)&#39;)</span>
        
<span class="c1">#        if self[&#39;reddening&#39;] is not None:</span>
<span class="c1">#            if self[&#39;mdegree&#39;] &gt; 0:</span>
<span class="c1">#                warnings.warn(&#39;Cannot both fit multiplicative polynomial and reddening.&#39; \</span>
<span class="c1">#                              &#39;Ignoring mdegree.&#39;)</span>
<span class="c1">#                self[&#39;mdegree&#39;] = 0</span>
        <span class="c1"># Other checks (and the one above) done within pPXF</span>


<div class="viewcode-block" id="PPXFFitPar.toheader"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitPar.toheader">[docs]</a>    <span class="k">def</span> <span class="nf">toheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFTPLK&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;template_library_key&#39;</span><span class="p">],</span> <span class="s1">&#39;Template library key used with pPXF&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFMODE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;iteration_mode&#39;</span><span class="p">],</span> <span class="s1">&#39;pPXF iteration mode&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFBIAS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;pPXF bias value&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFAO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">],</span> <span class="s1">&#39;Additive order in pPXF&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFMO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">],</span> <span class="s1">&#39;Multiplicative order in pPXF&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFAO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filt_degree&#39;</span><span class="p">],</span> <span class="s1">&#39;Additive order for filtered spectra&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFMO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filt_mdegree&#39;</span><span class="p">],</span> <span class="s1">&#39;Multiplicative order for filtered spectra&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFMOM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">],</span> <span class="s1">&#39;Number of fitted LOSVD moments in pPXF&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFRBOX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">],</span> <span class="s1">&#39;pPXF rejection boxcar&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_boxcar&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFBOX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_boxcar&#39;</span><span class="p">],</span> <span class="s1">&#39;pPXF filtering boxcar&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_tterations&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFILT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_iteration&#39;</span><span class="p">],</span> <span class="s1">&#39;pPXF number of filtering iterations&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdr</span></div>


<div class="viewcode-block" id="PPXFFitPar.fromheader"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitPar.fromheader">[docs]</a>    <span class="k">def</span> <span class="nf">fromheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;template_library_key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFTPLK&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFBIAS&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFAO&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFMO&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filt_degree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFAO&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filt_mdegree&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFMO&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFMOM&#39;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFRBOX&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input header does not specify rejection boxcar.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_boxcar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFBOX&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input header does not specify filtering boxcar.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_boxcar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_iteration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s1">&#39;PPXFFILT&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Input header does not specify number of filtering iterations.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;filter_iteration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div></div>
        


<div class="viewcode-block" id="PPXFFitResult"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitResult">[docs]</a><span class="k">class</span> <span class="nc">PPXFFitResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A basic utility to save the critical parts of the pPXF model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">ppxf_fit</span><span class="p">,</span> <span class="n">ntpl</span><span class="p">,</span>
                 <span class="n">weight_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component_fits</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npixtot</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">tpl_to_use</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpm</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">goodpixels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">bestfit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tplwgt</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ntpl</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="c1">#        if numpy.sum(self.tplwgt) == 0:</span>
<span class="c1">#            print(ppxf_fit.weights[0:ntpl])</span>
<span class="c1">#            print(self.tplwgt)</span>
<span class="c1">#            print(self.status)</span>
<span class="c1">#            print(ppxf_fit.sol)</span>
<span class="c1">#            print(ppxf_fit.error)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tplwgterr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set status</span>
        <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="kc">None</span> 
        <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tplwgt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No non-zero templates!  Setting status as failed.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>            <span class="c1"># All template weights are zero!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">status</span>
<span class="c1">#        self.status = None if ppxf_fit is None else ppxf_fit.status</span>

        <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight_errors</span><span class="p">:</span>
            <span class="n">design_matrix</span> <span class="o">=</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">ppxf_fit</span><span class="o">.</span><span class="n">goodpixels</span><span class="p">,:]</span> \
                                <span class="o">/</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">ppxf_fit</span><span class="o">.</span><span class="n">goodpixels</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">cov</span><span class="p">,</span> <span class="n">_tplwgterr</span> <span class="o">=</span> <span class="n">capfit</span><span class="o">.</span><span class="n">cov_err</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tplwgterr</span> <span class="o">=</span> <span class="n">_tplwgterr</span><span class="p">[</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="c1">#            covariance_matrix = numpy.linalg.inv(numpy.matmul(design_matrix.T, design_matrix))</span>
<span class="c1">#            self.tplwgterr = numpy.sqrt(numpy.diag(covariance_matrix))[degree+1:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">polyweights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mdegree</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">mpolyweights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinerr</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">robust_rchi2</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">chi2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit_comp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ppxf_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">component_fits</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Construct the model for each component</span>
        <span class="n">component_weights</span> <span class="o">=</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ppxf_fit</span><span class="o">.</span><span class="n">component</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ppxf_fit</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bestfit_comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">component_weights</span><span class="p">,</span> <span class="n">ppxf_fit</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">:,:])</span>

        <span class="c1"># Include the multiplicative polynomial</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multcoef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mpoly</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">),</span>
                                                     <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">multcoef</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bestfit_comp</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mpoly</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

<span class="c1">#        pyplot.plot(ppxf_fit.bestfit, color=&#39;k&#39;)</span>
<span class="c1">#        for i in range(ppxf_fit.ncomp):</span>
<span class="c1">#            pyplot.plot(self.bestfit_comp[i,:])</span>
<span class="c1">#        pyplot.show()</span>


<div class="viewcode-block" id="PPXFFitResult.empty_fit"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitResult.empty_fit">[docs]</a>    <span class="k">def</span> <span class="nf">empty_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="PPXFFitResult.reached_maxiter"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitResult.reached_maxiter">[docs]</a>    <span class="k">def</span> <span class="nf">reached_maxiter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">5</span></div>

<div class="viewcode-block" id="PPXFFitResult.fit_failed"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFitResult.fit_failed">[docs]</a>    <span class="k">def</span> <span class="nf">fit_failed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_fit</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="PPXFModel"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFModel">[docs]</a><span class="k">class</span> <span class="nc">PPXFModel</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that reconstructs a pPXF model given a set of templates and</span>
<span class="sd">    the model parameters.</span>

<span class="sd">    This pulls functions from M. Cappellari&#39;s ppxf class, version 6.7.0.</span>

<span class="sd">    Input common to ppxf() input should have the same format as pPXF</span>
<span class="sd">    input.</span>

<span class="sd">    The only reason the galaxy spectrum (or spectra) are provided is to</span>
<span class="sd">    set if the data are to fit as reflection-symmetric and how many</span>
<span class="sd">    spectral pixels there are.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma_diff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">moments</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gas_reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reddening_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sky</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">templates_rfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Suppress terminal output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1"># Dimensions of spectrum (or spectra) to fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="n">galaxy</span><span class="o">.</span><span class="n">ndim</span>     <span class="c1"># nspec=2 for reflection-symmetric LOSVD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="n">galaxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># total pixels in the galaxy spectrum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">galaxy</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GALAXY data must be finite&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">vsyst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;VSYST must be defined for two-sided fitting&#39;</span><span class="p">)</span>

        <span class="c1"># Set templates to use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Pixel sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span> <span class="o">=</span> <span class="n">velscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vsyst</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">vsyst</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">vsyst</span><span class="o">/</span><span class="n">velscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_diff</span> <span class="o">=</span> <span class="n">sigma_diff</span><span class="o">/</span><span class="n">velscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># default value</span>
        <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;VELSCALE_RATIO must be an integer&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span> <span class="o">%</span> <span class="n">velscale_ratio</span>
            <span class="c1"># Make size multiple of velscale_ratio</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># This is the size after rebin()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span> <span class="o">//=</span> <span class="n">velscale_ratio</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">velscale_ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span> <span class="o">&lt;</span> <span class="n">galaxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;TEMPLATES length cannot be smaller than GALAXY&#39;</span><span class="p">)</span>

        <span class="c1"># Set the FFT of the templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npad</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
                                <span class="k">if</span> <span class="n">templates_rfft</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">templates_rfft</span>

        <span class="c1"># Set sky spectrum</span>
        <span class="k">if</span> <span class="n">sky</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sky</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sky</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">galaxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GALAXY and SKY must have the same size&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sky</span> <span class="o">=</span> <span class="n">sky</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sky</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsky</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Select polynomials to use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mdegree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trig</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`degree` must be even with `trig=True`&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`mdegree` must be even with `trig=True`&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyval</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">trigval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyvander</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">trigvander</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyvander</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legvander</span>

        <span class="c1"># Initialize the design matrix.  Additive polynomial components</span>
        <span class="c1"># are independent of the input parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span>  <span class="c1"># Number of additive polynomials in fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndmcols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsky</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndmcols</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">vand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyvander</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">]</span> <span class="o">=</span> <span class="n">vand</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>     <span class="c1"># poly for right spectrum</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span><span class="p">]</span> <span class="o">=</span> <span class="n">vand</span>

        <span class="c1"># Kinematic components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">component</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;COMPONENT must be integers&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># component is a scalar so all templates have the same LOSVD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">component</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There must be one kinematic COMPONENT per template&#39;</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;COMPONENT must range from 0 to NCOMP-1&#39;</span><span class="p">)</span>

        <span class="c1"># Isolate gas components</span>
        <span class="k">if</span> <span class="n">gas_component</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_component</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_any</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_component</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gas_component</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_component</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`gas_component` must be boolean&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_component</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">component</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`gas_component` and `component` must have the same size&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gas_component</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one `gas_component` must be set to true&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gas_any</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Set reddening</span>
        <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gas_reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;LAM must be given with REDDENING or GAS_REDDENING keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MDEGREE cannot be used with REDDENING keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gas_reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_any</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GAS_COMPONENT must be nonzero with GAS_REDDENING keyword&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lam</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">galaxy</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GALAXY and LAM must have the same size&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span> <span class="o">=</span> <span class="n">lam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="o">=</span> <span class="n">reddening</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gas_reddening</span> <span class="o">=</span> <span class="n">gas_reddening</span>
        <span class="k">if</span> <span class="n">reddening_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reddening_func</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">reddening_cal00</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">reddening_func</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`reddening_func` must be callable&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reddening_func</span> <span class="o">=</span> <span class="n">reddening_func</span>

        <span class="c1"># Kinematic moments to fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># moments is scalar: all LOSVDs have same number of G-H moments</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="c1"># negative moments --&gt; keep entire LOSVD fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MOMENTS must be an array of length NCOMP&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">tplwgts</span><span class="p">,</span> <span class="n">addpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gas_reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as :func:`construct`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">kin</span><span class="p">,</span> <span class="n">tplwgts</span><span class="p">,</span> <span class="n">addpoly</span><span class="o">=</span><span class="n">addpoly</span><span class="p">,</span> <span class="n">multpoly</span><span class="o">=</span><span class="n">multpoly</span><span class="p">,</span>
                              <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span> <span class="n">gas_reddening</span><span class="o">=</span><span class="n">gas_reddening</span><span class="p">)</span>


<div class="viewcode-block" id="PPXFModel.construct"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFModel.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">tplwgts</span><span class="p">,</span> <span class="n">addpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multpoly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">gas_reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a pPXF model spectrum provided the input</span>
<span class="sd">        parameters.  Mostly a copy of ppxf._linear_fit().</span>

<span class="sd">        Args:</span>
<span class="sd">            kin (list, numpy.ndarray): Must have the kinematics of each</span>
<span class="sd">                component.  Must be a list or array of vectors with a</span>
<span class="sd">                shape (NCOMP,).  The length of each vector in the</span>
<span class="sd">                list/array must be the same as MOMENTS.</span>
<span class="sd">            tplwgts (numpy.ndarray): Weights to apply to each template.</span>
<span class="sd">                Shape must be (NTEMP,).</span>
<span class="sd">            addpoly (numpy.ndarray): (**Optional**) Coefficients of the</span>
<span class="sd">                additive polynomials.  Shape must be</span>
<span class="sd">                (NSPEC*(DEGREE+1),).  Exception is raised if</span>
<span class="sd">                coefficients are expected (self.degree &gt; -1), but no</span>
<span class="sd">                coefficiencts are provided.</span>
<span class="sd">            multpoly (numpy.ndarray): (**Optional**) Coefficients of the</span>
<span class="sd">                multiplicative polynomials.  Shape must be</span>
<span class="sd">                (NSPEC*MDEGREE,).  Exception is raised if coefficients</span>
<span class="sd">                are expected (self.mdegree &gt; 0), but no coefficiencts</span>
<span class="sd">                are provided.</span>
<span class="sd">            reddening (float): (**Optional**) E(B-V) value for the</span>
<span class="sd">                continuum fit.  Exception is raised if value is expected</span>
<span class="sd">                (self.reddening is not None), but none is provided.</span>
<span class="sd">            gas_reddening (float): (**Optional**) E(B-V) value for the</span>
<span class="sd">                gas components.  Exception is raised if value is</span>
<span class="sd">                expected (self.reddening is not None), but none is</span>
<span class="sd">                provided.</span>

<span class="sd">        Returns:</span>

<span class="sd">            numpy.ndarray:</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check the input kinematics</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">kin</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">kin</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There must be one set of kinematic moments per component&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span> 
                                <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">)]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input kinematics have the incorrect length&#39;</span><span class="p">)</span>
        <span class="c1"># Convert velocity from km/s to pixels</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">flx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">flx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Check the optional input</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">addpoly</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">addpoly</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;addpoly must be provided with length </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">multpoly</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">multpoly</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multpoly must be provided with length </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;reddening must be provided&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gas_reddening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;gas_reddening must be provided&#39;</span><span class="p">)</span>

        <span class="c1"># Check the input template weights</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tplwgts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of template weights provided.&#39;</span><span class="p">)</span>
        <span class="c1"># Include the additive polynomial weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">addpoly</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="c1"># Get the real FFT of the LOSVDs</span>
        <span class="n">losvd_rfft</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">losvd_rfft</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">templates_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vsyst</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_diff</span><span class="p">)</span>

        <span class="c1"># Get the multiplicative polynomials</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># Different multiplicative poly for left/right spectra</span>
                <span class="n">mpoly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">multpoly</span><span class="p">[::</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">mpoly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">multpoly</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">mpoly</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpoly1</span><span class="p">,</span> <span class="n">mpoly2</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">multpoly</span><span class="p">))</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mpoly</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">reddening_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">reddening</span><span class="p">)</span>
        <span class="n">gas_mpoly</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">gas_reddening</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">reddening_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> <span class="n">gas_reddening</span><span class="p">)</span>

        <span class="c1"># Perform the LOSVD convolution and finish the design matrix</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">template_rfft</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates_rfft</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>  <span class="c1"># columns loop</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">):</span>
                <span class="n">pr</span> <span class="o">=</span> <span class="n">template_rfft</span><span class="o">*</span><span class="n">losvd_rfft</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npad</span><span class="p">)</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">tt</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_temp</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gas_component</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">gas_mpoly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">gas_mpoly</span>
            <span class="k">elif</span> <span class="n">mpoly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mpoly</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsky</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoly</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntemp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsky</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky</span>
            <span class="k">if</span> <span class="n">nspec</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>      <span class="c1"># Sky for right spectrum</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsky</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nsky</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sky</span>

        <span class="c1"># return the model</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PPXFFit"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit">[docs]</a><span class="k">class</span> <span class="nc">PPXFFit</span><span class="p">(</span><span class="n">StellarKinematicsFit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use pPXF to measure the stellar kinematics.  Although it can also</span>
<span class="sd">    fit the composition and emission lines, for now just force it to be</span>
<span class="sd">    a :class:`StellarKinematicsFit` objec.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        bitmask (BitMask): Bitmask to use for masking spectral pixels</span>
<span class="sd">            and parameter values.  For</span>
<span class="sd">            :func:`fit_SpatiallyBinnedSpectra`, must have bit for</span>
<span class="sd">            &#39;LOW_SNR&#39;.  For :func:`fit` must have bits for &#39;TPL_PIXELS&#39;,</span>
<span class="sd">            &#39;TRUNCATED&#39;, &#39;PPXF_REJECT&#39;, &#39;LARGE_CHI2&#39;, &#39;LARGE_RESID&#39;,</span>
<span class="sd">            &#39;INSUFFICIENT_DATA&#39;, &#39;FIT_FAILED&#39;, &#39;NEAR_BOUND&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define bit names as global to the class</span>
    <span class="n">snr_flag</span> <span class="o">=</span> <span class="s1">&#39;LOW_SNR&#39;</span>
    <span class="n">rng_flag</span> <span class="o">=</span> <span class="s1">&#39;OUTSIDE_RANGE&#39;</span>
    <span class="n">tpl_flag</span> <span class="o">=</span> <span class="s1">&#39;TPL_PIXELS&#39;</span>
    <span class="n">trunc_flag</span> <span class="o">=</span> <span class="s1">&#39;TRUNCATED&#39;</span>
    <span class="n">rej_flag</span> <span class="o">=</span> <span class="s1">&#39;PPXF_REJECT&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">StellarKinematicsFit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">)</span>
        <span class="c1"># Logging and terminal output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Imposed fitting boundaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Spectral data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Fitting parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Fitting options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_degree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_mdegree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="PPXFFit.iteration_modes"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.iteration_modes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">iteration_modes</span><span class="p">():</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Possible iteration methods:</span>

<span class="sd">            ``none``: Fit all bins with all templates with a single call</span>
<span class="sd">            to pPXF.</span>

<span class="sd">            ``fit_reject_filter``: Perform the following procedure:</span>
<span class="sd">                - Fit each spectrum</span>
<span class="sd">                - for n iterations:</span>
<span class="sd">                    - Reject outliers</span>
<span class="sd">                    - Filter the object and template spectra</span>
<span class="sd">                    - Fit the filtered spectra</span>
<span class="sd">                - Fit the unfiltered spectra with the kinematics fixed</span>
<span class="sd">                  to result of the final filtered fit</span>

<span class="sd">            ``no_global_wrej``: Do not fit the global spectrum</span>
<span class="sd">            first, but include a rejection iteration.  All templates are</span>
<span class="sd">            fit in each step.</span>

<span class="sd">            ``global_template``:  Fit the global spectrum with all</span>
<span class="sd">            templates and include a single rejection iteration.  The</span>
<span class="sd">            pixel mask for this fit is the base mask for all fits to the</span>
<span class="sd">            individual bins.  A single rejection iteration is done for</span>
<span class="sd">            each bin.  **Only the global template is used when fitting</span>
<span class="sd">            each bin.**</span>

<span class="sd">            ``nonzero_templates``:  Fit the global spectrum with</span>
<span class="sd">            all templates and include a single rejection iteration.  The</span>
<span class="sd">            pixel mask for this fit is the base mask for all fits to the</span>
<span class="sd">            individual bins.  A single rejection iteration is done for</span>
<span class="sd">            each bin.  **Only the templates with non-zero weights are</span>
<span class="sd">            used when fitting each bin.**</span>

<span class="sd">            ``all_templates``:  Fit the global spectrum with all</span>
<span class="sd">            templates and include a single rejection iteration.  The</span>
<span class="sd">            pixel mask for this fit is the base mask for all fits to the</span>
<span class="sd">            individual bins.  A single rejection iteration is done for</span>
<span class="sd">            each bin.  **All templates are used when fitting each bin.**</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of allowed options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;fit_reject_filter&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;no_global_wrej&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;global_template&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;nonzero_templates&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;all_templates&#39;</span>
               <span class="p">]</span></div>


<div class="viewcode-block" id="PPXFFit._mode_uses_global_spectrum"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_uses_global_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_uses_global_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;global_template&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;nonzero_templates&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;all_templates&#39;</span> <span class="p">]</span></div>

<div class="viewcode-block" id="PPXFFit._mode_uses_global_template"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_uses_global_template">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_uses_global_template</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;global_template&#39;</span> <span class="p">]</span></div>

            
<div class="viewcode-block" id="PPXFFit._mode_uses_nonzero_templates"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_uses_nonzero_templates">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_uses_nonzero_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;nonzero_templates&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="PPXFFit._mode_uses_all_templates"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_uses_all_templates">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_uses_all_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;fit_reject_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;no_global_wrej&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;all_templates&#39;</span> <span class="p">]</span></div>

<div class="viewcode-block" id="PPXFFit._mode_includes_rejection"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_includes_rejection">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_includes_rejection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span></div>

<div class="viewcode-block" id="PPXFFit._mode_uses_filter"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._mode_uses_filter">[docs]</a>    <span class="k">def</span> <span class="nf">_mode_uses_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">==</span> <span class="s1">&#39;fit_reject_filter&#39;</span></div>


<div class="viewcode-block" id="PPXFFit._check_mode"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._check_mode">[docs]</a>    <span class="k">def</span> <span class="nf">_check_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration_mode</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="p">,</span> <span class="n">filter_boxcar</span><span class="p">,</span> <span class="n">filter_operation</span><span class="p">,</span>
                    <span class="n">filter_iterations</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">iteration_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_modes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Do not understand iteration mode </span><span class="se">\&#39;</span><span class="si">{0}</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iteration_mode</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">=</span> <span class="n">iteration_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">!=</span> <span class="s1">&#39;fit_reject_filter&#39;</span> \
                                        <span class="ow">or</span> <span class="n">filter_iterations</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">filter_iterations</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span> <span class="o">==</span> <span class="s1">&#39;fit_reject_filter&#39;</span> <span class="ow">and</span> <span class="n">filter_boxcar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Must provide boxcar for filtering iterations.  Using default (100).&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span> <span class="o">=</span> <span class="n">filter_boxcar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span> <span class="o">=</span> <span class="n">reject_boxcar</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Must specify the filtering operation as either </span><span class="se">\&#39;</span><span class="s1">divide</span><span class="se">\&#39;</span><span class="s1"> or &#39;</span>
                              <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">subtract</span><span class="se">\&#39;</span><span class="s1">; using divide as default.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">=</span> <span class="s1">&#39;divide&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">=</span> <span class="n">filter_operation</span></div>


<div class="viewcode-block" id="PPXFFit.check_template_usage_flags"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_template_usage_flags">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_template_usage_flags</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">ntpl</span><span class="p">,</span> <span class="n">usetpl</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">usetpl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">usetpl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">ntpl</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">usetpl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ntpl</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided template selection object does not have the correct shape!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">usetpl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_usetpl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nobj</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_usetpl</span> <span class="o">=</span> <span class="n">usetpl</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_usetpl</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">ntpl</span><span class="p">,):</span>
                <span class="n">_usetpl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_usetpl</span><span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_usetpl</span></div>


<div class="viewcode-block" id="PPXFFit.check_input_kinematics"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_input_kinematics">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_input_kinematics</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span> <span class="n">guess_dispersion</span><span class="p">):</span>
        <span class="c1"># Get the input guess kinematics</span>
        <span class="n">_guess_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">guess_redshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_redshift</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_redshift</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide a single redshift or one per object spectrum.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_redshift</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_guess_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">_guess_redshift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">_guess_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">guess_dispersion</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_dispersion</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_dispersion</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide a single dispersion or one per object spectrum.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_guess_dispersion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_guess_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">_guess_dispersion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Set the input redshifts</span>
        <span class="n">input_cz</span> <span class="o">=</span> <span class="n">_guess_redshift</span><span class="o">*</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Set the input pPXF, pixel-based kinematics (see</span>
        <span class="c1"># convert_velocity)</span>
        <span class="n">guess_kin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_guess_redshift</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                    <span class="n">_guess_dispersion</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">input_cz</span><span class="p">,</span> <span class="n">guess_kin</span></div>


<div class="viewcode-block" id="PPXFFit.check_resolution_match"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_resolution_match">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_resolution_match</span><span class="p">(</span><span class="n">tpl_sres</span><span class="p">,</span> <span class="n">obj_sres</span><span class="p">,</span> <span class="n">matched_resolution</span><span class="p">):</span>
        <span class="c1"># Confirm there is enough information to handle an unmatched</span>
        <span class="c1"># resolution</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matched_resolution</span> <span class="ow">and</span> <span class="p">(</span><span class="n">obj_sres</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tpl_sres</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If the spectral resolution is not matched between the template and &#39;</span>
                             <span class="s1">&#39;the object data, you must provide the spectral resolution for both.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matched_resolution</span></div>


<div class="viewcode-block" id="PPXFFit.set_wavelength_range"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.set_wavelength_range">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_wavelength_range</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_waverange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> \
                                <span class="k">if</span> <span class="n">waverange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">waverange</span><span class="p">)</span>
        <span class="n">_waverange</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">_waverange</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">_waverange</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">_waverange</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">),</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_wave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">_waverange</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_waverange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_waverange</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_waverange</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nobj</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input wavelength range array does not have the correct shape.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_waverange</span></div>


<div class="viewcode-block" id="PPXFFit.initialize_model_mask"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.initialize_model_mask">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">initialize_model_mask</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velocity_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">model_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Include the mask, if provided</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape of object mask array must match its flux array.&#39;</span><span class="p">)</span>
                <span class="n">model_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">SpectralPixelMask</span><span class="p">):</span>
                <span class="n">model_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">boolean</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">nspec</span><span class="o">=</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">velocity_offsets</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">)</span> \
                                <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                                    <span class="n">mask</span><span class="o">.</span><span class="n">bits</span><span class="p">(</span><span class="n">bitmask</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">nspec</span><span class="o">=</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">velocity_offsets</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model_mask</span></div>


<div class="viewcode-block" id="PPXFFit.initialize_pixels_to_fit"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.initialize_pixels_to_fit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">initialize_pixels_to_fit</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span>
                                 <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">velocity_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_velocity_range</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span> <span class="n">alias_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># TODO: This function can alter obj_flux and obj_ferr !!  Return</span>
        <span class="c1"># them instead?</span>

        <span class="n">nobj</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>  <span class="c1"># Empty error messages</span>
        <span class="n">_waverange</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">set_wavelength_range</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">)</span>
        <span class="n">model_mask</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">initialize_model_mask</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">bitmask</span><span class="o">=</span><span class="n">bitmask</span><span class="p">,</span>
                                                   <span class="n">velocity_offset</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">)</span>

        <span class="c1"># Assess the regions that need to be masked during fitting</span>
        <span class="k">if</span> <span class="n">ensemble</span><span class="p">:</span>
            <span class="c1"># Treat all spectra as part of an ensemble so mask the same</span>
            <span class="c1"># region for all spectra</span>
            <span class="n">_waverange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">_waverange</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">_waverange</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fit_indx</span><span class="p">,</span> <span class="n">waverange_mask</span><span class="p">,</span> <span class="n">npix_mask</span><span class="p">,</span> <span class="n">alias_mask</span> \
                        <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">fitting_mask</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span>
                                               <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                               <span class="n">waverange</span><span class="o">=</span><span class="n">_waverange</span><span class="p">,</span>
                                               <span class="n">velocity_offset</span><span class="o">=</span><span class="n">velocity_offset</span><span class="p">,</span>
                                               <span class="n">max_velocity_range</span><span class="o">=</span><span class="n">max_velocity_range</span><span class="p">,</span>
                                               <span class="n">alias_window</span><span class="o">=</span><span class="n">alias_window</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span>
                                               <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#quiet)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> \
                            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">fit_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">fit_indx</span> <span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
            <span class="n">waverange_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">waverange_mask</span> <span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
            <span class="n">npix_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">npix_mask</span> <span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
            <span class="n">alias_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">alias_mask</span> <span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Treat all spectra independently, such that the masks are</span>
            <span class="c1"># independent</span>
            <span class="n">fit_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">waverange_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">npix_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">alias_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">_velocity_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">velocity_offset</span><span class="p">)</span> \
                                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">velocity_offset</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> \
                                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">velocity_offset</span><span class="p">]</span><span class="o">*</span><span class="n">nobj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_velocity_offset</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nobj</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of velocity offsets provided.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobj</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fit_indx</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">waverange_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">npix_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">alias_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> \
                            <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">fitting_mask</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span>
                                                   <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                   <span class="n">waverange</span><span class="o">=</span><span class="n">_waverange</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                                   <span class="n">velocity_offset</span><span class="o">=</span><span class="n">_velocity_offset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="n">max_velocity_range</span><span class="o">=</span><span class="n">max_velocity_range</span><span class="p">,</span>
                                                   <span class="n">alias_window</span><span class="o">=</span><span class="n">alias_window</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span>
                                                   <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#quiet)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>

        <span class="c1"># Add these regions to the mask</span>
        <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">waverange_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">npix_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">alias_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">waverange_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">waverange_mask</span><span class="p">],</span>
                                                         <span class="n">PPXFFit</span><span class="o">.</span><span class="n">rng_flag</span><span class="p">)</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">npix_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">npix_mask</span><span class="p">],</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">tpl_flag</span><span class="p">)</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">alias_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">alias_mask</span><span class="p">],</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">trunc_flag</span><span class="p">)</span>

        <span class="c1"># Make sure that the errors are valid</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">bitmask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>\
                                    <span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;INVALID_ERROR&#39;</span><span class="p">)</span>
        <span class="c1"># To avoid having pPXF throw an exception, make sure that all</span>
        <span class="c1"># of these bad errors are set to unity</span>
        <span class="n">obj_ferr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Update the internal mask of the data</span>
        <span class="n">obj_flux</span><span class="p">[</span><span class="n">model_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="n">obj_ferr</span><span class="p">[</span><span class="n">model_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Determine the starting and ending pixels and return</span>
        <span class="c1"># TODO: does this work if all the pixels are masked in a given</span>
        <span class="c1"># spectrum?</span>
        <span class="n">pix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span><span class="o">*</span><span class="n">nobj</span><span class="p">),</span>
                                   <span class="n">mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span></div>


<div class="viewcode-block" id="PPXFFit._run_fit_iteration"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._run_fit_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">_run_fit_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">base_velocity</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span>
                           <span class="n">tpl_rfft</span><span class="p">,</span> <span class="n">guess_kin</span><span class="p">,</span> <span class="n">fix_kinematics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">obj_to_fit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">tpl_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">weight_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit all the object spectra in obj_flux.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Calculate DOF in this function?</span>
<span class="sd">            - Explicitly set the bounds to use instead of using the pPXF</span>
<span class="sd">              defaults?</span>

<span class="sd">        Args:</span>
<span class="sd">            obj_flux (numpy.ma.MaskedArray): Size is :math:`N_{\rm</span>
<span class="sd">                spec}\times N_{\rm chan}`, object spectra.</span>
<span class="sd">            obj_ferr (numpy.ma.MaskedArray): Size is :math:`N_{\rm</span>
<span class="sd">                spec}\times N_{\rm chan}`, object errors</span>
<span class="sd">            start (array): Size is :math:`N_{\rm spec}`, starting pixel</span>
<span class="sd">                for each spectrum</span>
<span class="sd">            end (array): Size is :math:`N_{\rm spec}`, ending pixel (+1)</span>
<span class="sd">                for each spectrum</span>
<span class="sd">            base_velocity (array): Size is :math:`N_{\rm spec}`, base</span>
<span class="sd">                velocity offset between each object spectrum and the</span>
<span class="sd">                template spectra.</span>
<span class="sd">            tpl_flux (array): Size is :math:`N_{\rm tpl}\times N_{\rm</span>
<span class="sd">                tpl chan}`, template spectra</span>
<span class="sd">            tpl_rfft (array): Size is :math:`N_{\rm tpl}\times N_{\rm</span>
<span class="sd">                tpl pad}`, real FFT of the template spectra</span>
<span class="sd">            guess_kin (array): Initial guess for kinematics.  Size is</span>
<span class="sd">                :math:`N_{\rm spec}\times N_{\rm moments}`.</span>
<span class="sd">            fix_kinematics (bool): (**Optional**) Flag to fix the</span>
<span class="sd">                kinematics to the input values during the fit.</span>
<span class="sd">            obj_to_fit (array): (**Optional**) Size is :math:`N_{\rm</span>
<span class="sd">                spec}`, boolean flag to fit object spectrum</span>
<span class="sd">            tpl_to_use (array): (**Optional**) Size is :math:`N_{\rm</span>
<span class="sd">                spec}\times N_{\rm tpl}`, boolean flag to use a template</span>
<span class="sd">                for the fit to each object spectrum</span>
<span class="sd">            plot (bool): (**Optional**) Produce the default ppxf fit</span>
<span class="sd">                plot.</span>
<span class="sd">            degree (int): (**Optional**) Additive polynomial order.</span>
<span class="sd">                Default is to use the internal attribute :attr:`degree`.</span>
<span class="sd">            mdegree (int): (**Optional**) Multiplicative polynomial</span>
<span class="sd">                order.  Default is to use the internal attribute</span>
<span class="sd">                :attr:`mdegree`.</span>
<span class="sd">            dof (int): (**Optional**) Number of degrees of freedom in</span>
<span class="sd">                the fit.  Default is to use the internal attribute</span>
<span class="sd">                :attr:`dof`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : Array with :math:`N_{\rm spec}` instances of</span>
<span class="sd">            :class:`PPXFFitResult`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the list of templates to use</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_obj_to_fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">obj_to_fit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">obj_to_fit</span>
        <span class="n">ntpl</span> <span class="o">=</span> <span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">tpl_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tpl_to_use</span>

<span class="c1">#        input_kin = self.guess_kin if fixed_kin is None else fixed_kin</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="k">if</span> <span class="n">fix_kinematics</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="k">if</span> <span class="n">degree</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">degree</span>
        <span class="n">mdegree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="k">if</span> <span class="n">mdegree</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mdegree</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dof</span>

<span class="c1">#        linear = fixed_kin is not None and mdegree &lt; 1</span>
        <span class="n">linear</span> <span class="o">=</span> <span class="n">fix_kinematics</span> <span class="ow">and</span> <span class="n">mdegree</span> <span class="o">&lt;</span> <span class="mi">1</span>

        <span class="c1"># Create the object to hold all the fits</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="c1">#        plot=True</span>

        <span class="c1"># Fit each spectrum</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running pPXF fit on spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># Meant to ignore this spectrum</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_obj_to_fit</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Get the pixels to fit for this spectrum</span>
            <span class="n">gpm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Check if there is sufficient data for the fit</span>
            <span class="n">ntpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gpm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dof</span><span class="o">+</span><span class="n">ntpl_to_use</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Insufficient data points (</span><span class="si">{0}</span><span class="s1">) to fit spectrum </span><span class="si">{1}</span><span class="s1">&#39;</span>
                                  <span class="s1">&#39;(dof=</span><span class="si">{2}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gpm</span><span class="p">),</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dof</span><span class="o">+</span><span class="n">ntpl_to_use</span><span class="p">))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PPXFFitResult</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                                          <span class="kc">None</span><span class="p">,</span> <span class="n">ntpl</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Run ppxf</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">pyplot</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PPXFFitResult</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span>
                            <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">tpl_flux</span><span class="p">[</span><span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                      <span class="n">obj_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                      <span class="n">obj_ferr</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                      <span class="n">guess_kin</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                      <span class="n">goodpixels</span><span class="o">=</span><span class="n">gpm</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                                      <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=-</span><span class="n">base_velocity</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">plot</span><span class="p">),</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">,</span>
                                      <span class="n">templates_rfft</span><span class="o">=</span><span class="n">tpl_rfft</span><span class="p">[</span><span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],:]</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">ntpl</span><span class="p">,</span>
                                      <span class="n">weight_errors</span><span class="o">=</span><span class="n">weight_errors</span><span class="p">)</span>

<span class="c1">#            if numpy.sum(result[i].tplwgt) == 0:</span>
<span class="c1">#                print(numpy.sum(numpy.invert(numpy.isfinite(obj_ferr.data[i,start[i]:end[i]]))))</span>
<span class="c1">#                print(numpy.sum(numpy.invert(obj_ferr.data[i,start[i]:end[i]] &gt; 0)))</span>
<span class="c1">#                pyplot.plot(self.obj_wave[start[i]:end[i]], obj_flux.data[i,start[i]:end[i]])</span>
<span class="c1">#                pyplot.plot(self.obj_wave[start[i]:end[i]], obj_ferr.data[i,start[i]:end[i]])</span>
<span class="c1">#                for j in range(numpy.sum(tpl_to_use[i,:])):</span>
<span class="c1">#                    pyplot.plot(self.tpl_wave, tpl_flux[tpl_to_use[i,:],:][j,:])</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#                exit()</span>


<span class="c1">#            print(result[i].tplwgt)</span>
<span class="c1">#            print(result[i].tpl_to_use)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#                result[i].kin[1] = numpy.absolute(result[i].kin[1]) #self.sigma_limits[0]</span>
<span class="c1">#                warnings.warn(&#39;pPXF gives negative dispersion! Change -{0:.4f} to {0:.4f}&#39;.format(</span>
<span class="c1">#                                    result[i].kin[1]))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dispersion less than 0! </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reached_maxiter</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;pPXF optimizer reached maximum number of iterations for spectrum &#39;</span>
                              <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">pyplot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">#            model = PPXFModel(tpl_flux[tpl_to_use[i,:],:].T, obj_flux.data[i,start[i]:end[i]],</span>
<span class="c1">#                              self.velscale, velscale_ratio=self.velscale_ratio, degree=degree,</span>
<span class="c1">#                              mdegree=mdegree, moments=moments, vsyst=-base_velocity[i],</span>
<span class="c1">#                              quiet=True, templates_rfft=tpl_rfft[tpl_to_use[i,:],:].T)</span>
<span class="c1">#           </span>
<span class="c1">#            modelfit = model(result[i].kin, result[i].tplwgt, addpoly=result[i].addcoef,</span>
<span class="c1">#                             multpoly=result[i].multcoef)</span>
<span class="c1">#</span>
<span class="c1">#            print(numpy.sum(result[i].bestfit-modelfit))</span>
<span class="c1">#</span>
<span class="c1">#            pyplot.plot(self.obj_wave[start[i]:end[i]], modelfit, color=&#39;C0&#39;)</span>
<span class="c1">#            pyplot.plot(self.obj_wave[start[i]:end[i]], result[i].bestfit, color=&#39;C3&#39;)</span>
<span class="c1">#            pyplot.plot(self.obj_wave[start[i]:end[i]], result[i].bestfit-modelfit, color=&#39;C1&#39;)</span>
<span class="c1">#            pyplot.show()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running pPXF fit on spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span><span class="n">nspec</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="PPXFFit._fit_global_spectrum"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._fit_global_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">_fit_global_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_to_include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the global spectrum.  This:</span>
<span class="sd">            - Sets the base-level good pixel mask for the fits to the individual</span>
<span class="sd">              bins</span>
<span class="sd">            - Gives the template weights for the global template</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Only include spectra above a given S/N in global spectrum?</span>
<span class="sd">            - Allow for a number of iterations as input.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_obj_to_include</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="n">obj_to_include</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">obj_to_include</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_obj_to_include</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of object flags.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the global spectrum and its error</span>
        <span class="c1"># TODO: Does not include covariance!</span>
        <span class="n">global_spectrum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">[</span><span class="n">_obj_to_include</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">global_spectrum_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                                <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">[</span><span class="n">_obj_to_include</span><span class="p">,:]),</span>
                                                         <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">global_spectrum_err</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">global_spectrum</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c1"># To avoid pPXF error</span>

        <span class="c1"># TODO: Because of how it&#39;s used, setting start, end, and</span>
        <span class="c1"># base_vel this way will mess things up later in the fit()</span>
        <span class="c1"># function UNLESS all the spectra have the same start and end;</span>
        <span class="c1"># ie., when fitting the global spectrum, the object spectra</span>
        <span class="c1"># provided to fit() must be treated as an ensemble.</span>

        <span class="c1"># Set the fitting region and base velocity offset</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">)])</span>
        <span class="n">base_vel</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">)]])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">)])</span>

        <span class="c1"># Use any template that is request for any of the individual</span>
        <span class="c1"># spectra</span>
        <span class="n">usetpl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usetpl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#        plot=True</span>
        <span class="c1"># Fit the spectrum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;First fit to global spectrum.&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">global_spectrum</span><span class="p">,</span> <span class="n">global_spectrum_err</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
                                         <span class="n">base_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">,</span>
                                         <span class="n">fix_kinematics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">usetpl</span><span class="p">,</span>
                                         <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>

        <span class="c1"># Return if pPXF failed</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;pPXF failed to fit global spectrum!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Perform a single fit rejection</span>
        <span class="n">global_spectrum</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">reject_model_outliers</span><span class="p">(</span><span class="n">global_spectrum</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># refit the spectrum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Fit to global spectrum after rejection.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">global_spectrum</span><span class="p">,</span> <span class="n">global_spectrum_err</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
                                       <span class="n">base_vel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">,</span>
                                       <span class="n">fix_kinematics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">usetpl</span><span class="p">,</span>
                                       <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="PPXFFit._fill_ppxf_par"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._fill_ppxf_par">[docs]</a>    <span class="k">def</span> <span class="nf">_fill_ppxf_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">no_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># Moments for each kinematic component</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">)</span>
        <span class="n">_moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">moments</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> \
                              <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span>

        <span class="c1"># Construct the LOSVD parameter vector</span>
        <span class="n">vj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">_moments</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">kin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span>
        <span class="k">if</span> <span class="n">no_shift</span><span class="p">:</span>
            <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">par</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">vj</span></div>


<div class="viewcode-block" id="PPXFFit._get_losvd_kernels"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._get_losvd_kernels">[docs]</a>    <span class="k">def</span> <span class="nf">_get_losvd_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">no_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="n">nspec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">losvd_kernel_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">par</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_ppxf_par</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">,</span> <span class="n">no_shift</span><span class="o">=</span><span class="n">no_shift</span><span class="p">)</span>
            <span class="n">losvd_kernel_rfft</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">losvd_rfft</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="mf">0.0</span> <span class="k">if</span> <span class="n">no_shift</span> <span class="k">else</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">losvd_kernel_rfft</span></div>
            

<div class="viewcode-block" id="PPXFFit._matched_mask_filter"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._matched_mask_filter">[docs]</a>    <span class="k">def</span> <span class="nf">_matched_mask_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="n">obj_mask</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span> <span class="n">tpl_rfft</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self.tpl_npad must exist!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the LOSVD kernels for each fit</span>
        <span class="n">losvd_kernel_rfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_losvd_kernels</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">npix_tpl_resampled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span>

        <span class="c1"># Instantiate the output arrays</span>
        <span class="n">ntpl_per_obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tpl_flux_filt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ntpl_per_obj</span><span class="p">),</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">tpl_to_use_filt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ntpl_per_obj</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># For each spectrum:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">losvd_kernel_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Masking and smoothing templates for object spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">losvd_kernel_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="c1">#            t = time.clock()</span>

            <span class="c1"># Get all the templates convolved by the LOSVD for this fit</span>
            <span class="n">cnvlv_tpl_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">tpl_rfft</span><span class="p">[</span><span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span>
                                                    <span class="o">*</span> <span class="n">losvd_kernel_rfft</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="kc">None</span><span class="p">,:],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,:</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cnvlv_tpl_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cnvlv_tpl_flux</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ntpl_per_obj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#            print(&#39;fft: time: {0} seconds&#39;.format(time.clock() - t))</span>

            <span class="c1"># Get the object-spectrum mask shifted to the template frame</span>
            <span class="n">_obj_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obj_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]]</span><span class="o">*</span><span class="n">ntpl_per_obj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_obj_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">_obj_mask</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">_obj_mask</span><span class="p">[:,:</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_obj_mask</span><span class="p">[:,</span><span class="n">shift</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
           
            <span class="c1"># Apply the mask to the convolved spectra</span>
            <span class="n">_cnvlv_tpl_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">cnvlv_tpl_flux</span><span class="p">,</span>
                                                   <span class="n">mask</span><span class="o">=</span><span class="n">_obj_mask</span><span class="p">[:,:</span><span class="n">npix_tpl_resampled</span><span class="p">])</span>

            <span class="c1"># Smooth the template spectra using the same smoothing</span>
            <span class="c1"># function as used for the object data</span>
<span class="c1">#            t2 = time.clock()</span>
            <span class="n">sm_cnvlv_tpl_flux</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">_cnvlv_tpl_flux</span><span class="p">)</span>
<span class="c1">#            print(&#39;smooth: time: {0} seconds&#39;.format(time.clock() - t2))</span>

            <span class="c1"># Interpolate the smoothing function to the original pixels</span>
            <span class="c1"># of the template spectra</span>
<span class="c1">#            t2 = time.clock()</span>
            <span class="n">pixcoo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pixcoo</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">),</span>
                                                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">sm_cnvlv_tpl_flux</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sm_tpl_flux</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">pixcoo</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#            print(&#39;interpolate: time: {0} seconds&#39;.format(time.clock() - t2))</span>

            <span class="c1"># Set the filtered templates for this object spectrum</span>
            <span class="n">tpls</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ntpl_per_obj</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">tple</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ntpl_per_obj</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">tpl_to_use_filt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">tpls</span><span class="p">:</span><span class="n">tple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">==</span> <span class="s1">&#39;divide&#39;</span><span class="p">:</span>
                <span class="n">tpl_flux_filt</span><span class="p">[</span><span class="n">tpls</span><span class="p">:</span><span class="n">tple</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">tpl_flux</span><span class="p">[</span><span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">],:],</span>
                                                             <span class="n">sm_tpl_flux</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tpl_flux_filt</span><span class="p">[</span><span class="n">tpls</span><span class="p">:</span><span class="n">tple</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">tpl_flux</span><span class="p">[</span><span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">],:]</span> <span class="o">-</span> <span class="n">sm_tpl_flux</span>
<span class="c1">#            print(&#39;obj: {0}, total time: {1} seconds&#39;.format(i+1, time.clock() - t))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Masking and smoothing templates for object spectrum:              DONE&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tpl_flux_filt</span><span class="p">,</span> <span class="n">tpl_to_use_filt</span></div>


<div class="viewcode-block" id="PPXFFit._fit_all_spectra"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._fit_all_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">_fit_all_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">templates_rfft</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">plot_file_root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit all spectra provided.</span>

<span class="sd">        - Get an initial fit</span>
<span class="sd">        - Reject</span>
<span class="sd">        - Mask and smooth templates and objects</span>
<span class="sd">        - Fit ratio</span>
<span class="sd">        - Mask and smooth</span>
<span class="sd">        - Fit ratio</span>
<span class="sd">        - Fit unmasked with fixed kinematics to get models (with</span>
<span class="sd">          emission lines?)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fit the spectra</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of object spectra to fit: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">)))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span>
                                         <span class="n">templates_rfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">,</span>
                                         <span class="n">fix_kinematics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">,</span>
                                         <span class="n">obj_to_fit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">tpl_to_use</span><span class="p">,</span>
                                         <span class="n">weight_errors</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_includes_rejection</span><span class="p">(),</span>
                                         <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_includes_rejection</span><span class="p">():</span>
            <span class="c1"># Only a single fit so return</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Copy the input as to not overwrite the input masks</span>
        <span class="n">obj_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj_ferr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj_to_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Save which were not fit successfully</span>
        <span class="n">obj_to_fit</span> <span class="o">&amp;=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">r</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Number of object spectra to fit (excluding failed fits): </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">)))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Reject model outliers</span>
        <span class="c1"># TODO: This will cause an error if boxcar is None!</span>
        <span class="n">obj_flux</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">reject_model_outliers</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">local_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">boxcar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span><span class="p">,</span>
                                                 <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
        <span class="c1"># Copy the new mask to the errors</span>
        <span class="n">obj_ferr</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Refit and return results</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span>
                                           <span class="n">templates_rfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">,</span>
                                           <span class="n">fix_kinematics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">,</span>
                                           <span class="n">obj_to_fit</span><span class="o">=</span><span class="n">obj_to_fit</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">tpl_to_use</span><span class="p">,</span>
                                           <span class="n">weight_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Iteratively filter, fit and reject outliers</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filtering. Boxcar size is </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span><span class="p">))</span>
        <span class="n">bf</span> <span class="o">=</span> <span class="n">BoxcarFilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span><span class="p">):</span>

            <span class="c1"># Get the filtered object spectra and errors</span>
            <span class="n">sm_obj_flux</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">==</span> <span class="s1">&#39;divide&#39;</span><span class="p">:</span>
                <span class="n">obj_flux_filt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">sm_obj_flux</span><span class="p">)</span>
                <span class="n">obj_ferr_filt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="n">sm_obj_flux</span><span class="p">))</span>
                <span class="n">obj_ferr_filt</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_ferr_filt</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_flux_filt</span> <span class="o">=</span> <span class="n">obj_flux</span> <span class="o">-</span> <span class="n">sm_obj_flux</span>
                <span class="n">obj_ferr_filt</span> <span class="o">=</span> <span class="n">obj_ferr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">obj_ferr_filt</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_ferr_filt</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1">#            pyplot.imshow(obj_flux, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#            pyplot.imshow(numpy.ma.log10(obj_flux_filt), origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="c1">#                          aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
        
            <span class="c1"># Get the filtered template spectra</span>
            <span class="n">tpl_flux_filt</span><span class="p">,</span> <span class="n">tpl_to_use_filt</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matched_mask_filter</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux_filt</span><span class="p">),</span>
                                                    <span class="n">templates</span><span class="p">,</span> <span class="n">templates_rfft</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Constructing FFT of filtered templates&#39;</span><span class="p">)</span>
            <span class="n">tpl_flux_filt_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">tpl_flux_filt</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">#            pyplot.imshow(templates, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;, aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#            pyplot.imshow(numpy.ma.log10(tpl_flux_filt), origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="c1">#                          aspect=&#39;auto&#39;)</span>
<span class="c1">#            pyplot.show()</span>
       
            <span class="c1"># Fit the filtered spectra        </span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">tpl_flux_filt</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;There are masked template pixels!&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">obj_flux_filt</span><span class="p">,</span> <span class="n">obj_ferr_filt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span>
                                             <span class="n">tpl_flux_filt</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">tpl_flux_filt_rfft</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">,</span>
                                             <span class="n">fix_kinematics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">,</span>
                                             <span class="n">obj_to_fit</span><span class="o">=</span><span class="n">obj_to_fit</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">tpl_to_use_filt</span><span class="p">,</span>
                                             <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_mdegree</span><span class="p">,</span>
                                             <span class="n">dof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                                             <span class="n">weight_errors</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Reject outliers</span>
            <span class="c1"># TODO: This will cause an error if boxcar is None!</span>
            <span class="n">obj_flux_filt</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">reject_model_outliers</span><span class="p">(</span><span class="n">obj_flux_filt</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                          <span class="n">local_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                          <span class="n">boxcar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reject_boxcar</span><span class="p">,</span>
                                                          <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>
            <span class="c1"># Copy the new mask to the unfiltered spectra</span>
            <span class="n">obj_flux</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux_filt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">obj_ferr</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Reset template flags back to original, add the smoothed object</span>
        <span class="c1"># spectra into the best-fitting models, and recalculate chi-sqr</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">==</span> <span class="s1">&#39;divide&#39;</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bestfit</span> <span class="o">*=</span> <span class="n">sm_obj_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bestfit</span> <span class="o">+=</span> <span class="n">sm_obj_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bestfit</span><span class="p">)[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">]</span> \
                        <span class="o">/</span> <span class="n">obj_ferr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">][</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">]</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">robust_rchi2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">chi</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">chi</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span>
                                                                   <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_mdegree</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">#            pyplot.plot(self.obj_wave[result[i].start:result[i].end],</span>
<span class="c1">#                        self.obj_flux[i,result[i].start:result[i].end], color=&#39;k&#39;, lw=0.5)</span>
<span class="c1">#            pyplot.plot(self.obj_wave[result[i].start:result[i].end],</span>
<span class="c1">#                        result[i].bestfit, color=&#39;C3&#39;, lw=1.0)</span>
<span class="c1">#            pyplot.show()</span>

        <span class="c1"># Return the filtered results</span>
        <span class="k">return</span> <span class="n">result</span></div>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># THIS CODE IS THE OLD APPROACH !!</span>
        <span class="c1">#---------------------------------------------------------------</span>
<span class="c1">#        # Reset template flags back to original, unfiltered flags and</span>
<span class="c1">#        # construct the optimized template based on the filtered fit</span>
<span class="c1">#        optimal_templates = numpy.zeros((self.nobj,self.npix_tpl), dtype=float)</span>
<span class="c1">#        optimal_templates_filt = numpy.zeros((self.nobj,self.npix_tpl), dtype=float)</span>
<span class="c1">#        optimal_templates_rfft = numpy.empty((self.nobj,self.tpl_rfft.shape[1]), dtype=complex)</span>
<span class="c1">#        for i in range(self.nobj):</span>
<span class="c1">#            if result[i] is None:</span>
<span class="c1">#                continue</span>
<span class="c1">#            optimal_templates_filt[i,:] = numpy.dot(result[i].tplwgt,</span>
<span class="c1">#                                                    tpl_flux_filt.data[result[i].tpl_to_use,:])</span>
<span class="c1">#            result[i].tpl_to_use = tpl_to_use[i,:]</span>
<span class="c1">#            optimal_templates[i,:] = numpy.dot(result[i].tplwgt, templates[tpl_to_use[i,:],:])</span>
<span class="c1">#            optimal_templates_rfft[i,:] = numpy.dot(result[i].tplwgt,</span>
<span class="c1">#                                                    templates_rfft[tpl_to_use[i,:],:])</span>
<span class="c1">##            pyplot.plot(self.tpl_wave, optimal_templates[i,:])</span>
<span class="c1">##            pyplot.plot(self.tpl_wave, optimal_templates[i,:]-optimal_templates_filt[i,:])</span>
<span class="c1">##            pyplot.plot(self.tpl_wave, optimal_templates_filt[i,:])</span>
<span class="c1">##            pyplot.show()</span>
<span class="c1">#        optimal_tpl_to_use = numpy.identity(self.nobj, dtype=bool)</span>
<span class="c1">#        print(optimal_tpl_to_use)</span>
<span class="c1">#</span>
<span class="c1">#        # Use the best-fit kinematics for the final fit where the</span>
<span class="c1">#        # kinematics are fixed to the filtered result</span>
<span class="c1">#        best_fit_kin = numpy.zeros((nspec,numpy.absolute(self.moments)), dtype=float)</span>
<span class="c1">#        best_fit_kin[obj_to_fit] = numpy.array([ r.kin for r in result[obj_to_fit] ])</span>
<span class="c1">#</span>
<span class="c1">#        # Refit the unfiltered spectra with the fixed kinematics</span>
<span class="c1">#        fixed_kin_result = self._run_fit_iteration(obj_flux, obj_ferr, self.spectrum_start,</span>
<span class="c1">#                                                   self.spectrum_end, self.base_velocity,</span>
<span class="c1">#                                                   optimal_templates, optimal_templates_rfft,</span>
<span class="c1">#                                                   best_fit_kin,</span>
<span class="c1">#                                                   fix_kinematics=True, obj_to_fit=obj_to_fit,</span>
<span class="c1">#                                                   tpl_to_use=optimal_tpl_to_use, degree=degree,</span>
<span class="c1">#                                                   mdegree=mdegree, plot=True)#plot)</span>
<span class="c1">##        tplwgt = result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt * \</span>
<span class="c1">##                fixed_kin_result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt[0]</span>
<span class="c1">##        print(result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt *</span>
<span class="c1">##                fixed_kin_result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt[0])</span>
<span class="c1">#</span>
<span class="c1">#        # Refit the unfiltered spectra with the fixed kinematics</span>
<span class="c1">#        fixed_kin_result = self._run_fit_iteration(obj_flux, obj_ferr, self.spectrum_start,</span>
<span class="c1">#                                                   self.spectrum_end, self.base_velocity,</span>
<span class="c1">#                                                   templates, templates_rfft, best_fit_kin,</span>
<span class="c1">#                                                   fix_kinematics=True, obj_to_fit=obj_to_fit,</span>
<span class="c1">#                                                   tpl_to_use=tpl_to_use, degree=degree,</span>
<span class="c1">#                                                   mdegree=mdegree, plot=True)#plot)</span>
<span class="c1">##        print(fixed_kin_result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt)</span>
<span class="c1">##        pyplot.scatter(tplwgt, fixed_kin_result[numpy.arange(self.nobj)[obj_to_fit][0]].tplwgt,</span>
<span class="c1">##                        marker=&#39;.&#39;, s=50)</span>
<span class="c1">##        pyplot.plot([0,0.1],[0.0,0.1])</span>
<span class="c1">##        pyplot.show()</span>

<span class="c1">#        # Copy elements from the fixed kinematics result into the main</span>
<span class="c1">#        # result</span>
<span class="c1">#        for r,fr in zip(result[obj_to_fit],fixed_kin_result[obj_to_fit]):</span>
<span class="c1">#            fr.kinerr = r.kinerr</span>
<span class="c1">#</span>
<span class="c1">#        return fixed_kin_result</span>


<span class="c1">#    def _rescale_to_fit_emission_lines(self, ppxf_fit, i, global_weights, gpm, dvtol):</span>
<span class="c1">#</span>
<span class="c1">#        # - updated mask with emission-lines unmasked</span>
<span class="c1">#        # - Keep stellar kinematics fixed</span>
<span class="c1">#</span>
<span class="c1">#        # Construct a set of Gaussian emission line templates</span>
<span class="c1">#        z = (numpy.exp(ppxf_fit.sol[0]/astropy.constants.c.to(&#39;km/s&#39;).value)-1.0)</span>
<span class="c1">#        obj_rest_waverange = numpy.array([self.obj_wave[self.spectrum_start[i]],</span>
<span class="c1">#                                          self.obj_wave[self.spectrum_end[i]-1] ]) / (1+z)</span>
<span class="c1">#        </span>
<span class="c1">#        # TODO: Just adopting FWHM = 2.5 for now</span>
<span class="c1">#        gas_templates, line_names, line_wave = \</span>
<span class="c1">#                ppxf_util.emission_lines(numpy.log(self.tpl_wave), obj_rest_waverange, 2.5)</span>
<span class="c1">##        print(&#39;GAS&#39;)</span>
<span class="c1">##        print( gas_templates.shape )</span>
<span class="c1">##        print( numpy.sum(gas_templates, axis=0) )</span>
<span class="c1">##        for ii in range(gas_templates.shape[1]):</span>
<span class="c1">##            pyplot.plot(numpy.arange(gas_templates.shape[0]), gas_templates[:,ii])</span>
<span class="c1">##        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        # Construct the best-fitting stellar template based on the first</span>
<span class="c1">#        # fit</span>
<span class="c1">#</span>
<span class="c1">#        # TODO: Need to check that this works with the change in how the</span>
<span class="c1">#        # templates are selected for individual spectra</span>
<span class="c1">#        if self.iteration_mode == &#39;global_template_plus_emlines&#39;:</span>
<span class="c1">#            global_weights *= ppxf_fit.weights[0]</span>
<span class="c1">##        elif self.iteration_mode == &#39;nonzero_templates_plus_emlines&#39;:</span>
<span class="c1">##            global_weights[tpl_to_fit[i,:]] = ppxf_fit.weights[0:ntpl_to_fit]</span>
<span class="c1">#            #templates.shape[0]]</span>
<span class="c1">#        else:</span>
<span class="c1">#            global_weights[tpl_to_fit[i,:]] = ppxf_fit.weights[0:ntpl_to_fit]</span>
<span class="c1">##            global_weights = ppxf_fit.weights[0:self.ntpl]</span>
<span class="c1">#        global_template = numpy.dot(global_weights, self.tpl_flux).reshape(1,-1)</span>
<span class="c1">#</span>
<span class="c1">##        pyplot.plot(self.tpl_wave, global_template[0,:])</span>
<span class="c1">##        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        # Include emission-line templates with others</span>
<span class="c1">#        _templates = numpy.row_stack([global_template, gas_templates.T])</span>
<span class="c1">##        for ii in range(_templates.shape[0]):</span>
<span class="c1">##            pyplot.plot(numpy.arange(_templates.shape[1]), _templates[ii,:])</span>
<span class="c1">##        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        # Set the component values</span>
<span class="c1">#        _component = [0]*1 + [1]*gas_templates.shape[1]</span>
<span class="c1">#        # do not fit stars but use previous solution</span>
<span class="c1">#        _moments = [-self.moments, 2]</span>
<span class="c1">#        # initialize the gas kinematics based on the stars</span>
<span class="c1">#        _guess_kin = [ppxf_fit.sol[0:2], [ppxf_fit.sol[0], 50]]</span>
<span class="c1">##        _guess_kin = [ppxf_fit.sol[0:2], ppxf_fit.sol[0:2]]</span>
<span class="c1">#        # unmask the emission lines</span>
<span class="c1">#        _gpm = numpy.union1d(gpm, numpy.where(self.bitmask.flagged(</span>
<span class="c1">#                                        model_mask[i,self.spectrum_start[i]:self.spectrum_end[i]],</span>
<span class="c1">#                                        flag=&#39;EML_REGION&#39;))[0])</span>
<span class="c1">#        # Fit with emission lines, using only multiplicative polynomials</span>
<span class="c1">#        _ppxf_fit = ppxf.ppxf(_templates.T,</span>
<span class="c1">#                         self.obj_flux.data[i,self.spectrum_start[i]:self.spectrum_end[i]],</span>
<span class="c1">#                         self.obj_ferr.data[i,self.spectrum_start[i]:self.spectrum_end[i]],</span>
<span class="c1">#                         self.velscale, _guess_kin, velscale_ratio=self.velscale_ratio,</span>
<span class="c1">#                         goodpixels=_gpm, bias=self.bias, clean=self.clean, degree=-1,</span>
<span class="c1">#                         mdegree=8, moments=_moments, vsyst=-self.base_velocity[i],</span>
<span class="c1">#                         quiet=(not plot), plot=plot, component=_component)</span>
<span class="c1">#        if plot:</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        # Fit failed</span>
<span class="c1">#        if not ppxf_fit.status &gt; 0:</span>
<span class="c1">#            model_mask[i,:], model_par[&#39;MASK&#39;][i] = self._set_and_report_failed_status(</span>
<span class="c1">#                            model_mask[i,:], model_par[&#39;MASK&#39;][i],</span>
<span class="c1">#                           &#39;Emission-line iteration pPXF status for spectrum {0}; &#39;</span>
<span class="c1">#                           &#39;nothing saved.&#39;.format(i+1))</span>
<span class="c1">#            continue</span>
<span class="c1">#</span>
<span class="c1">#        # Save the necessary new data to the old fit (without</span>
<span class="c1">#        # emission lines)</span>
<span class="c1">#        ppxf_fit.weights = global_weights * _ppxf_fit.weights[0]</span>
<span class="c1">#        ppxf_fit.polyweights = None</span>
<span class="c1">#        ppxf_fit.mpolyweights = _ppxf_fit.mpolyweights</span>
<span class="c1">#</span>
<span class="c1">##        old_bestfit = ppxf_fit.bestfit</span>
<span class="c1">#        ppxf_fit.bestfit = self.reconstruct_model(self.tpl_wave, self.tpl_flux,</span>
<span class="c1">#                                self.obj_wave, ppxf_fit.sol, ppxf_fit.weights[0:self.ntpl],</span>
<span class="c1">#                                self.velscale, polyweights=ppxf_fit.polyweights,</span>
<span class="c1">#                                mpolyweights=ppxf_fit.mpolyweights,</span>
<span class="c1">#                                start=self.spectrum_start[i], end=self.spectrum_end[i],</span>
<span class="c1">#                                velscale_ratio=self.velscale_ratio, dvtol=dvtol,</span>
<span class="c1">#                                revert_velocity=False)[self.spectrum_start[i]:self.spectrum_end[i]]</span>
<span class="c1">##        pyplot.plot(self.obj_wave[self.spectrum_start:self.spectrum_end], ppxf_fit.bestfit)</span>
<span class="c1">##        pyplot.plot(self.obj_wave[self.spectrum_start:self.spectrum_end], _ppxf_fit.bestfit)</span>
<span class="c1">##        pyplot.plot(self.obj_wave[self.spectrum_start:self.spectrum_end], old_bestfit)</span>
<span class="c1">##        pyplot.show()</span>
<span class="c1">#        return ppxf_fit</span>


<div class="viewcode-block" id="PPXFFit._fit_dispersion_correction"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._fit_dispersion_correction">[docs]</a>    <span class="k">def</span> <span class="nf">_fit_dispersion_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">baseline_dispersion</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the dispersion correction:</span>
<span class="sd">          - Construct the optimized, redshifted template *without* the</span>
<span class="sd">            convolution with the best-fitting LOSVD.</span>
<span class="sd">          - Convolve it with the resolution difference in the data.</span>
<span class="sd">          - Use pPXF to fit the matched version to the unmatched version;</span>
<span class="sd">            this should be the dispersion correction.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Decide how to deal with regions below 2-pixel resolution in</span>
<span class="sd">            synthetic spectrum being fit.  How does this alter the</span>
<span class="sd">            correction?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Determining velocity dispersion corrections using fit to &#39;</span>
                       <span class="s1">&#39;resolution-matched templates.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct the model spectra with only the resolution</span>
        <span class="c1"># difference</span>
        <span class="n">model_wlosvd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_wlosvd_msres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_template</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_template_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">guess_kin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">res_match_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">tpl_ang_per_pix</span> <span class="o">=</span> <span class="n">angstroms_per_pixel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>
        <span class="n">unity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">_obj_to_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get the nominal kinematics</span>
        <span class="n">nominal_redshift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">nominal_dispersion</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_obj_to_fit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">()):</span>
                <span class="n">_obj_to_fit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_obj_to_fit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">baseline_dispersion</span> <span class="ow">is</span> <span class="kc">None</span> \
                                        <span class="k">else</span> <span class="n">baseline_dispersion</span>

        <span class="c1"># Create the spectra to use for the correction</span>
        <span class="n">niter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_obj_to_fit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                    <span class="k">continue</span>

                <span class="c1"># Get the convolution kernel with 0 velocity shift</span>
                <span class="n">nominal_par</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_ppxf_par</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span>
                                                                            <span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
                <span class="n">nominal_losvd_kernel_rfft</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">losvd_rfft</span><span class="p">(</span><span class="n">nominal_par</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Get the composite template</span>
                <span class="n">model_template</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgt</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">,:])</span>
                <span class="n">model_template_rfft</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgt</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">,:])</span>
<span class="c1">#                print(i+1, numpy.sum(result[i].tplwgt))</span>
<span class="c1">#                print(result[i].tplwgt)</span>
<span class="c1">#                if numpy.sum(result[i].tplwgt) == 0:</span>
<span class="c1">#                    pyplot.plot(self.obj_wave, self.obj_flux[i,:])</span>
<span class="c1">#                    pyplot.show()</span>
<span class="c1">#                    raise ValueError(&#39;zero template weights&#39;)</span>
<span class="c1">#                tmp_mt = numpy.fft.irfft(model_template_rfft[i,:], self.tpl_npad)[:self.npix_tpl]</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, model_template[i,:], lw=1, zorder=2)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, tmp_mt, lw=3, zorder=1)</span>
<span class="c1">#                pyplot.show()</span>

                <span class="c1"># Convolve the template to the fitted velocity dispersion</span>
                <span class="n">tmp_wlosvd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">model_template_rfft</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">nominal_losvd_kernel_rfft</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="p">]</span>
                <span class="n">model_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1">#                pyplot.plot(self.tpl_wave, model_template[i,:])</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, tmp_wlosvd)</span>
<span class="c1">#                pyplot.show()</span>

<span class="c1">#                obj_sres_obj = spectral_resolution(self.obj_wave/(1+nominal_redshift[i]),</span>
<span class="c1">#                                                   self.obj_sres[i,:])</span>
<span class="c1">#                self.tpl_sres.match(obj_sres_obj)</span>
<span class="c1">#                indx = (self.tpl_wave &gt; obj_sres_obj.wave()[result[i].start]) \</span>
<span class="c1">#                             &amp; (self.tpl_wave &lt; obj_sres_obj.wave()[result[i].end-1])</span>
<span class="c1">#                print(obj_sres_obj.wave()[result[i].start])</span>
<span class="c1">#                print(obj_sres_obj.wave()[result[i].end-1])</span>
<span class="c1">#                print(len(self.tpl_wave))</span>
<span class="c1">#                print(numpy.sum(indx))</span>
<span class="c1">#                pyplot.plot(self.tpl_wave[indx], self.tpl_sres.sig_pd[indx])</span>
<span class="c1">#                pyplot.show()</span>

                <span class="c1"># Match the spectral resolution</span>
                <span class="n">tmp_wlosvd_msres</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">res_match_offset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> \
                         <span class="n">match_spectral_resolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tmp_wlosvd</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sres</span><span class="o">.</span><span class="n">sres</span><span class="p">(),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">new_log10</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1">#                s = numpy.sqrt(8*numpy.log(2))</span>
<span class="c1">#                c = astropy.constants.c.to(&#39;km/s&#39;).value</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, c/s/self.tpl_sres.sres(), label=r&#39;MILES $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.obj_wave[result[i].start:result[i].end]/(1+nominal_redshift[i]),</span>
<span class="c1">#                            c/s/self.obj_sres[i,result[i].start:result[i].end], label=r&#39;MaNGA $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, c/s/sres, label=r&#39;Matched $R$&#39;)</span>
<span class="c1">#</span>
<span class="c1">#                diff2 = numpy.square(c/s/self.obj_sres[i,result[i].start:result[i].end]) \</span>
<span class="c1">#                        - numpy.square(c/s/self.tpl_sres(</span>
<span class="c1">#                            self.obj_wave[result[i].start:result[i].end]/(1+nominal_redshift[i])))</span>
<span class="c1">#                pyplot.plot(self.obj_wave[result[i].start:result[i].end]/(1+nominal_redshift[i]),</span>
<span class="c1">#                            numpy.ma.sqrt(diff2), label=r&#39;$\sigma_{\rm diff}$&#39;)</span>
<span class="c1">#                pyplot.plot(self.obj_wave[result[i].start:result[i].end]/(1+nominal_redshift[i]),</span>
<span class="c1">#                            numpy.ma.sqrt(diff2+numpy.square(res_match_offset[i]))</span>
<span class="c1">#                            , label=r&#39;$\sigma_{\rm diff,off}$&#39;)</span>

<span class="c1">#                pyplot.legend()</span>
<span class="c1">#                pyplot.xlabel(r&#39;$\lambda\ [\AA]$&#39;)</span>
<span class="c1">#                pyplot.ylabel(r&#39;$\sigma_{\rm inst}$ [km/s]&#39;) #r&#39;$R=\lambda/\Delta\lambda$&#39;)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, mask)</span>
<span class="c1">#                pyplot.show()</span>

                <span class="c1"># Check 2-pixel resolution limit in resolution-matched</span>
                <span class="c1"># spectrum</span>
<span class="c1">#                pix_per_fwhm = numpy.ma.divide(numpy.ma.divide(self.tpl_wave, sres),</span>
<span class="c1">#                                               tpl_ang_per_pix)</span>
<span class="c1">#                pix_per_fwhm = interpolate.interp1d(self.tpl_wave, pix_per_fwhm,</span>
<span class="c1">#                                                    fill_value=&#39;extrapolate&#39;)(self.obj_wave)</span>

<span class="c1">#                print(&#39;Resolution match offset: &#39;, res_match_offset[i])</span>
<span class="c1">#                print(&#39;Masked pixels: {0}/{1}&#39;.format(numpy.sum(mask), len(mask)))</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, model_template[i,:])</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, tmp_wlosvd, lw=1, label=r&#39;MILES $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, tmp_wlosvd_msres, lw=0.5, label=r&#39;MaNGA $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, tmp_wlosvd_msres-tmp_wlosvd, color=&#39;0.5&#39;, lw=0.5,</span>
<span class="c1">#                            label=r&#39;Difference&#39;)</span>
<span class="c1">#                pyplot.legend()</span>
<span class="c1">#                pyplot.xlabel(r&#39;$\lambda\ [\AA]$&#39;)</span>
<span class="c1">#                pyplot.ylabel(r&#39;Flux&#39;)</span>
<span class="c1">#                pyplot.plot(self.tpl_wave, mask)</span>
<span class="c1">##                pyplot.plot(self.tpl_wave, tmp_wlosvd_msres - model_template[i,:])</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#                exit()</span>

                <span class="c1"># Resample to match the object spectra</span>
                <span class="n">inRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">model_wlosvd</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">tmp_wlosvd</span><span class="p">,</span>
                                             <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                             <span class="n">inLog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">newRange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                             <span class="n">newpix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">newLog</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">outy</span>
                <span class="n">model_wlosvd_msres</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">tmp_wlosvd_msres</span><span class="p">,</span>
                                                   <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                   <span class="n">inLog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">newRange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                                                   <span class="n">newpix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">newLog</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">outy</span>

                <span class="c1"># Check 2-pixel resolution limit in resampled data</span>
<span class="c1">#                _, npix = resample_vector(unity, xRange=inRange, inLog=True,</span>
<span class="c1">#                                          newRange=self.obj_wave[[0,-1]],</span>
<span class="c1">#                                          newpix=self.obj_wave.size, newLog=True, conserve=True,</span>
<span class="c1">#                                          flat=False)</span>
<span class="c1">#                new_pix_per_fwhm = numpy.ma.divide(pix_per_fwhm, npix)</span>
<span class="c1">#                indx = new_pix_per_fwhm &lt; 2</span>
<span class="c1">#                print(&#39;Number below 2 pixels: {0}&#39;.format(numpy.sum(indx)))</span>

<span class="c1">#                pyplot.plot(self.tpl_wave, model_template[i,:])</span>
<span class="c1">#                pyplot.plot(self.obj_wave, model_wlosvd[i,:])</span>
<span class="c1">#                pyplot.plot(self.obj_wave, model_wlosvd_msres[i,:])</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#                pyplot.plot(self.obj_wave, npix)</span>
<span class="c1">#                pyplot.show()</span>


                <span class="c1"># Set the pixels to fit</span>
                <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span>

                <span class="n">model_wlosvd</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">model_wlosvd</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                <span class="n">model_wlosvd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">model_wlosvd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

                <span class="n">model_wlosvd_msres</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">model_wlosvd_msres</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                <span class="n">model_wlosvd_msres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">model_wlosvd_msres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

<span class="c1">#                pyplot.plot(self.obj_wave[start[i]:end[i]], model_wlosvd[i,start[i]:end[i]],</span>
<span class="c1">#                            lw=1, label=r&#39;MILES $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.obj_wave[start[i]:end[i]],</span>
<span class="c1">#                            model_wlosvd_msres[i,start[i]:end[i]], lw=0.5, label=r&#39;MaNGA $R$&#39;)</span>
<span class="c1">#                pyplot.plot(self.obj_wave[start[i]:end[i]],</span>
<span class="c1">#                    10*(model_wlosvd_msres[i,start[i]:end[i]]-model_wlosvd[i,start[i]:end[i]]),</span>
<span class="c1">#                            color=&#39;0.5&#39;, lw=0.5, label=r&#39;$10\times\Delta$&#39;)</span>
<span class="c1">#                pyplot.legend()</span>
<span class="c1">#                pyplot.xlabel(r&#39;$\lambda\ [\AA]$&#39;)</span>
<span class="c1">#                pyplot.ylabel(r&#39;Flux&#39;)</span>
<span class="c1">#                pyplot.show()</span>

                <span class="c1"># Set the guess kinematics</span>
                <span class="n">guess_kin</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nominal_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> \
                                    <span class="o">*</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">guess_kin</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Fit the model to the resolution-matched model</span>
            <span class="n">model_ferr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">model_ferr</span><span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">model_wlosvd_msres</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">result_wlosvd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">model_wlosvd</span><span class="p">,</span> <span class="n">model_ferr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span> <span class="n">model_template</span><span class="p">,</span>
                                                    <span class="n">model_template_rfft</span><span class="p">,</span> <span class="n">guess_kin</span><span class="p">,</span>
                                                    <span class="n">obj_to_fit</span><span class="o">=</span><span class="n">_obj_to_fit</span><span class="p">,</span>
                                                    <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">model_tpl_to_use</span><span class="p">)</span><span class="c1">#,</span>
                                                    <span class="c1">#plot=True)</span>

            <span class="n">result_wlosvd_msres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fit_iteration</span><span class="p">(</span><span class="n">model_wlosvd_msres</span><span class="p">,</span> <span class="n">model_ferr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                                          <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span><span class="p">,</span> <span class="n">model_template</span><span class="p">,</span>
                                                          <span class="n">model_template_rfft</span><span class="p">,</span> <span class="n">guess_kin</span><span class="p">,</span>
                                                          <span class="n">obj_to_fit</span><span class="o">=</span><span class="n">_obj_to_fit</span><span class="p">,</span>
                                                          <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">model_tpl_to_use</span><span class="p">)</span><span class="c1">#,</span>
                                                          <span class="c1">#plot=True)</span>

<span class="c1">#            print(res_match_offset)</span>
<span class="c1">#            print([ s.kin[1] for s in result_wlosvd])</span>
<span class="c1">#            print([ s.kin[1] for s in result_wlosvd_msres])</span>

            <span class="n">dispersion_correction_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">rcl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rcl</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">()</span>
                                                        <span class="ow">or</span> <span class="n">rcl</span><span class="o">.</span><span class="n">reached_maxiter</span><span class="p">()</span>
                                                    <span class="ow">or</span> <span class="n">rcls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rcls</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">()</span>
                                                        <span class="ow">or</span> <span class="n">rcls</span><span class="o">.</span><span class="n">reached_maxiter</span><span class="p">()</span> 
                                        <span class="k">for</span> <span class="n">rcl</span><span class="p">,</span> <span class="n">rcls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result_wlosvd</span><span class="p">,</span> <span class="n">result_wlosvd_msres</span><span class="p">)</span> <span class="p">])</span>
            <span class="n">dispersion_correction_err</span> <span class="o">&amp;=</span> <span class="n">_obj_to_fit</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">dispersion_correction_err</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_obj_to_fit</span>

            <span class="n">disp_wlosvd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">disp_wlosvd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">rc</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">rc</span> <span class="ow">in</span> <span class="n">result_wlosvd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="p">])</span>

            <span class="n">disp_wlosvd_msres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">disp_wlosvd_msres</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigoff</span><span class="p">)</span> 
                                            <span class="k">for</span> <span class="n">rc</span><span class="p">,</span> <span class="n">sigoff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result_wlosvd_msres</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                                                  <span class="n">res_match_offset</span><span class="p">[</span><span class="n">indx</span><span class="p">])])</span>
            <span class="n">disp_wlosvd_msres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">disp_wlosvd_msres</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

<span class="c1">#            print(disp_wlosvd)</span>
<span class="c1">#            print(disp_wlosvd_msres)</span>

<span class="c1">#            pyplot.scatter(disp_wlosvd[indx], disp_wlosvd_msres[indx], marker=&#39;.&#39;, s=30, color=&#39;k&#39;)</span>
<span class="c1">#            pyplot.plot([0,300], [0,300], color=&#39;C3&#39;)</span>
<span class="c1">#            pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#            pyplot.scatter(disp_wlosvd_msres[indx],</span>
<span class="c1">#                           numpy.ma.sqrt(numpy.square(disp_wlosvd_msres[indx])</span>
<span class="c1">#                                            -numpy.square(disp_wlosvd[indx])).filled(0.0),</span>
<span class="c1">#                           marker=&#39;.&#39;, s=30, color=&#39;C0&#39;)</span>
<span class="c1">#            pyplot.scatter(disp_wlosvd_msres[indx],</span>
<span class="c1">#                           numpy.ma.sqrt(numpy.square(disp_wlosvd_msres[indx])</span>
<span class="c1">#                                            -numpy.square(nominal_dispersion[indx])).filled(0.0),</span>
<span class="c1">#                           marker=&#39;.&#39;, s=30, color=&#39;C1&#39;)</span>
<span class="c1">#            pyplot.show()</span>

            <span class="n">dispersion_correction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dispersion_correction</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">disp_wlosvd_msres</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
                                            <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">disp_wlosvd</span><span class="p">[</span><span class="n">indx</span><span class="p">]))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> 
<span class="c1">#            print(dispersion_correction)</span>

            <span class="c1"># TODO: The looping and this update should probably be</span>
            <span class="c1"># removed</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">niter</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
                                            <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dispersion_correction</span><span class="p">[</span><span class="n">indx</span><span class="p">]))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                               <span class="s1">&#39;Dispersion corrections larger than measurement: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dispersion_correction</span> <span class="o">&gt;</span> <span class="n">nominal_dispersion</span><span class="p">)))</span>
                <span class="n">nominal_dispersion</span><span class="p">[</span><span class="n">dispersion_correction</span> <span class="o">&gt;</span> <span class="n">nominal_dispersion</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Mean dispersion correction: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                            <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dispersion_correction</span><span class="p">[</span><span class="n">indx</span><span class="p">])))</span>

<span class="c1">#        dispersion_correction_err = numpy.array([ rc is None or rc.fit_failed()</span>
<span class="c1">#                                                    or rc.reached_maxiter() for rc in result_corr ])</span>
<span class="c1">#        indx = numpy.invert(dispersion_correction_err)</span>
<span class="c1">#        dispersion_correction = numpy.zeros(self.nobj, dtype=float)</span>
<span class="c1">#        dispersion_correction[indx] = numpy.array([ numpy.square(rc.kin[1]) - numpy.square(sigoff) </span>
<span class="c1">#                                for rc, sigoff in zip(result_corr[indx], res_match_offset[indx]) ])</span>
<span class="c1">#        dispersion_correction = numpy.ma.sqrt(dispersion_correction).filled(0.0)</span>

<span class="c1">#        print(&#39;successful fits: {0}/{1}&#39;.format(numpy.sum(indx), numpy.sum(self.obj_to_fit)))</span>
<span class="c1">#        pyplot.scatter(nominal_dispersion[indx], dispersion_correction[indx], marker=&#39;.&#39;, s=30)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="k">return</span> <span class="n">dispersion_correction</span><span class="p">,</span> <span class="n">dispersion_correction_err</span></div>


<div class="viewcode-block" id="PPXFFit._nominal_dispersion_correction"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._nominal_dispersion_correction">[docs]</a>    <span class="k">def</span> <span class="nf">_nominal_dispersion_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_sres</span><span class="p">,</span> <span class="n">gpm</span><span class="p">,</span> <span class="n">cz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the dispersion corrections as the quadrature</span>
<span class="sd">        difference between the spectral resolution of the template and</span>
<span class="sd">        object spectra.  Returns a masked array!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">fwhm_inst_obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">obj_sres</span><span class="p">[</span><span class="n">gpm</span><span class="p">]</span>
        <span class="n">fwhm_inst_tpl</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_sres</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">gpm</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">cz</span><span class="o">/</span><span class="n">c</span><span class="p">))</span>
        <span class="n">mean_fwhm_sqr_diff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fwhm_inst_obj</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fwhm_inst_tpl</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mean_fwhm_sqr_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_fwhm_sqr_diff</span><span class="p">)</span><span class="o">/</span><span class="n">DAPConstants</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="p">,</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="PPXFFit._is_near_bounds"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._is_near_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">_is_near_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">guess_velocity</span><span class="p">,</span> <span class="n">tol_frac</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the fitted kinematics are near the imposed limits.</span>
<span class="sd">        </span>
<span class="sd">        The definition of &quot;near&quot; is that the velocity and higher moments</span>
<span class="sd">        cannot be closer than the provided fraction of the total width</span>
<span class="sd">        to the boundary.  For the velocity dispersion, the fraction is</span>
<span class="sd">        done in log space.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">near_bounds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">near_lower_sigma_bound</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Velocity</span>
        <span class="n">_velocity_limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span> <span class="o">+</span> <span class="n">guess_velocity</span>
        <span class="n">Dv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_velocity_limits</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">Dv</span><span class="o">*</span><span class="n">tol_frac</span>

        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">_velocity_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span> \
                            <span class="ow">or</span> <span class="n">_velocity_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="c1"># Velocity dispersion</span>
        <span class="n">Ds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">Ds</span><span class="o">*</span><span class="n">tol_frac</span>

        <span class="n">near_lower_sigma_bound</span> \
                <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">near_lower_sigma_bound</span> \
                        <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">near_bounds</span><span class="p">,</span> <span class="n">near_lower_sigma_bound</span>

        <span class="c1"># H3 and H4</span>
        <span class="n">Dh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">Dh</span><span class="o">*</span><span class="n">tol_frac</span>
        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span> \
                                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span> \
                                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">near_bounds</span><span class="p">,</span> <span class="n">near_lower_sigma_bound</span>

        <span class="c1"># H5 and H6</span>
        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span> \
                                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">near_bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span> \
                                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">kin</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tol</span>

        <span class="k">return</span> <span class="n">near_bounds</span><span class="p">,</span> <span class="n">near_lower_sigma_bound</span></div>


<span class="c1">#    def _set_and_report_failed_status(self, model_mask, model_par, message):</span>
<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 1, logging.INFO, message)</span>
<span class="c1">#        return self.bitmask.turn_on(model_mask, &#39;FIT_FAILED&#39;), \</span>
<span class="c1">#               self.bitmask.turn_on(model_par, &#39;FIT_FAILED&#39;)</span>


<div class="viewcode-block" id="PPXFFit._validate_kinematics"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._validate_kinematics">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the returned kinematics.</span>

<span class="sd">        Checks:</span>
<span class="sd">            - corrected velocity dispersion must be in the range 50-400</span>
<span class="sd">              km/s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigcor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR_EMP&#39;</span><span class="p">])</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">((</span><span class="n">sigcor</span> <span class="o">&lt;</span> <span class="mf">2500.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">sigcor</span> <span class="o">&gt;</span> <span class="mf">1.6e5</span><span class="p">))</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">,:],</span> <span class="s1">&#39;BAD_SIGMA&#39;</span><span class="p">)</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">indx</span><span class="p">],</span> <span class="s1">&#39;BAD_SIGMA&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PPXFFit._save_results"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit._save_results">[docs]</a>    <span class="k">def</span> <span class="nf">_save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_fit_result</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span><span class="p">):</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the model spectra</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">compile_model_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="c1"># Calculate the model residuals.  They still need to be masked</span>
        <span class="c1"># in regions that were *not* included in the fit; see the</span>
        <span class="c1"># iterations below</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span> <span class="o">-</span> <span class="n">model_flux</span>
        <span class="n">fractional_residual</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span> <span class="o">-</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">)</span>

        <span class="c1"># Instantiate a bad pixel mask to be used</span>
        <span class="n">bpm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Flag the pixels that were not used</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">)]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">)],</span>
                                               <span class="n">flag</span><span class="o">=</span><span class="s1">&#39;DIDNOTUSE&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Need to iterate over each spectrum</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">):</span>

            <span class="c1">#-----------------------------------------------------------</span>
            <span class="c1"># Set output flags</span>
            <span class="c1"># No fit was performed</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># No fit attempted because of insufficient data</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">empty_fit</span><span class="p">():</span>
                <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                                            <span class="s1">&#39;INSUFFICIENT_DATA&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Fit attempted but failed</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>

            <span class="c1"># Fit successful but hit maximum iterations.</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reached_maxiter</span><span class="p">():</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;MAXITER&#39;</span><span class="p">)</span>

            <span class="c1"># Test if the kinematics are near the imposed boundaries.</span>
            <span class="c1"># The best fitting model is still provided, but masked.</span>
            <span class="n">near_bound</span><span class="p">,</span> <span class="n">near_lower_sigma_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_near_bounds</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                      <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If the velocity dispersion has hit the lower limit, ONLY</span>
            <span class="c1"># flag the value as having a MIN_SIGMA.</span>
            <span class="k">if</span> <span class="n">near_lower_sigma_bound</span><span class="p">:</span>
                <span class="n">near_bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;MIN_SIGMA&#39;</span><span class="p">)</span>
            <span class="c1"># Otherwise, flag both the model and parameter set</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">near_bound</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Returned parameters for spectrum </span><span class="si">{0}</span><span class="s1"> too close to &#39;</span>
                                  <span class="s1">&#39;bounds.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>
                <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="s1">&#39;NEAR_BOUND&#39;</span><span class="p">)</span>

            <span class="c1"># Mask rejected pixels</span>
            <span class="n">original_gpm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                                                      <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">[</span><span class="n">i</span><span class="p">]]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rejected_pixels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">original_gpm</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rejected_pixels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">rejected_pixels</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">rejected_pixels</span><span class="p">],</span>
                                               <span class="n">flag</span><span class="o">=</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">rej_flag</span><span class="p">)</span>

            <span class="c1">#-----------------------------------------------------------</span>
            <span class="c1"># Save the model parameters and figures of merit</span>

            <span class="c1"># Number of fitted pixels</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">)</span>
            <span class="c1"># Template weights and errors</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_global_template</span><span class="p">():</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">global_fit_result</span><span class="o">.</span><span class="n">tplwgt</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgterr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGTERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgterr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">global_fit_result</span><span class="o">.</span><span class="n">tplwgt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgt</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgterr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGTERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tplwgterr</span>
            <span class="c1"># Templates used</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;USETPL&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tpl_to_use</span>
            <span class="c1"># Additive polynomial coefficients</span>
            <span class="c1"># TODO: Save nominal polynomial errors as well?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">addcoef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">addcoef</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">multcoef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">multcoef</span>
            <span class="c1"># Input kinematics</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="c1"># Best-fit kinematics</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kin</span>
            <span class="c1"># Kinematic errors</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">kinerr</span>

            <span class="c1"># Mask the residuals according to the pixel fit for this</span>
            <span class="c1"># spectrum</span>
            <span class="n">bpm</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">bpm</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">bpm</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">fractional_residual</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">bpm</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

            <span class="c1"># Get the chi-square and rms metrics</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">residual</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                                    <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;RMS&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">residual</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                                    <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;FRMS&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fractional_residual</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                            <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fractional_residual</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>

            <span class="c1"># Chi-square</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;RCHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;CHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> \
                                        <span class="o">/</span> <span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;NPIXFIT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> 
                                            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ROBUST_RCHI2&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">robust_rchi2</span>

            <span class="c1"># Get growth statistics for the residuals</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ABSRESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span>
                                                     <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.68</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;FABSRESID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_growth</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fractional_residual</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span>
                                                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.68</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

            <span class="c1"># Calculate the dispersion correction if necessary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span><span class="p">:</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR_SRES&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">err</span> \
                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nominal_dispersion_correction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span><span class="p">,</span>
                                        <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                                                <span class="s1">&#39;BAD_SIGMACORR_SRES&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Calculate the dispersion corrections, if necessary</span>
        <span class="c1"># TODO: Get the velocity dispersion corrections here and above</span>
        <span class="c1"># regardless of the resolution matching?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span><span class="p">:</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR_EMP&#39;</span><span class="p">],</span> <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_dispersion_correction</span><span class="p">(</span>
                                                            <span class="n">result</span><span class="p">,</span> <span class="n">baseline_dispersion</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">err</span><span class="p">],</span>
                                                              <span class="s1">&#39;BAD_SIGMACORR_EMP&#39;</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Test if kinematics are reliable</span>
        <span class="c1"># TODO: Skipped for now because unreliable flag not well defined</span>
<span class="c1">#        self._validate_kinematics(model_mask, model_par)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Convert the velocities from pixel units to redshift</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KININP&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span>
                                                               <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">))</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">convert_velocity</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">#        indx = numpy.invert(self.bitmask.flagged(model_par[&#39;MASK&#39;],</span>
<span class="c1">#                            flag=[&#39;NO_FIT&#39;, &#39;INSUFFICIENT_DATA&#39;, &#39;FIT_FAILED&#39;]))</span>
<span class="c1">#        pyplot.scatter(model_par[&#39;SIGMACORR_SRES&#39;][indx], model_par[&#39;SIGMACORR_EMP&#39;][indx],</span>
<span class="c1">#                       marker=&#39;.&#39;, s=50)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span></div>


<div class="viewcode-block" id="PPXFFit.fit_SpatiallyBinnedSpectra"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.fit_SpatiallyBinnedSpectra">[docs]</a>    <span class="k">def</span> <span class="nf">fit_SpatiallyBinnedSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binned_spectra</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This is a basic interface that is geared for the DAP that</span>
<span class="sd">        interacts with the rest of the, more general, parts of the</span>
<span class="sd">        class.</span>

<span class="sd">        This should not declare anything to self!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parameter must be provided</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Required parameters for PPXFFit have not been defined.&#39;</span><span class="p">)</span>
        <span class="c1"># Check the parameters</span>
        <span class="n">_def</span> <span class="o">=</span> <span class="n">PPXFFitPar</span><span class="o">.</span><span class="n">_keyword_defaults</span><span class="p">()</span>
<span class="c1">#        if par[&#39;regul&#39;] != _def[&#39;regul&#39;] or par[&#39;reddening&#39;] != _def[&#39;reddening&#39;] \</span>
<span class="c1">#                or par[&#39;component&#39;] != _def[&#39;component&#39;] or par[&#39;reg_dim&#39;] != _def[&#39;reg_dim&#39;]:</span>
<span class="c1">#            raise NotImplementedError(&#39;Cannot use regul, reddening, component, or regul_dim yet.&#39;)</span>

        <span class="c1"># SpatiallyBinnedSpectra object always needed</span>
        <span class="k">if</span> <span class="n">binned_spectra</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binned_spectra</span><span class="p">,</span> <span class="n">SpatiallyBinnedSpectra</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a SpatiallyBinnedSpectra object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided SpatiallyBinnedSpectra object is undefined!&#39;</span><span class="p">)</span>
        <span class="c1"># If specified, the binned_spectra should have spectral</span>
        <span class="c1"># resolution measurements based on a pre-pixelized Gaussian</span>
        <span class="k">if</span> <span class="s1">&#39;STCKPRE&#39;</span> <span class="ow">in</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;PRIMARY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;STCKPRE&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;PPXFFit expects LSF measurements based on a pre-pixelized Gaussian.&#39;</span><span class="p">)</span>

        <span class="c1"># TemplateLibrary object always needed</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> \
                <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">],</span> <span class="n">TemplateLibrary</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must provide a TemplateLibrary object for fitting.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided TemplateLibrary object is undefined!&#39;</span><span class="p">)</span>

        <span class="c1"># Select the spectra that meet the selection criteria</span>
        <span class="c1"># TODO: Link this to the StellarContinuumModel._bins_to_fit()</span>
        <span class="c1"># function...</span>
        <span class="n">good_spec</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">above_snr_limit</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;minimum_snr&#39;</span><span class="p">])</span>

        <span class="c1"># Get the object data</span>
        <span class="n">obj_wave</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj_flux</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">do_not_fit_flags</span><span class="p">())</span>
        <span class="n">obj_ferr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">,</span>
                                                    <span class="n">flag</span><span class="o">=</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">do_not_fit_flags</span><span class="p">())</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">obj_sres</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">)</span>

        <span class="c1"># Warn the user that only a single spectral resolution is used</span>
        <span class="c1"># for the templates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Adopting mean spectral resolution of all templates!&#39;</span><span class="p">)</span>
        <span class="n">tpl_sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">][</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Perform the fit</span>
        <span class="c1"># TODO: Alias window is never used...</span>
        <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">][</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                           <span class="n">par</span><span class="p">[</span><span class="s1">&#39;template_library&#39;</span><span class="p">][</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                           <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">obj_flux</span><span class="p">[</span><span class="n">good_spec</span><span class="p">,:],</span>
                           <span class="n">obj_ferr</span><span class="p">[</span><span class="n">good_spec</span><span class="p">,:],</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_redshift&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">],</span>
                           <span class="n">par</span><span class="p">[</span><span class="s1">&#39;guess_dispersion&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">],</span> <span class="n">iteration_mode</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;iteration_mode&#39;</span><span class="p">],</span>
                           <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;reject_boxcar&#39;</span><span class="p">],</span> <span class="n">filter_boxcar</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;filter_boxcar&#39;</span><span class="p">],</span>
                           <span class="n">filter_operation</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;filter_operation&#39;</span><span class="p">],</span>
                           <span class="n">filter_iterations</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;filter_iterations&#39;</span><span class="p">],</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;velscale_ratio&#39;</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">],</span>
                           <span class="n">matched_resolution</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;match_resolution&#39;</span><span class="p">],</span>
                           <span class="n">tpl_sres</span><span class="o">=</span><span class="n">tpl_sres</span><span class="p">,</span> <span class="n">obj_sres</span><span class="o">=</span><span class="n">obj_sres</span><span class="p">[</span><span class="n">good_spec</span><span class="p">,:],</span>
                           <span class="n">waverange</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;pixelmask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">waverange</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;bias&#39;</span><span class="p">],</span>
                           <span class="n">degree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;degree&#39;</span><span class="p">],</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;mdegree&#39;</span><span class="p">],</span>
                           <span class="n">filt_degree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;filt_degree&#39;</span><span class="p">],</span> <span class="n">filt_mdegree</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;filt_mdegree&#39;</span><span class="p">],</span>
                           <span class="n">moments</span><span class="o">=</span><span class="n">par</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">],</span> <span class="n">loggers</span><span class="o">=</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span>
                           <span class="c1">#plot=True)</span>

        <span class="c1"># DEBUG</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">model_wave</span> <span class="o">-</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
                    <span class="s1">&#39;Incorrect wavelength range&#39;</span>

        <span class="c1"># Save the the bin ID numbers indices based on the spectra</span>
        <span class="c1"># selected to be fit</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binned_spectra</span><span class="p">[</span><span class="s1">&#39;BINS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">][</span><span class="n">good_spec</span><span class="p">]</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">binned_spectra</span><span class="o">.</span><span class="n">nbins</span><span class="p">)[</span><span class="n">good_spec</span><span class="p">]</span>

        <span class="c1"># Only return model and model parameters for the *fitted*</span>
        <span class="c1"># spectra</span>
        <span class="k">return</span> <span class="n">model_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span></div>

    
<div class="viewcode-block" id="PPXFFit.fit"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span>
            <span class="n">guess_dispersion</span><span class="p">,</span> <span class="n">iteration_mode</span><span class="o">=</span><span class="s1">&#39;global_template&#39;</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
            <span class="n">filter_boxcar</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">filter_operation</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="n">filter_iterations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usetpl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">matched_resolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tpl_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">obj_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filt_degree</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">filt_mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_velocity_range</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span>
            <span class="n">alias_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file_root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for pPXF with some additional convenience functions.</span>
<span class="sd">        Limited implementation at the moment.</span>

<span class="sd">        Args:</span>
<span class="sd">            tpl_wave (numpy.ndarray): 1D vector of template wavelengths</span>
<span class="sd">                at rest in angstroms.</span>
<span class="sd">            tpl_flux (numpy.ndarray): N-templates x N-wavelengths array</span>
<span class="sd">                of template spectra to fit.</span>
<span class="sd">            obj_wave (numpy.ndarray): 1D vector of object wavelengths in</span>
<span class="sd">                angstroms.  Does NOT need to be same as the template</span>
<span class="sd">                wavelengths.</span>
<span class="sd">            obj_flux (numpy.ndarray): N-spec x N-wavelengths array of</span>
<span class="sd">                object spectra to fit.  Can be a numpy.ma.MaskedArray.</span>
<span class="sd">            obj_ferr (numpy.ndarray): N-spec x N-wavelengths array</span>
<span class="sd">                with the errors in the object spectra.</span>
<span class="sd">            guess_redshift (float or numpy.ndarray): Single or</span>
<span class="sd">                spectrum-specific redshift used to set the initial guess</span>
<span class="sd">                kinematics.</span>
<span class="sd">            guess_dispersion (float or numpy.ndarray): Single or</span>
<span class="sd">                spectrum-specific velocity dispersion used to set the</span>
<span class="sd">                initial guess kinematics.</span>
<span class="sd">            iteration_mode (str): (**Optional**) Iteration sequence to</span>
<span class="sd">                perform.  See :func:`iteration_modes`.</span>
<span class="sd">            reject_boxcar (int): (**Optional**) Size of the boxcar to</span>
<span class="sd">                use during the rejection iteration.  Default is 100.  If</span>
<span class="sd">                None, rejection uses the entire residual spectrum.</span>
<span class="sd">            filter_boxcar (int): (**Optional**) Size of the boxcar to</span>
<span class="sd">                use when filtering the spectra.  Default is 100.  Cannot</span>
<span class="sd">                be None.</span>
<span class="sd">            filter_iterations (int): (**Optional**) Number of filtering</span>
<span class="sd">                iterations for the &#39;fit_reject_filter&#39; iteration mode.</span>
<span class="sd">            ensemble (bool): (**Optional**) Treat the list of input</span>
<span class="sd">                spectra as an ensemble.  Currently, this only affects</span>
<span class="sd">                how the spectra are masked.  Default is to treat them as</span>
<span class="sd">                an ensemble.  When not treated as an ensemble, each</span>
<span class="sd">                spectrum is masked individually according to the input</span>
<span class="sd">                wavelength range and velocity offsets.  *It does not</span>
<span class="sd">                make sense to set the iteration_mode to something that</span>
<span class="sd">                will include a fit to the global spectrum if you&#39;re not</span>
<span class="sd">                treating the list of object spectra as an ensemble.*</span>
<span class="sd">            velscale_ratio (int): (**Optional**) Ratio of velocity scale</span>
<span class="sd">                per pixel in the object spectra to that for the template</span>
<span class="sd">                spectra.  Default is that they should be identical.</span>
<span class="sd">            mask (numpy.ndarray,</span>
<span class="sd">                :class:`mangadap.util.pixelmask.SpectralPixelMask):</span>
<span class="sd">                (**Optional**) A baseline pixel mask to use during the</span>
<span class="sd">                fitting.  Other pixels may be masked via the convenience</span>
<span class="sd">                functions, but these pixels will always be masked.</span>
<span class="sd">            matched_resolution (bool): (**Optional**)  Flag that the</span>
<span class="sd">                object and template spectra have identical spectral</span>
<span class="sd">                resolution.  Default is True.</span>
<span class="sd">            tpl_sres (numpy.ndarray): (**Optional**) One-dimensional</span>
<span class="sd">                vector with the spectral resolution (:math:`R =</span>
<span class="sd">                \lambda/\Delta\lambda`) at each wavelength of the</span>
<span class="sd">                template spectra.  Default is the resolution is not</span>
<span class="sd">                provided and assumed to be same as the object</span>
<span class="sd">                resolution.</span>
<span class="sd">            obj_sres (numpy.ndarray): (**Optional**) One- or Two-dimensional</span>
<span class="sd">                array with the spectral resolution (:math:`R =</span>
<span class="sd">                \lambda/\Delta\lambda`) at each wavelength for (each of)</span>
<span class="sd">                the object spectra.  Default is the resolution is not</span>
<span class="sd">                provided and assumed to be same as the template</span>
<span class="sd">                resolution.</span>
<span class="sd">            waverange (array-like): (**Optional**) Lower and upper</span>
<span class="sd">                wavelength limits to *include* in the fit.  This can be</span>
<span class="sd">                a two-element vector to apply the same limits to all</span>
<span class="sd">                spectra, or a N-spec x 2 array with wavelength ranges</span>
<span class="sd">                for each spectrum to be fit.  Default is to use as much</span>
<span class="sd">                of the spectrum as possible.</span>
<span class="sd">            bias (float): (**Optional**) Defaults to 0.0. From the pPXF</span>
<span class="sd">                documentation: This parameter biases the (h3, h4, ...)</span>
<span class="sd">                measurements towards zero (Gaussian LOSVD) unless their</span>
<span class="sd">                inclusion significantly decreases the error in the fit.</span>
<span class="sd">                Set this to BIAS=0.0 not to bias the fit: the solution</span>
<span class="sd">                (including [V, sigma]) will be noisier in that case. The</span>
<span class="sd">                default BIAS should provide acceptable results in most</span>
<span class="sd">                cases, but it would be safe to test it with Monte Carlo</span>
<span class="sd">                simulations. This keyword precisely corresponds to the</span>
<span class="sd">                parameter \lambda in the Cappellari &amp; Emsellem (2004)</span>
<span class="sd">                paper. Note that the penalty depends on the *relative*</span>
<span class="sd">                change of the fit residuals, so it is insensitive to</span>
<span class="sd">                proper scaling of the NOISE vector. A nonzero BIAS can</span>
<span class="sd">                be safely used even without a reliable NOISE spectrum,</span>
<span class="sd">                or with equal weighting for all pixels.</span>
<span class="sd">            degree (int): (**Optional**) Default is 4.  From the pPXF</span>
<span class="sd">                documentation: degree of the *additive* Legendre</span>
<span class="sd">                polynomial used to correct the template continuum shape</span>
<span class="sd">                during the fit (default: 4).  Set DEGREE = -1 not to</span>
<span class="sd">                include any additive polynomial.</span>
<span class="sd">            mdegree (int): (**Optional**) Default is 0.  From the pPXF</span>
<span class="sd">                documentation: degree of the *multiplicative* Legendre</span>
<span class="sd">                polynomial (with mean of 1) used to correct the</span>
<span class="sd">                continuum shape during the fit (default: 0). The zero</span>
<span class="sd">                degree multiplicative polynomial is always included in</span>
<span class="sd">                the fit as it corresponds to the weights assigned to the</span>
<span class="sd">                templates.  Note that the computation time is longer</span>
<span class="sd">                with multiplicative polynomials than with the same</span>
<span class="sd">                number of additive polynomials.</span>

<span class="sd">                .. note::</span>
<span class="sd">                </span>
<span class="sd">                    **IMPORTANT**: Multiplicative polynomials cannot be</span>
<span class="sd">                    used when the REDDENING keyword is set.</span>

<span class="sd">            filt_degree (int): (**Optional**) The order of the additive</span>
<span class="sd">                polynomial to use when fitting the filtered spectra.</span>
<span class="sd">            filt_mdegree (int): (**Optional**) The order of the</span>
<span class="sd">                multiplicative polynomial to use when fitting the</span>
<span class="sd">                filtered spectra.</span>
<span class="sd">            moments (int): (**Optional**) Default is 2.  From the pPXF</span>
<span class="sd">                documentation: Order of the Gauss-Hermite moments to</span>
<span class="sd">                fit. Set this keyword to 4 to fit [h3, h4] and to 6 to</span>
<span class="sd">                fit [h3, h4, h5, h6]. Note that in all cases the G-H</span>
<span class="sd">                moments are fitted (non-linearly) *together* with [V,</span>
<span class="sd">                sigma].</span>

<span class="sd">                    - If MOMENTS=2 or MOMENTS is not set then only [V,</span>
<span class="sd">                      sigma] are fitted and the other parameters are</span>
<span class="sd">                      returned as zero.</span>
<span class="sd">                    - If MOMENTS is negative then the kinematics of the</span>
<span class="sd">                      given COMPONENT are kept fixed to the input</span>
<span class="sd">                      values.</span>
<span class="sd">                    - EXAMPLE: We want to keep fixed component 0, which</span>
<span class="sd">                      has an LOSVD described by [V, sigma, h3, h4] and</span>
<span class="sd">                      is modelled with 100 spectral templates; At the</span>
<span class="sd">                      same time we fit [V, sigma] for COMPONENT=1, which</span>
<span class="sd">                      is described by 5 templates (this situation may</span>
<span class="sd">                      arise when fitting stellar templates with</span>
<span class="sd">                      pre-determined stellar kinematics, while fitting</span>
<span class="sd">                      the gas emission).  We should give in input to</span>
<span class="sd">                      ppxf() the following parameters: component =</span>
<span class="sd">                      [0]*100 + [1]*5   # --&gt; [0, 0, ..., 0, 1, 1, 1, 1,</span>
<span class="sd">                      1] moments = [-4, 2] start = [[V, sigma, h3, h4],</span>
<span class="sd">                      [V, sigma]]</span>

<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_ objects</span>
<span class="sd">                to log progress; ignored if quiet=True.  Logging is done</span>
<span class="sd">                using :func:`mangadap.util.log.log_output`.  Default is</span>
<span class="sd">                no logging.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.  Default is False.</span>
<span class="sd">            max_velocity_range (float): (**Optional**) Maximum range</span>
<span class="sd">                (+/-) expected for the fitted velocities in km/s.</span>
<span class="sd">                Default is 400 km/s.</span>
<span class="sd">            alias_window (float) : (**Optional**) The window to mask to</span>
<span class="sd">                avoid aliasing near the edges of the spectral range in</span>
<span class="sd">                km/s.  Default is six times *max_velocity_range*.</span>
<span class="sd">            dvtol (float): (**Optional**) The velocity scale of the</span>
<span class="sd">                template spectra and object spectrum must be smaller</span>
<span class="sd">                than this tolerance.  Default is 1e-10.</span>
<span class="sd">            plot (bool): (**Optional**) Show the automatically generated</span>
<span class="sd">                pPXF fit plots.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Returns 4 objects:</span>

<span class="sd">                1. The wavelengths of the best fitting model spectra.</span>
<span class="sd">                Nominally the same as the wavelengths of the input</span>
<span class="sd">                object spectra (*obj_wave*).</span>

<span class="sd">                2. The fluxes of the best-fitting model spectra.</span>

<span class="sd">                3. A mask for the best-fitting models spectra, following</span>
<span class="sd">                from the internal bitmask.</span>

<span class="sd">                4. A record array with the fitted model parameters; see</span>
<span class="sd">                :class:`spectralfitting.StellarKinematicsFit._per_stellar_kinematics_dtype`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the input arrays are not of the</span>
<span class="sd">                correct shape or if the pixel scale of the template and</span>
<span class="sd">                object spectra is greater than the specified tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the reporting</span>
        <span class="k">if</span> <span class="n">loggers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loggers</span> <span class="o">=</span> <span class="n">loggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="n">quiet</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Check the input; the following operations are necessarily</span>
        <span class="c1"># sequential in some cases because of attributes assigned along</span>
        <span class="c1"># the way</span>

        <span class="c1"># - Mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mode</span><span class="p">(</span><span class="n">iteration_mode</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="p">,</span> <span class="n">filter_boxcar</span><span class="p">,</span> <span class="n">filter_operation</span><span class="p">,</span>
                         <span class="n">filter_iterations</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">)</span>
        <span class="c1"># - Objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="o">=</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="n">obj_sres</span><span class="o">=</span><span class="n">obj_sres</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_obj_mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#        print(&#39;Objects to fit: {0}/{1}&#39;.format(numpy.sum(self.obj_to_fit), self.nobj))</span>

        <span class="c1"># - Input pixel scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_pixel_scale</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span>
                                            <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">)</span>
        <span class="c1"># - Templates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sres</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_templates</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span> <span class="n">tpl_sres</span><span class="o">=</span><span class="n">tpl_sres</span><span class="p">,</span>
                                          <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix_tpl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># - Template usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usetpl</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_template_usage_flags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> <span class="n">usetpl</span><span class="p">)</span>
        <span class="c1"># - Input kinematics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_kin</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_input_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="n">guess_redshift</span><span class="p">,</span>
                                                                       <span class="n">guess_dispersion</span><span class="p">)</span>
        <span class="c1"># - Spectral resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matched_resolution</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_resolution_match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_sres</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_sres</span><span class="p">,</span>
                                                                 <span class="n">matched_resolution</span><span class="p">)</span>
        <span class="c1"># - Selected wavelength range: always has shape (self.nobj,2)</span>
        <span class="c1"># TODO: When is this used?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waverange</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">set_wavelength_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Make sure that any mode that fits the global spectrum treats</span>
        <span class="c1"># the individual spectra as part of an ensemble.  This step is</span>
        <span class="c1"># important for setting the spectral range and the masking that</span>
        <span class="c1"># is assumed throughout the rest of the function!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ensemble</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_global_spectrum</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;When fitting the global spectrum, the spectra MUST be treated as an &#39;</span>
                          <span class="s1">&#39;ensemble.&#39;</span><span class="p">)</span>
            <span class="n">_ensemble</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ensemble</span> <span class="o">=</span> <span class="n">ensemble</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the mask and the spectral range to fit; this was</span>
        <span class="c1"># moved here (7 June 2017) so that the filtering order could be</span>
        <span class="c1"># set below</span>
        <span class="n">model_mask</span><span class="p">,</span> <span class="n">init_pix_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">initialize_pixels_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                   <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                   <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                                   <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                   <span class="n">velocity_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_cz</span><span class="p">,</span>
                                                   <span class="n">max_velocity_range</span><span class="o">=</span><span class="n">max_velocity_range</span><span class="p">,</span>
                                                   <span class="n">alias_window</span><span class="o">=</span><span class="n">alias_window</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="n">_ensemble</span><span class="p">,</span>
                                                   <span class="n">loggers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Set the basic pPXF parameters</span>

        <span class="c1"># - Polynomials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mdegree</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If filtering, use the size of the filter and the fitted</span>
            <span class="c1"># spectral range to set an effective polynomial order used</span>
            <span class="c1"># during the initial fit in _fit_all_spectra()</span>
            <span class="n">filter_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">)</span>
                                                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">==</span> <span class="s1">&#39;divide&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">filter_order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">filter_order</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">filt_degree</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_mdegree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">filt_mdegree</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># - Kinematics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gh_limits</span> \
                    <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">losvd_limits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span> <span class="o">=</span> <span class="n">moments</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="c1"># - Degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filt_mdegree</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_degree</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filt_degree</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments</span>

<span class="c1">#        print(self.tpl_npad)</span>
<span class="c1">#        print(self.npix_tpl)</span>
<span class="c1">#        test_irfft = numpy.fft.irfft(self.tpl_rfft[0,:], self.tpl_npad)[:self.npix_tpl]</span>
<span class="c1">#        par, _moments, vj = self._fill_ppxf_par([0.0, 100.0])</span>
<span class="c1">#        test_losvd_rfft = _losvd_rfft(par, 1, _moments, self.tpl_rfft.shape[1], 1,</span>
<span class="c1">#                                        0.0, self.velscale_ratio, 0.0)[:,0,0]</span>
<span class="c1">#        print(test_losvd_rfft.shape)</span>
<span class="c1">#        print(self.tpl_rfft.shape)</span>
<span class="c1">#        print(test_irfft.shape)</span>
<span class="c1">#        print(test_losvd_rfft.shape)</span>
<span class="c1">#        test_irfft_losvd = numpy.fft.irfft(self.tpl_rfft[0,:]*test_losvd_rfft,</span>
<span class="c1">#                                            self.tpl_npad)[:self.npix_tpl]</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, self.tpl_flux[0,:])</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, test_irfft)</span>
<span class="c1">#        pyplot.plot(self.tpl_wave, test_irfft_losvd)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Report the input checks/results</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of templates: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Number of object spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                                        <span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Pixel scale: </span><span class="si">{0}</span><span class="s1"> km/s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Pixel scale ratio: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Dispersion limits: </span><span class="si">{0}</span><span class="s1"> - </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_limits</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Kinematics fixed: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">fix_kinematics</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Model degrees of freedom: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">dof</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Iteration mode: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_filter</span><span class="p">():</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Model degrees of freedom for filtered spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">filt_dof</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Filter boxcar size: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">filter_boxcar</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Filtering operation: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Effective polynomial order: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_operation</span> <span class="o">==</span> <span class="s1">&#39;subtract&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Additive polynomial order: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> 
                                                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;None&#39;</span><span class="p">))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Multiplicative polynomial order: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> 
                                                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;None&#39;</span><span class="p">))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the output data</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">model_par</span> <span class="o">=</span> <span class="n">init_record_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_per_stellar_kinematics_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ntpl</span><span class="p">,</span> 
                                            <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_filter</span><span class="p">()</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_filter</span><span class="p">()</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdegree</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">moments</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">minimum_dtype</span><span class="p">()))</span>
        <span class="c1"># Set the bins; here the ID and index are identical</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">)</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BINID_INDEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">)</span>

        <span class="c1"># Save the pixel statistics</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span>
        <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;NPIXTOT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Flag any errors in the fitted spectral range initialization</span>
        <span class="n">ended_in_error</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">init_pix_err</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Masking failures in some/all spectra.  Errors are: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">init_pix_err</span><span class="p">)])[</span><span class="n">ended_in_error</span><span class="p">]))</span>
            <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][</span><span class="n">ended_in_error</span><span class="p">],</span> <span class="s1">&#39;NO_FIT&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ended_in_error</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Get the input pixel shift between the object and template</span>
        <span class="c1"># wavelength vectors; interpretted by pPXF as a base velocity</span>
        <span class="c1"># shift between the two</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_velocity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpl_wave</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">velscale</span><span class="p">,</span>
                                                            <span class="n">velscale_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">velscale_ratio</span><span class="p">)</span>
                                                <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_start</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_end</span><span class="p">)])</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Fit the global spectrum if requested by the iteration mode</span>
        <span class="n">global_fit_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_global_spectrum</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Fitting global spectrum.&#39;</span><span class="p">)</span>
            <span class="n">global_fit_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_global_spectrum</span><span class="p">(</span><span class="n">obj_to_include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_fit</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">global_fit_result</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="c1"># pPXF failed!  </span>
                <span class="n">model_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_mask</span><span class="p">[:],</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>
                <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">turn_on</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">][:],</span> <span class="s1">&#39;FIT_FAILED&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Number of non-zero templates in fit to global spectrum: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">global_fit_result</span><span class="o">.</span><span class="n">tplwgt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Initialize the template set according to the iteration mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_global_template</span><span class="p">():</span>
            <span class="n">templates</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">global_fit_result</span><span class="o">.</span><span class="n">tplwgt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">templates_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_nonzero_templates</span><span class="p">():</span>
            <span class="n">templates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span>
            <span class="n">tpl_to_use</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">global_fit_result</span><span class="o">.</span><span class="n">tplwgt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nobj</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">usetpl</span>
            <span class="n">templates_rfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode_uses_all_templates</span><span class="p">():</span>
            <span class="n">templates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_flux</span>
            <span class="n">tpl_to_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">usetpl</span>
            <span class="n">templates_rfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_rfft</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized iteration mode: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration_mode</span><span class="p">))</span>

<span class="c1">#        #---------------------------------------------------------------</span>
<span class="c1">#        # Print heading of fitted kinematics for each bin</span>
<span class="c1">#        if not self.quiet:</span>
<span class="c1">#            log_output(self.loggers, 2, logging.INFO, &#39;{0:&gt;5}&#39;.format(&#39;INDX&#39;)</span>
<span class="c1">#                       + &#39; {:&gt;7} {:&gt;7}&#39;.format(&#39;SWAVE&#39;, &#39;EWAVE&#39;)</span>
<span class="c1">#                       + (&#39; {:&gt;9}&#39;*self.moments).format(*([&#39;KIN{0}&#39;.format(i+1)</span>
<span class="c1">#                                                                for i in range(self.moments)]))</span>
<span class="c1">#                       + &#39; {0:&gt;5} {1:&gt;9} {2:&gt;5} {3:&gt;4}&#39;.format(&#39;NZTPL&#39;, &#39;CHI2&#39;, &#39;RCHI2&#39;, &#39;STAT&#39;))</span>

        <span class="c1"># Fit all spectra</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_all_spectra</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">templates_rfft</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                                       <span class="n">plot_file_root</span><span class="o">=</span><span class="n">plot_file_root</span><span class="p">)</span>

        <span class="c1">#---------------------------------------------------------------</span>
        <span class="c1"># Save the results</span>
        <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_results</span><span class="p">(</span><span class="n">global_fit_result</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;pPXF finished&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_par</span></div>


<div class="viewcode-block" id="PPXFFit.obj_tpl_pixelmatch"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.obj_tpl_pixelmatch">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">obj_tpl_pixelmatch</span><span class="p">(</span><span class="n">velscale</span><span class="p">,</span> <span class="n">tpl_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confirm that the pixel scale of the template and object data are</span>
<span class="sd">        the same within some tolerance, accounting for and input ratio</span>
<span class="sd">        of the two.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">velscale_ratio</span>
<span class="c1">#        print(numpy.absolute(velscale - spectrum_velocity_scale(tpl_wave)*_velscale_ratio), dvtol)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">velscale</span> <span class="o">-</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">)</span><span class="o">*</span><span class="n">_velscale_ratio</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dvtol</span></div>


<div class="viewcode-block" id="PPXFFit.fitting_mask"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.fitting_mask">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fitting_mask</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">velocity_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_velocity_range</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span> <span class="n">alias_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of pixels in the object spectrum to be fit using pPXF.</span>
<span class="sd"> </span>
<span class="sd">        Be clear between velocity (ppxf) vs. redshift (cz) !</span>

<span class="sd">        The limits applied to the fitted pixels are:</span>
<span class="sd">    </span>
<span class="sd">            - Apply the provided wavelength range limit (*waverange*).</span>
<span class="sd">            - pPXF will only allow a fit when the number of template</span>
<span class="sd">              pixels is the same as or exceeds the number of pixels in</span>
<span class="sd">              the object spectrum.  The first step toward limiting</span>
<span class="sd">              template spectra that are too long is to truncate the blue</span>
<span class="sd">              and red edges that likely won&#39;t be used given the provided</span>
<span class="sd">              velocity offsets (*velocity_offset*) and the expected</span>
<span class="sd">              velocity range (*max_velocity_range*).</span>
<span class="sd">            - Remove leading and trailing pixels that will cause alias</span>
<span class="sd">              problems during the convolution with the LOSVD</span>
<span class="sd">              (*alias_window*).</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            obj_wave (array): Wavelength vector of the object spectrum to be</span>
<span class="sd">                fit.</span>
<span class="sd">            tpl_wave (array): Wavelength vector of the template library to</span>
<span class="sd">                fit to the object spectrum.</span>
<span class="sd">            velscale (float): Velocity scale of the pixel.</span>
<span class="sd">            velscale_ratio (int): (**Optional**) Ratio of the object</span>
<span class="sd">                velscale to the template velscale.  Default is 1 (i.e.</span>
<span class="sd">                the two have the same pixel scale).</span>
<span class="sd">            waverange (array): (**Optional**) Lower and upper wavelength</span>
<span class="sd">                limits to *include* in the analysis.  The array can</span>
<span class="sd">                either define a single wavelength range -- shape is (2,)</span>
<span class="sd">                -- or a set of wavelength ranges -- shape is (n,2).</span>
<span class="sd">                Default is to apply no wavelength range limitation.</span>
<span class="sd">            velocity_offset (array): (**Optional**) Vector with the</span>
<span class="sd">                velocity offset (expected or actual) between the</span>
<span class="sd">                template and the object spectrum in km/s.  Used to</span>
<span class="sd">                estimate which wavelengths can be removed from the</span>
<span class="sd">                template.  This can be a single offset or a set of</span>
<span class="sd">                offsets.  If both waverange and velocity_offset are 2D</span>
<span class="sd">                arrays, the number of wavelength ranges and offsets must</span>
<span class="sd">                be the same.  Default is that there is no velocity</span>
<span class="sd">                offset.</span>
<span class="sd">            max_velocity_range (float): (**Optional**) Maximum range</span>
<span class="sd">                (+/-) expected for the fitted velocities in km/s.</span>
<span class="sd">                Default is 400 km/s.</span>
<span class="sd">            alias_window (float) : (**Optional**) The window to mask to</span>
<span class="sd">                avoid aliasing near the edges of the spectral range in</span>
<span class="sd">                km/s.  Default is six times *max_velocity_range*.</span>
<span class="sd">            loggers (list): (**Optional**) List of `logging.Logger`_</span>
<span class="sd">                objects to log progress; ignored if quiet=True.  Logging</span>
<span class="sd">                is done using :func:`mangadap.util.log.log_output`.</span>
<span class="sd">                Default is no logging.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress all terminal and</span>
<span class="sd">                logging output.  Default is False.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Four boolean vectors are returned:</span>

<span class="sd">                - flags for pixels to include in the fit</span>
<span class="sd">                - flags for pixels that were excluded because they were</span>
<span class="sd">                  outside the designated wavelength range</span>
<span class="sd">                - flags for pixels that were excluded to ensure the</span>
<span class="sd">                  proper length of the template spectrum wrt the object</span>
<span class="sd">                  spectrum.</span>
<span class="sd">                - flags for pixels that were truncated to avoid</span>
<span class="sd">                  convolution aliasing</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if (1) no pixels are valid for the fit,</span>
<span class="sd">                (2) the template and object do not have overlapping</span>
<span class="sd">                spectral regions given the expected velocity offset</span>
<span class="sd">                between the two, or (3) the turncation to deal with</span>
<span class="sd">                aliasing removes all remaining pixels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the input</span>
        <span class="n">_velocity_offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">velocity_offset</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">velocity_offset</span><span class="p">)</span>
        <span class="n">_alias_window</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="n">max_velocity_range</span> <span class="k">if</span> <span class="n">alias_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alias_window</span>

        <span class="c1"># 1. Apply the wavelength range limit, if provided</span>
        <span class="n">now</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">)</span>                               <span class="c1"># Number of object wavelengths</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                                            <span class="s1">&#39;Original number of object pixels: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">waverange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">waverange</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fit_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">waverange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fit_indx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">obj_wave</span> <span class="o">&gt;</span> <span class="n">waverange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">waverange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fit_indx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">obj_wave</span> <span class="o">&lt;</span> <span class="n">waverange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Selected wavelength range for analysis contains no pixels!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fit_indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">waverange_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span>

        <span class="c1"># Minimum and maximum redshift about primary offsets</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">_velocity_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">max_velocity_range</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">_velocity_offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">max_velocity_range</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Minimum/Maximum redshift: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">))</span>

        <span class="c1"># 2. If the number of template pixels is not &gt;= number of fitted galaxy pixels,</span>
        <span class="c1">#    further limit the blue and red edges of the galaxy spectra.</span>
        <span class="c1">#    **This must account for the relative pixel scale.**</span>
        <span class="n">now</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span>                 <span class="c1"># Number of good object pixels</span>
        <span class="n">_velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">velscale_ratio</span>
        <span class="n">ntw</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">)</span><span class="o">//</span><span class="n">_velscale_ratio</span>       <span class="c1"># Number of template pixels</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;After selecting the wavelength range to analyze: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                <span class="s1">&#39;Number of template pixels (in units of the galaxy pixel scale): </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ntw</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ntw</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
            <span class="c1"># Indices of wavelengths redward of the redshifted template</span>
            <span class="c1"># TODO: Change this to the rigorous calculation of the pPXF</span>
            <span class="c1"># velocity: see </span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">obj_wave</span> <span class="o">&gt;</span> <span class="n">tpl_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">z_min</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No overlapping wavelengths between galaxy and template!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Initial wavelength of template: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Initial wavelength of redshifted template: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">tpl_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">z_min</span><span class="p">)))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Initial wavelength of spectrum: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Pixels blueward of redshifted template: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="nb">len</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)))</span>
            <span class="c1"># Merge with current index</span>
            <span class="n">fit_indx</span> <span class="o">&amp;=</span> <span class="n">indx</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No overlapping wavelengths between galaxy and template!&#39;</span><span class="p">)</span>
            <span class="n">now_</span><span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;After merging with the specified wavelength range: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now_</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">now_</span> <span class="o">=</span> <span class="n">now</span>
    
        <span class="c1"># New number of good object pixels</span>
        <span class="k">if</span> <span class="n">ntw</span> <span class="o">&lt;</span> <span class="n">now_</span><span class="p">:</span>
            <span class="n">fit_indx</span><span class="p">[</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">ntw</span><span class="p">:]</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>      <span class="c1"># Truncate the red edge as well</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> 
                           <span class="s1">&#39;Limit to at most the number of template pixels: </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">),</span> <span class="n">ntw</span><span class="p">))</span>
        <span class="n">npix_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">waverange_mask</span><span class="p">)</span>

        <span class="c1"># 3. Limit wavelength range to avoid aliasing problems in the template convolution</span>
        <span class="n">nalias</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">_alias_window</span><span class="o">/</span><span class="n">velscale</span><span class="p">))</span>            <span class="c1"># Number of pixels to mask</span>
        <span class="c1"># Mask to the range that should be unaffected by alias errors</span>
        <span class="n">waverange_tpl</span> <span class="o">=</span> <span class="p">[</span> <span class="n">tpl_wave</span><span class="p">[</span><span class="n">nalias</span><span class="o">*</span><span class="n">_velscale_ratio</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z_max</span><span class="p">),</span>
                          <span class="n">tpl_wave</span><span class="p">[(</span><span class="n">ntw</span><span class="o">-</span><span class="n">nalias</span><span class="p">)</span><span class="o">*</span><span class="n">_velscale_ratio</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z_min</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Mask to these wavelengths to avoid convolution aliasing: </span><span class="si">{0}</span><span class="s1"> - </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                            <span class="n">waverange_tpl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waverange_tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">obj_wave</span> <span class="o">&gt;</span> <span class="n">waverange_tpl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_wave</span> <span class="o">&lt;</span> <span class="n">waverange_tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Merge with current index</span>
        <span class="n">fit_indx</span> <span class="o">&amp;=</span> <span class="n">indx</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No wavelengths available in this range!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                       <span class="s1">&#39;Final wavelength range to fit: </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">[</span><span class="n">fit_indx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                                       <span class="n">obj_wave</span><span class="p">[</span><span class="n">fit_indx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">alias_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fit_indx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">npix_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fit_indx</span><span class="p">,</span> <span class="n">waverange_mask</span><span class="p">,</span> <span class="n">npix_mask</span><span class="p">,</span> <span class="n">alias_mask</span></div>


<div class="viewcode-block" id="PPXFFit.ppxf_tpl_obj_voff"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.ppxf_tpl_obj_voff">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the pseudo offset in velocity between the template and</span>
<span class="sd">        object spectra, just due to the difference in the starting</span>
<span class="sd">        wavelengths.</span>
<span class="sd">    </span>
<span class="sd">        This calculation is independent of the base of the logarithm used</span>
<span class="sd">        the sampling of the spectra.</span>

<span class="sd">        Assumes wavelengths are logarithmically binned.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            tpl_wave (numpy.ndarray): Wavelength vector for the template</span>
<span class="sd">                library to fit to the object spectrum.</span>
<span class="sd">            obj_wave (numpy.ndarray): Wavelength vector for the object</span>
<span class="sd">                spectrum to be fit.</span>
<span class="sd">            velscale (float): Velocity step per pixel in km/s for the</span>
<span class="sd">                **object** spectrum.</span>
<span class="sd">            velscale_ratio (int): (**Optional**) The **integer** ratio</span>
<span class="sd">                between the velocity scale of the pixel in the galaxy</span>
<span class="sd">                data to that of the template data.  This is used only</span>
<span class="sd">                when constructing the template library.  Default is</span>
<span class="sd">                None, which is the same as assuming that the velocity</span>
<span class="sd">                scales are identical.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Velocity offset in km/s between the initial wavelengths</span>
<span class="sd">            of the template and object spectra.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Implement a check that calculates the velocity ratio directly?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dlogl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> \
                    <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">velscale_ratio</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">dlogl</span><span class="o">*</span><span class="n">velscale</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="PPXFFit.check_templates"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_templates">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_templates</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span> <span class="n">tpl_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the input template data is valid for use with</span>
<span class="sd">        pPXFFit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpl_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input template wavelengths must be a vector; all spectra should &#39;</span>
                             <span class="s1">&#39;have the same wavelength solution.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tpl_flux</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Template spectra cannot be masked arrays!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The template spectra fluxes must have the same length as the &#39;</span>
                             <span class="s1">&#39;wavelength array.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tpl_sres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tpl_sres</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tpl_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided template resolution vector does not have the correct shape.&#39;</span><span class="p">)</span>

        <span class="c1"># Force the number of template pixels to be an integer number of</span>
        <span class="c1"># object pixels</span>
        <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">velscale_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">npix_tpl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">)</span> <span class="o">%</span> <span class="n">velscale_ratio</span>
            <span class="n">_tpl_wave</span> <span class="o">=</span> <span class="n">tpl_wave</span><span class="p">[:</span><span class="n">npix_tpl</span><span class="p">]</span>
            <span class="n">_tpl_flux</span> <span class="o">=</span> <span class="n">tpl_flux</span><span class="p">[:,:</span><span class="n">npix_tpl</span><span class="p">]</span>
            <span class="n">_tpl_sres</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">tpl_sres</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tpl_sres</span><span class="p">[:</span><span class="n">npix_tpl</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_tpl_wave</span> <span class="o">=</span> <span class="n">tpl_wave</span>
            <span class="n">_tpl_flux</span> <span class="o">=</span> <span class="n">tpl_flux</span>
            <span class="n">_tpl_sres</span> <span class="o">=</span> <span class="n">tpl_sres</span>

        <span class="n">_tpl_sres</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">_tpl_sres</span> <span class="ow">is</span> <span class="kc">None</span> \
                            <span class="k">else</span> <span class="n">SpectralResolution</span><span class="p">(</span><span class="n">_tpl_wave</span><span class="p">,</span> <span class="n">_tpl_sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># TODO: Allow spectral resolution to be spectrum dependent?</span>
        <span class="k">return</span> <span class="n">_tpl_wave</span><span class="p">,</span> <span class="n">_tpl_flux</span><span class="p">,</span> <span class="n">_tpl_sres</span></div>


<div class="viewcode-block" id="PPXFFit.check_objects"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_objects">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">,</span> <span class="n">obj_ferr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj_sres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the input object data is valid for use with pPXFFit.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj_wave (numpy.ndarray): 1D vector of object wavelengths in</span>
<span class="sd">                angstroms.  Does NOT need to be same as the template</span>
<span class="sd">                wavelengths.</span>
<span class="sd">            obj_flux (numpy.ndarray): :math:`N_{\rm spec}\times N_{\rm</span>
<span class="sd">                pix}` array of object spectra to fit.  Can be a</span>
<span class="sd">                numpy.ma.MaskedArray.</span>
<span class="sd">            obj_ferr (numpy.ndarray): (**Optional**) :math:`N_{\rm</span>
<span class="sd">                spec}\times N_{\rm pix}` array with the errors in the</span>
<span class="sd">                object spectra.  Can be a numpy.ma.MaskedArray.</span>
<span class="sd">            obj_sres (numpy.ndarray): (**Optional**) 1D or 2D array with</span>
<span class="sd">                the spectral resolution (:math:`R =</span>
<span class="sd">                \lambda/\Delta\lambda`) at each wavelength for (each of)</span>
<span class="sd">                the object spectra.  Default is the resolution is not</span>
<span class="sd">                provided and assumed to be same as the template</span>
<span class="sd">                resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input object wavelengths must be a vector; all spectra should &#39;</span>
                             <span class="s1">&#39;have the same wavelength solution.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The object spectra fluxes must have the same length as the &#39;</span>
                             <span class="s1">&#39;wavelength array.&#39;</span><span class="p">)</span>
        <span class="n">_obj_flux</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> \
                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_ferr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj_ferr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The shape of any provided error array must match the flux array.&#39;</span><span class="p">)</span>
        <span class="n">_obj_ferr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                                         <span class="n">mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">_obj_flux</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> \
                        <span class="k">if</span> <span class="n">obj_ferr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                            <span class="p">(</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_ferr</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> \
                                <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">obj_ferr</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">obj_sres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj_sres</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">obj_wave</span><span class="o">.</span><span class="n">shape</span> \
                <span class="ow">and</span> <span class="n">obj_sres</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided object resolution vector does not have the correct shape.&#39;</span><span class="p">)</span>
        <span class="n">_obj_sres</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">obj_sres</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">obj_sres</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_obj_sres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_obj_sres</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">_obj_sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_obj_sres</span><span class="p">]</span><span class="o">*</span><span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">_obj_flux</span><span class="p">,</span> <span class="n">_obj_ferr</span><span class="p">,</span> <span class="n">_obj_sres</span></div>


<div class="viewcode-block" id="PPXFFit.check_pixel_scale"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.check_pixel_scale">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_pixel_scale</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confirm that the pixel scale of the template and object spectra</span>
<span class="sd">        are identical within a certain tolerance, accounting for an</span>
<span class="sd">        input pixel-scale ratio.  Returns the velocity scale of the</span>
<span class="sd">        object spectra and the velocity scale ratio wrt the template</span>
<span class="sd">        spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the pixel scale</span>
        <span class="n">velscale</span> <span class="o">=</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">)</span>
        <span class="n">_velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">velscale_ratio</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">obj_tpl_pixelmatch</span><span class="p">(</span><span class="n">velscale</span><span class="p">,</span> <span class="n">tpl_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">,</span>
                                          <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Pixel scale of the object and template spectra must be identical.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">_velscale_ratio</span></div>


<div class="viewcode-block" id="PPXFFit.losvd_limits"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.losvd_limits">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">losvd_limits</span><span class="p">(</span><span class="n">velscale</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the limits on the LOSVD parameters used by pPXF.</span>

<span class="sd">            - Velocity limits are :math:`\pm 2000` km/s</span>
<span class="sd">            - Velocity-disperison limits are from 1/10 pixels to 1000 km/s</span>
<span class="sd">            - Limits of the higher orders moments are from -0.3 to 0.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">velocity_limits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">])</span>
        <span class="n">sigma_limits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.01</span><span class="o">*</span><span class="n">velscale</span><span class="p">,</span> <span class="mf">1e3</span><span class="p">])</span>
        <span class="n">gh_limits</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">velocity_limits</span><span class="p">,</span> <span class="n">sigma_limits</span><span class="p">,</span> <span class="n">gh_limits</span></div>


<div class="viewcode-block" id="PPXFFit.reject_model_outliers"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.reject_model_outliers">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reject_model_outliers</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">ppxf_result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">local_sigma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">nsigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">loggers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">boxcar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">local_sigma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For local sigma determination, must provide boxcar size.&#39;</span><span class="p">)</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">compile_model_flux</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">ppxf_result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">local_sigma</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span>
                           <span class="s1">&#39;Rejecting using local sigma (boxcar is </span><span class="si">{0}</span><span class="s1"> pixels).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">boxcar</span><span class="p">))</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">-</span><span class="n">model_flux</span> <span class="c1"># This should be masked where the data were not fit</span>
            <span class="n">bf</span> <span class="o">=</span> <span class="n">BoxcarFilter</span><span class="p">(</span><span class="n">boxcar</span><span class="p">,</span> <span class="n">lo</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span> <span class="n">hi</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">residual</span><span class="p">,</span>
                              <span class="n">local_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">obj_flux</span><span class="p">[</span><span class="n">bf</span><span class="o">.</span><span class="n">output_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="k">return</span> <span class="n">obj_flux</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">log_output</span><span class="p">(</span><span class="n">loggers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;Rejecting full spectrum outliers.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">obj_flux</span><span class="o">-</span><span class="n">model_flux</span>  <span class="c1"># This should be masked where the data were not fit</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="n">residual</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nsigma</span><span class="o">*</span><span class="n">sigma</span>
            <span class="n">old_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">obj_flux</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">))</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">old_mask</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">obj_flux</span></div>


<div class="viewcode-block" id="PPXFFit.compile_model_flux"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.compile_model_flux">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compile_model_flux</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">,</span> <span class="n">ppxf_result</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the model flux but pulling the models out of the ppxf</span>
<span class="sd">        results.  The model can be rescaled to the data based on the</span>
<span class="sd">        fitted pixels if rescale is True.</span>

<span class="sd">        The output array is masked in the spectral regions below and</span>
<span class="sd">        above the fitted wavelength range; any intervening pixels are</span>
<span class="sd">        *not* masked, even if they&#39;re not included in the fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                                          <span class="n">mask</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit_failed</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">end</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">gpm</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">optimal_scale</span><span class="p">(</span><span class="n">obj_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">][</span><span class="n">g</span><span class="p">],</span> <span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bestfit</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="k">if</span> <span class="n">rescale</span> <span class="k">else</span> <span class="mf">1.</span>
            <span class="n">model_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="o">*</span><span class="n">ppxf_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bestfit</span>
        <span class="k">return</span> <span class="n">model_flux</span></div>


<div class="viewcode-block" id="PPXFFit.convert_velocity"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.convert_velocity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_velocity</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">verr</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert kinematics from pPXF from pixel shifts to redshifts.</span>
<span class="sd">        pPXF determines the velocity offset by making the approximation</span>
<span class="sd">        that every pixel (logarithmically binned in wavelength) is a</span>
<span class="sd">        constant change in velocity.  Over large velocity shifts, this</span>
<span class="sd">        approximation can become poor.  An e-mail summary from Michele</span>
<span class="sd">        Cappellari:</span>

<span class="sd">        The velocity scale per pixel is input as</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \delta v = c \delta\ln\lambda = c (\ln\lambda_1 -</span>
<span class="sd">            \ln\lambda_0)</span>

<span class="sd">        The velocites output by pPXF are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            V = \delta V N_{\rm shift} = c \ln(\lambda_{N_{\rm</span>
<span class="sd">            shift}}/\lambda_0)</span>

<span class="sd">        which implies that the relation between PPXF output velocity and</span>
<span class="sd">        redshift is</span>

<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            1 + z = exp(V/c),</span>

<span class="sd">        which reduces z~vel/c in the low-redshift limit.  This function</span>
<span class="sd">        converts the :math:`V` values provided by pPXF to :math:`cz`</span>
<span class="sd">        velocities.</span>

<span class="sd">        .. note::</span>

<span class="sd">            **IMPORTANT**: After this conversion, you must revert the</span>
<span class="sd">            velocities back to the &quot;pixel-based velocities&quot; (using</span>
<span class="sd">            :func:`_revert_velocity`) before using the velocities to</span>
<span class="sd">            reconstruct the pPXF fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">verr</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">c</span><span class="p">))</span></div>


<div class="viewcode-block" id="PPXFFit.revert_velocity"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.revert_velocity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">revert_velocity</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">verr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Revert the velocity back to the &quot;pixelized&quot; velocity returned by</span>
<span class="sd">        pPXF.</span>

<span class="sd">        Order matters here.  The error computation is NOT a true error</span>
<span class="sd">        propagation; it&#39;s just the inverse of the &quot;convert&quot; operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="o">=</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">_v</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">c</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_v</span><span class="p">,</span> <span class="n">verr</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_v</span><span class="o">/</span><span class="n">c</span><span class="p">))</span></div>


<div class="viewcode-block" id="PPXFFit.reconstruct_model"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.reconstruct_model">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reconstruct_model</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">polyweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">mpolyweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redshift_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">sigma_corr</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">revert_velocity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a pPXF model spectrum based on a set of input spectra</span>
<span class="sd">        and parameters.</span>

<span class="sd">        **This function is outdated!  Use :func:`construct_models` or</span>
<span class="sd">        :class:`PPXFModel` instead.**</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the pixel scales match</span>
        <span class="n">_velscale_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">velscale_ratio</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">obj_tpl_pixelmatch</span><span class="p">(</span><span class="n">velscale</span><span class="p">,</span> <span class="n">tpl_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">,</span>
                                          <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Pixel scale of the object and template spectra must be identical.&#39;</span><span class="p">)</span>

        <span class="c1"># Moments for each kinematic component</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">kin</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">_moments</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">moments</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> \
                            <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span>

        <span class="c1"># Get the redshift to apply</span>
        <span class="n">redshift</span> <span class="o">=</span> <span class="n">kin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Check that the corrected sigma is defined</span>
        <span class="n">corrected_sigma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">kin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma_corr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">redshift_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">corrected_sigma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Corrected sigma is 0 or not defined.  Redshifting template only.&#39;</span><span class="p">)</span>
            <span class="n">_redshift_only</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_redshift_only</span> <span class="o">=</span> <span class="n">redshift_only</span>

        <span class="c1"># Start and end pixel in the object spectrum to fit</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span>
        <span class="n">_end</span> <span class="o">=</span> <span class="n">obj_wave</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">end</span>

        <span class="c1"># Construct the composite template</span>
        <span class="n">composite_template</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">templates</span><span class="p">)</span>

<span class="c1">#        pyplot.step(tpl_wave, composite_template, where=&#39;mid&#39;, linestyle=&#39;-&#39;, lw=0.5,</span>
<span class="c1">#                    color=&#39;k&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># Construct the output models</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_redshift_only</span><span class="p">:</span>
            <span class="c1"># Resample the redshifted template to the wavelength grid of</span>
            <span class="c1"># the binned spectra</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">Resample</span><span class="p">(</span><span class="n">composite_template</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">tpl_wave</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">redshift</span><span class="p">),</span> <span class="n">inLog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">newRange</span><span class="o">=</span><span class="n">obj_wave</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">newpix</span><span class="o">=</span><span class="n">obj_wave</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">newLog</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">outy</span>
            <span class="n">model</span><span class="p">[:</span><span class="n">_start</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">model</span><span class="p">[:</span><span class="n">_start</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="n">model</span><span class="p">[</span><span class="n">_end</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">model</span><span class="p">[</span><span class="n">_end</span><span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform the same operations as pPXF v6.0.0</span>

            <span class="c1"># Get the offset velocity just due to the difference in the</span>
            <span class="c1"># initial wavelength of the template and object data</span>
            <span class="n">vsyst</span> <span class="o">=</span> <span class="o">-</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">[</span><span class="n">_start</span><span class="p">:</span><span class="n">_end</span><span class="p">],</span> <span class="n">velscale</span><span class="p">,</span>
                                               <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">)</span>
            <span class="c1"># Account for a modulus in the number of object pixels in</span>
            <span class="c1"># the template spectra</span>
            <span class="k">if</span> <span class="n">_velscale_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">npix_tpl</span> <span class="o">=</span> <span class="n">composite_template</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">composite_template</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">_velscale_ratio</span>
                <span class="n">_composite_template</span> <span class="o">=</span> <span class="n">composite_template</span><span class="p">[:</span><span class="n">npix_tpl</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_composite_template</span> <span class="o">=</span> <span class="n">composite_template</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">npix_tpl</span> <span class="o">=</span> <span class="n">_composite_template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get the FFT of the composite template</span>
            <span class="n">npad</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="n">npix_tpl</span><span class="p">)</span>
            <span class="n">ctmp_rfft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">_composite_template</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Construct the LOSVD parameter vector</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">kin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Convert the velocity to pixel units</span>
            <span class="k">if</span> <span class="n">revert_velocity</span><span class="p">:</span>
                <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verr</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">revert_velocity</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="c1"># Convert the velocity dispersion to ignore the</span>
            <span class="c1"># resolution difference</span>
            <span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma_corr</span><span class="p">))</span>
            <span class="c1"># Convert the kinematics to pixel units</span>
            <span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">velscale</span>

            <span class="c1"># Construct the model spectrum</span>
            <span class="n">kern_rfft</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">losvd_rfft</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">ctmp_rfft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">/</span><span class="n">velscale</span><span class="p">,</span>
                                        <span class="n">_velscale_ratio</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">_model</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">ctmp_rfft</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">kern_rfft</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])[:</span><span class="n">npix_tpl</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_velscale_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_model</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_model</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">_velscale_ratio</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Copy the model to the output vector</span>
            <span class="n">model</span><span class="p">[</span><span class="n">_start</span><span class="p">:</span><span class="n">_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">_model</span><span class="p">[:</span><span class="n">_end</span><span class="o">-</span><span class="n">_start</span><span class="p">]</span>

<span class="c1">#            pyplot.plot(tpl_wave[:npix_tpl], _composite_template[0,:])</span>
<span class="c1">#            pyplot.plot(obj_wave, model)</span>
<span class="c1">#            pyplot.show()</span>

        <span class="c1"># Account for the polynomials</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_end</span><span class="o">-</span><span class="n">_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mpolyweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model</span><span class="p">[</span><span class="n">_start</span><span class="p">:</span><span class="n">_end</span><span class="p">]</span> <span class="o">*=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="n">mpolyweights</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">polyweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model</span><span class="p">[</span><span class="n">_start</span><span class="p">:</span><span class="n">_end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">polyweights</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span></div>


<div class="viewcode-block" id="PPXFFit.construct_models"><a class="viewcode-back" href="../../../mangadap.proc.ppxffit.html#mangadap.proc.ppxffit.PPXFFit.construct_models">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">construct_models</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux_shape</span><span class="p">,</span> <span class="n">model_par</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">redshift_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deredshift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">corrected_dispersion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">dvtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct models using the provided set of model parameters.</span>
<span class="sd">        This is a wrapper for :class:`PPXFModel`.</span>

<span class="sd">        Only the shape of the object data is needed, not the data</span>
<span class="sd">        itself.</span>

<span class="sd">        Allows for a replacement template library that must have the</span>
<span class="sd">        same shape as :attr:`tpl_flux`.</span>

<span class="sd">        The input velocities are expected to be cz, not &quot;ppxf&quot;</span>
<span class="sd">        (pixelized) velocities.</span>

<span class="sd">        If redshift_only is true, the provided dispersion is set to 1e-9</span>
<span class="sd">        km/s, which is numerically identical to 0 (i.e., just shifting</span>
<span class="sd">        the spectrum) in the tested applications.  However, beware that</span>
<span class="sd">        this is a HARDCODED number.</span>
<span class="sd">        </span>
<span class="sd">        .. warning::</span>
<span class="sd">            This will not work if the parameters are the result of a</span>
<span class="sd">            filtered fit! (iteration_mode = &#39;fit_reject_filter&#39;)</span>

<span class="sd">        To convolve the model to the corrected dispersion, instead of</span>
<span class="sd">        the uncorrected dispersion, set corrected_dispersion=True.</span>
<span class="sd">        Correction *always* uses SIGMACORR_EMP data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">redshift_only</span> <span class="ow">and</span> <span class="n">corrected_dispersion</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The redshift_only and corrected_dispersion are mutually exclusive.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deredshift</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot yet deredshift models.&#39;</span><span class="p">)</span>

        <span class="c1"># Check the spectral sampling</span>
        <span class="n">velscale_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">)</span>
                                        <span class="o">/</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">)))</span>
        <span class="n">_velscale</span><span class="p">,</span> <span class="n">_velscale_ratio</span> \
                <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_pixel_scale</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">obj_wave</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                             <span class="n">dvtol</span><span class="o">=</span><span class="n">dvtol</span><span class="p">)</span>
        <span class="c1"># Check the input spectra</span>
        <span class="n">obj_flux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">obj_flux_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">_obj_wave</span><span class="p">,</span> <span class="n">_obj_flux</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_objects</span><span class="p">(</span><span class="n">obj_wave</span><span class="p">,</span> <span class="n">obj_flux</span><span class="p">)</span>
        <span class="n">nobj</span> <span class="o">=</span> <span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_tpl_wave</span><span class="p">,</span> <span class="n">_tpl_flux</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">check_templates</span><span class="p">(</span><span class="n">tpl_wave</span><span class="p">,</span> <span class="n">tpl_flux</span><span class="p">,</span>
                                                          <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">)</span>
        <span class="n">ntpl</span> <span class="o">=</span> <span class="n">_tpl_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check the shape of the input model parameter database</span>
        <span class="k">if</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BINID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nobj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of model-parameter sets.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ntpl</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of weights does not match the number of templates.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the input pixel shift between the object and template</span>
        <span class="c1"># wavelength vectors; interpretted by pPXF as a base velocity</span>
        <span class="c1"># shift between the two</span>
        <span class="n">vsyst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="o">-</span><span class="n">PPXFFit</span><span class="o">.</span><span class="n">ppxf_tpl_obj_voff</span><span class="p">(</span><span class="n">_tpl_wave</span><span class="p">,</span> <span class="n">_obj_wave</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">],</span> <span class="n">_velscale</span><span class="p">,</span>
                                                         <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">],</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">])])</span>

        <span class="c1"># Get the additive and multiplicative degree of the polynomials</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">degree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">mdegree</span> <span class="o">=</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">mdegree</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdegree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">mdegree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Only produce selected models</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>

        <span class="c1"># Instantiate the output model array</span>
        <span class="n">models</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_obj_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1"># Initially mask everything</span>
        <span class="n">models</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

        <span class="c1"># Set the kinematics</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kin</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">_</span> <span class="o">=</span> <span class="n">PPXFFit</span><span class="o">.</span><span class="n">revert_velocity</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KINERR&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">redshift_only</span><span class="p">:</span>
            <span class="n">kin</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="k">elif</span> <span class="n">corrected_dispersion</span><span class="p">:</span>
            <span class="n">kin</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;KIN&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span> 
                                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;SIGMACORR_EMP&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">)</span>
<span class="c1">#        if deredshift:</span>
<span class="c1">#            kin[:,0] = 0.0</span>

        <span class="c1"># Construct the model for each (selected) object spectrum</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skip</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing model for spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nobj</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># This has to be redeclared every iteration because the</span>
            <span class="c1"># starting and ending pixels might be different (annoying);</span>
            <span class="c1"># as will the velocity offset; this means that the FFT of</span>
            <span class="c1"># the templates is recalculated at every step...</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">PPXFModel</span><span class="p">(</span><span class="n">_tpl_flux</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                          <span class="n">_obj_flux</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]],</span>
                          <span class="n">_velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">_velscale_ratio</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">)</span>

            <span class="n">models</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;BEGPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span><span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ENDPIX&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> \
                        <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">kin</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;TPLWGT&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:],</span>
                            <span class="n">addpoly</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;ADDCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:],</span>
                            <span class="n">multpoly</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">mdegree</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">model_par</span><span class="p">[</span><span class="s1">&#39;MULTCOEF&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,:])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing model for spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nobj</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">models</span></div></div>

</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>