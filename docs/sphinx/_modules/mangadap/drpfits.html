

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.drpfits &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.drpfits</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.drpfits</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines a class used to interface with files produced in the 3D phase of</span>
<span class="sd">the MaNGA Data Reduction Pipeline (DRP).</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2016, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/drpfits.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>

<span class="sd">        import sys</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import time</span>
<span class="sd">        import os.path</span>
<span class="sd">        import numpy</span>
<span class="sd">        import warnings</span>

<span class="sd">        from scipy import sparse</span>
<span class="sd">        from astropy.io import fits</span>
<span class="sd">        from astropy.wcs import WCS</span>

<span class="sd">        from .util.parser import arginp_to_list</span>
<span class="sd">        from .util.covariance import Covariance</span>
<span class="sd">        from .config.defaults import default_idlutils_dir, default_drp_version</span>
<span class="sd">        from .config.defaults import default_redux_path, default_drp_directory_path</span>
<span class="sd">        from .config.defaults import default_cube_pixelscale, default_cube_width_buffer</span>
<span class="sd">        from .config.defaults import default_cube_recenter, default_regrid_rlim</span>
<span class="sd">        from .config.defaults import default_regrid_sigma</span>
<span class="sd">        from .config.defaults import default_manga_fits_root</span>
<span class="sd">        from .util.bitmask import BitMask</span>

<span class="sd">*Class usage examples*:</span>

<span class="sd">    This class provides a basic interface with DRP LOG* files.  It provides a number of </span>


<span class="sd">*Revision history*:</span>
<span class="sd">    | **20 Nov 2014**: Original implementation by K. Westfall (KBW)</span>
<span class="sd">    | **12 Feb 2014**: (KBW) Added :func:`DRPFits.directory_path`</span>
<span class="sd">    | **20 Feb 2015**: (KBW) Add covariance calculation to :class:`DRPFits`</span>
<span class="sd">    | **19 Mar 2015**: (KBW) Added redux_path to :class:`DRPFits`.</span>
<span class="sd">        Re-arranged arguments in :func:`drpfits_list`, made drpver</span>
<span class="sd">        optional, and added redux_path</span>
<span class="sd">    | **22 May 2015**: (KBW) Sphinx documentation.  Changed DRPFits.w to</span>
<span class="sd">        :attr:`DRPFits.wcs`.</span>
<span class="sd">    | **26 May 2015**: (KBW) Added checksum=True when opening the DRP</span>
<span class="sd">        file.</span>
<span class="sd">    | **04 Jun 2015**: (KBW) Moved parse_drp_file_name to</span>
<span class="sd">        :func:`mangadap.util.parser.parse_drp_file_name`</span>
<span class="sd">    | **15 Jun 2015**: (KBW) Moved functions that return default values</span>
<span class="sd">        (like :func:`DRPFits._default_pixelscale`) to</span>
<span class="sd">        :mod:`mangadap.config.defaults`</span>
<span class="sd">    | **05 Aug 2015**: (KBW) Changed mode testing to be more robust.</span>
<span class="sd">        Added directory_path keyword to :func:`drpfits_list`.  Changed</span>
<span class="sd">        how directory path is set; previously required drpver and</span>
<span class="sd">        redux_path defaults, even if directory_path was provided</span>
<span class="sd">        directly.  **May need to add checks to other code to make sure</span>
<span class="sd">        drpver and redux_path are not None when directory_path has been</span>
<span class="sd">        directly defined.**</span>
<span class="sd">    | **28 Aug 2015**: (KBW) Added usage of</span>
<span class="sd">        :func:`mangadap.config.defaults.default_manga_fits_root`</span>
<span class="sd">    | **15 Feb 2016**: (KBW) Added :func:`DRPFits.__getitem__`</span>
<span class="sd">        function</span>
<span class="sd">    | **17 Feb 2016**: (KBW) Converted drpfile class name to DRPFits</span>
<span class="sd">    | **23 Mar 2016**: (KBW) Added functionality that abstracts the</span>
<span class="sd">        difference between the RSS and CUBE file formats at the user</span>
<span class="sd">        level.  CUBE files are now restructured to matched the</span>
<span class="sd">        *intended* orientation provided by the DRP; i.e., [x,y,lambda].</span>
<span class="sd">        RSS files are left the same, which is [fiber, lambda].</span>
<span class="sd">        Documentation.  Testing, particularly of x,y order.</span>
<span class="sd">    | **10 Nov 2016**: (KBW) Included &#39;DISP&#39; in spectral arrays.</span>
<span class="sd">    | **30 Nov 2016**: (KBW) Include</span>
<span class="sd">        :func:`DRPFits.spectral_resolution`, which returns spectral</span>
<span class="sd">        resolution cube or vector independent of MPL</span>
<span class="sd">    | **01 Dec 2016**: (KBW) Added</span>
<span class="sd">        :func:`DRPFits.spectral_resolution_header`.</span>
<span class="sd">    | **06 Dec 2016**: (KBW) Removed wavelength_mask function, now uses</span>
<span class="sd">        :class:`mangadap.util.pixelmask.SpectralPixelMask`.  Moved the</span>
<span class="sd">        main functionality of :func:`DRPFits.copy_to_array` and</span>
<span class="sd">        :func:`DRPFits.copy_to_masked_array` to</span>
<span class="sd">        :class:`mangadap.util.fitsutil.DAPFitsUtil`, what&#39;s left are</span>
<span class="sd">        wrapper functions for the more general functions in</span>
<span class="sd">        :class:`mangadap.util.fitsutil.DAPFitsUtil`.</span>
<span class="sd">    | **17 Feb 2017**: (KBW) Return nominal inverse variance in</span>
<span class="sd">        :func:`DRPFits.regrid_wavelength_plane` if requested.</span>
<span class="sd">    | **17 May 2017**: (KBW) Include a response function in</span>
<span class="sd">        :func:`DRPFits.flux_stats` and</span>
<span class="sd">        :func:`DAPFits.mean_sky_coordinates`.</span>
<span class="sd">    | **21 Aug 2017**: (KBW) In spectral resolution function, select</span>
<span class="sd">        pre- vs. post-pixelized Gaussian respresentation.</span>

<span class="sd">.. todo::</span>

<span class="sd">    - Calculation in :func:`DRPFits._cube_dimensions` will only be</span>
<span class="sd">      correct if the WCS coordinates have no rotation.</span>
<span class="sd">    - Further optimize calculation of transfer matrix</span>
<span class="sd">    - Make DRP file class flexible to linear or log-linear wavelength</span>
<span class="sd">      sampling?  Incorporate into MODE?</span>
<span class="sd">    - Reconstructed broad-band images and PSFs are *not* restructured in</span>
<span class="sd">      the CUBE files!  This is why the are transposed in</span>
<span class="sd">      :func:`mangadap.drpfits.DRPFits.gri_composite`.</span>
<span class="sd">    - Image reconstruction has transpose sense wrt DRP output!</span>
<span class="sd">    - Add logging</span>

<span class="sd">    - Need to be clear about which functions use the RSS spectra to</span>
<span class="sd">      create CUBE related data, like the covariance matrix and</span>
<span class="sd">      instrumental dispersion calculations.</span>

<span class="sd">.. _astropy.io.fits: http://docs.astropy.org/en/stable/io/fits/index.html</span>
<span class="sd">.. _astropy.io.fits.hdu.hdulist.HDUList: http://docs.astropy.org/en/v1.0.2/io/fits/api/hdulists.html</span>
<span class="sd">.. _astropy.wcs.wcs.WCS: http://docs.astropy.org/en/v1.0.2/api/astropy.wcs.WCS.html</span>
<span class="sd">.. _numpy.meshgrid: http://docs.scipy.org/doc/numpy/reference/generated/numpy.meshgrid.html</span>
<span class="sd">.. _scipy.sparse.csr_matrix: http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html</span>
<span class="sd">.. _numpy.ma.MaskedArray: http://docs.scipy.org/doc/numpy-1.10.1/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray</span>
<span class="sd">.. _shapely: https://pypi.python.org/pypi/Shapely</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="k">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="k">import</span> <span class="n">WCS</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="k">import</span> <span class="n">cascaded_union</span>
    <span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="k">import</span> <span class="n">Point</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not import shapely!&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.util.fitsutil</span> <span class="k">import</span> <span class="n">DAPFitsUtil</span>
<span class="kn">from</span> <span class="nn">.util.bitmask</span> <span class="k">import</span> <span class="n">BitMask</span>
<span class="kn">from</span> <span class="nn">.util.constants</span> <span class="k">import</span> <span class="n">DAPConstants</span>
<span class="kn">from</span> <span class="nn">.util.parser</span> <span class="k">import</span> <span class="n">arginp_to_list</span>
<span class="kn">from</span> <span class="nn">.util.covariance</span> <span class="k">import</span> <span class="n">Covariance</span>
<span class="kn">from</span> <span class="nn">.util.pixelmask</span> <span class="k">import</span> <span class="n">SpectralPixelMask</span>
<span class="kn">from</span> <span class="nn">.util.filter</span> <span class="k">import</span> <span class="n">interpolate_masked_vector</span>
<span class="kn">from</span> <span class="nn">.util.instrument</span> <span class="k">import</span> <span class="n">spectral_coordinate_step</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_idlutils_dir</span><span class="p">,</span> <span class="n">default_drp_version</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_redux_path</span><span class="p">,</span> <span class="n">default_drp_directory_path</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_cube_pixelscale</span><span class="p">,</span> <span class="n">default_cube_width_buffer</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_cube_recenter</span><span class="p">,</span> <span class="n">default_regrid_rlim</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_regrid_sigma</span>
<span class="kn">from</span> <span class="nn">.config.defaults</span> <span class="k">import</span> <span class="n">default_manga_fits_root</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span>
<span class="c1">#from memory_profiler import profile</span>

<div class="viewcode-block" id="drpfits_list"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.drpfits_list">[docs]</a><span class="k">def</span> <span class="nf">drpfits_list</span><span class="p">(</span><span class="n">platelist</span><span class="p">,</span> <span class="n">ifudesignlist</span><span class="p">,</span> <span class="n">modelist</span><span class="p">,</span> <span class="n">combinatorics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">redux_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provided a list of plates, ifudesigns, and modes, return a list of</span>
<span class="sd">    DRP files to be analyzed by the DAP.</span>

<span class="sd">    If the number of elements in each list is the same, the matching is</span>
<span class="sd">    assumed to be finished unless combinatorics is True.  If the number</span>
<span class="sd">    of elements is not the same, or cominatorics is True, the matched</span>
<span class="sd">    list is all the combinations of the provided elements.</span>

<span class="sd">    Args:</span>
<span class="sd">        platelist (str or list): List of plates to use.</span>
<span class="sd">        ifudesignlist (str or list): List of IFU designs to use.</span>
<span class="sd">        modelist (str or list): List of DRP output modes (&#39;CUBE&#39; or &#39;RSS&#39;)</span>
<span class="sd">        combinatorics (bool): (**Optional**) Based on the input</span>
<span class="sd">            *platelist* and *ifudesignlist*, create a list with all</span>
<span class="sd">            possible combinations.</span>
<span class="sd">        drpver (str): (**Optional**) The DRP version, which **must** be</span>
<span class="sd">            a single string value used for all DRP files.</span>
<span class="sd">        redux_path (str): (**Optional**) The path to the top level</span>
<span class="sd">            directory containing the DRP output files; this is the same</span>
<span class="sd">            as the *redux_path* in the :class:`DRPFits` class.</span>
<span class="sd">        directory_path (str): (**Optional**) The exact path to the DRP</span>
<span class="sd">            file.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_drp_directory_path`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of DRP file objects</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: Raised if *drpver* or *redux_path* are not strings.</span>
<span class="sd">        ValueError: Raised if the *platelist*, *ifudesignlist*, or</span>
<span class="sd">            *modelist* are None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">drpver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drpver</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;drpver must be a string&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">redux_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">redux_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;redux_path must be a string&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;directory_path must be a string&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">platelist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ifudesignlist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">modelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide platelist, ifudesignlist, and modelist!&#39;</span><span class="p">)</span>

    <span class="n">platelist_</span> <span class="o">=</span> <span class="n">arginp_to_list</span><span class="p">(</span><span class="n">platelist</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#   print(platelist)</span>
<span class="c1">#   print(platelist_)</span>
    <span class="n">ifudesignlist_</span> <span class="o">=</span> <span class="n">arginp_to_list</span><span class="p">(</span><span class="n">ifudesignlist</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#   print(ifudesignlist)</span>
<span class="c1">#   print(ifudesignlist_)</span>
    <span class="n">modelist_</span> <span class="o">=</span> <span class="n">arginp_to_list</span><span class="p">(</span><span class="n">modelist</span><span class="p">)</span>

    <span class="n">n_plates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">platelist_</span><span class="p">)</span>
    <span class="n">n_designs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifudesignlist_</span><span class="p">)</span>
    <span class="n">n_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modelist_</span><span class="p">)</span>

<span class="c1">#   print(n_plates)</span>
<span class="c1">#   print(n_designs)</span>
<span class="c1">#   print(n_modes)</span>

    <span class="c1"># Perform the combinatorics</span>
    <span class="k">if</span> <span class="n">n_plates</span> <span class="o">!=</span> <span class="n">n_designs</span> <span class="ow">or</span> <span class="n">n_plates</span> <span class="o">!=</span> <span class="n">n_modes</span> <span class="ow">or</span> <span class="n">combinatorics</span><span class="p">:</span>

        <span class="c1"># Force elements in platelist, ifudesignlist, and modelist</span>
        <span class="c1"># to be unique before performing combinatorics</span>
        <span class="n">platelist_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">platelist_</span><span class="p">))</span>
        <span class="n">ifudesignlist_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ifudesignlist_</span><span class="p">))</span>
        <span class="n">modelist_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">modelist_</span><span class="p">))</span>

        <span class="n">n_plates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">platelist_</span><span class="p">)</span>
        <span class="n">n_designs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifudesignlist_</span><span class="p">)</span>
        <span class="n">n_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modelist_</span><span class="p">)</span>

        <span class="c1"># Each element of plate list is repeated n_designs*n_modes times</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_plates</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_designs</span><span class="o">*</span><span class="n">n_modes</span><span class="p">):</span>
                <span class="n">platelist_</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">n_designs</span><span class="o">*</span><span class="n">n_modes</span><span class="p">,</span> <span class="n">platelist_</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n_designs</span><span class="o">*</span><span class="n">n_modes</span><span class="p">])</span>

        <span class="c1"># First repeat each element of ifudesign list n_modes times</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_designs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_modes</span><span class="p">):</span>
                <span class="n">ifudesignlist_</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">n_modes</span><span class="p">,</span> <span class="n">ifudesignlist_</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">n_modes</span><span class="p">])</span>
        <span class="c1"># Then repeat the entire list n_plates times</span>
        <span class="n">ifudesignlist__</span> <span class="o">=</span> <span class="n">ifudesignlist_</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_plates</span><span class="p">):</span>
            <span class="n">ifudesignlist_</span> <span class="o">+=</span> <span class="n">ifudesignlist__</span>

        <span class="c1"># Mode list iterated most quickly, so repeat the full list</span>
        <span class="c1"># n_plates*n_designs times</span>
        <span class="n">modelist__</span> <span class="o">=</span> <span class="n">modelist_</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_plates</span><span class="o">*</span><span class="n">n_designs</span><span class="p">):</span>
            <span class="n">modelist_</span> <span class="o">+=</span> <span class="n">modelist__</span>

        <span class="n">nn</span> <span class="o">=</span> <span class="n">n_plates</span><span class="o">*</span><span class="n">n_designs</span><span class="o">*</span><span class="n">n_modes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">n_plates</span>

    <span class="c1"># Set the directory path based on the provided main path</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">DRPFits</span><span class="p">(</span><span class="n">platelist_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ifudesignlist_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">modelist_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">drpver</span><span class="o">=</span><span class="n">drpver</span><span class="p">,</span>
                    <span class="n">redux_path</span><span class="o">=</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="n">directory_path</span><span class="p">)</span> \
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nn</span><span class="p">)]</span></div>


<div class="viewcode-block" id="DRPFitsBitMask"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFitsBitMask">[docs]</a><span class="k">class</span> <span class="nc">DRPFitsBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Structure with the DRP mask bits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdss_maskbits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;CUBE&#39;</span><span class="p">):</span>
        <span class="n">DRPFits</span><span class="o">.</span><span class="n">check_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">sdss_maskbits</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">default_idlutils_dir</span><span class="p">(),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;sdss&#39;</span><span class="p">,</span> <span class="s1">&#39;sdssMaskbits.par&#39;</span><span class="p">)</span> \
                        <span class="k">if</span> <span class="n">sdss_maskbits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sdss_maskbits</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par_file</span><span class="o">=</span><span class="n">sdss_maskbits</span><span class="p">,</span> <span class="n">par_grp</span><span class="o">=</span><span class="s1">&#39;MANGA_DRP3PIXMASK&#39;</span> \
                                                        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span> <span class="k">else</span> <span class="s1">&#39;MANGA_DRP2PIXMASK&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPQuality3DBitMask"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPQuality3DBitMask">[docs]</a><span class="k">class</span> <span class="nc">DRPQuality3DBitMask</span><span class="p">(</span><span class="n">BitMask</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Structure with the definition of the DRP3QUAL mask bits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdss_maskbits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">sdss_maskbits</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">default_idlutils_dir</span><span class="p">(),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;sdss&#39;</span><span class="p">,</span> <span class="s1">&#39;sdssMaskbits.par&#39;</span><span class="p">)</span> \
                        <span class="k">if</span> <span class="n">sdss_maskbits</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sdss_maskbits</span>
        <span class="n">BitMask</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par_file</span><span class="o">=</span><span class="n">sdss_maskbits</span><span class="p">,</span> <span class="n">par_grp</span><span class="o">=</span><span class="s1">&#39;MANGA_DRP3QUAL&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits">[docs]</a><span class="k">class</span> <span class="nc">DRPFits</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A general purpose class used to interface with a MaNGA DRP file.</span>

<span class="sd">    Args:</span>
<span class="sd">        plate (int): Plate number</span>
<span class="sd">        ifudesign (int): IFU design</span>
<span class="sd">        mode (str): 3D mode of the DRP file; must be either &#39;RSS&#39; or</span>
<span class="sd">            &#39;CUBE&#39;</span>
<span class="sd">        drpver (str): (**Optional**) DRP version, which is used to</span>
<span class="sd">            define the default DRP redux path.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_drp_version`</span>
<span class="sd">        redux_path (str): (**Optional**) The path to the top level</span>
<span class="sd">            directory containing the DRP output files for a given DRP</span>
<span class="sd">            version.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_redux_path`.</span>
<span class="sd">        directory_path (str): (**Optional**) The exact path to the DRP</span>
<span class="sd">            file.  Default is defined by</span>
<span class="sd">            :func:`mangadap.config.defaults.default_drp_directory_path`.</span>
<span class="sd">        read (bool) : (**Optional**) Read the DRP file upon</span>
<span class="sd">            instantiation of the object.</span>
<span class="sd">        checksum (bool): (**Optional**) Check for file corruption.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if *mode* is not &#39;RSS&#39; or &#39;CUBE&#39;.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        plate, ifudesign (int): Plate and IFU designation</span>
<span class="sd">        mode (str): 3D mode of the DRP file, see above</span>
<span class="sd">        drpver (str): DRP version, which is used to define the default</span>
<span class="sd">            DRP redux path, see above.</span>
<span class="sd">        redux_path (str): The path to the top level directory containing</span>
<span class="sd">            the DRP output files for a given DRP version, see above.</span>
<span class="sd">        directory_path (str): The exact path to the DRP file, see above.</span>
<span class="sd">        pixelscale (float): Pixel scale used during the CUBE reconstruction.</span>
<span class="sd">        recenter (bool): If False, the coordinates in the XPOS and YPOS</span>
<span class="sd">            extensions of the DRP file are assumed to be centered at</span>
<span class="sd">            0,0.  If True, the XPOS and YPOS can have any center, and</span>
<span class="sd">            the center of the CUBE is set to be approximately the center</span>
<span class="sd">            of the range in XPOS,YPOS.</span>
<span class="sd">        width_buffer (float): The number of pixels to add to the width</span>
<span class="sd">            of the cube in addition to the range needed to cover XPOS</span>
<span class="sd">            and YPOS.</span>
<span class="sd">        xs, ys (float): The starting on-sky coordinate of the</span>
<span class="sd">            reconstructed image defined by the bottom corner of the</span>
<span class="sd">            first pixel, not its center!</span>
<span class="sd">        nx, ny (int): The size (number of pixel in x and y) of the</span>
<span class="sd">            reconstructed image.</span>
<span class="sd">        regrid_T (`scipy.sparse.csr_matrix`_): Transfer matrix :math:`{\mathbf</span>
<span class="sd">            T}` such that:</span>

<span class="sd">            .. math::</span>

<span class="sd">                {\mathbf T} \times {\mathbf F} = {\mathbf I}</span>

<span class="sd">            where :math:`{\mathbf F}` is the vector of fluxes in a</span>
<span class="sd">            single wavelength channel for all the fiber measurements in</span>
<span class="sd">            the field of view and :math:`{\mathbf I}` is the</span>
<span class="sd">            pre-formatted reconstructed image of that wavelength</span>
<span class="sd">            channel.  Saved such that repeat calls to create T for a</span>
<span class="sd">            given wavelength channel do not result in repeat</span>
<span class="sd">            calculations.</span>
<span class="sd">        regrid_channel (int): Wavelength channel for which</span>
<span class="sd">            :attr:`regrid_T` has been calculated.</span>
<span class="sd">        regrid_rlim (float): The limiting radius of the Gaussian</span>
<span class="sd">            interpolation kernel used during image construction in</span>
<span class="sd">            arcseconds.</span>
<span class="sd">        regrid_sigma (float): The sigma of the Gaussian interpolation</span>
<span class="sd">            kernel used during image construction in arcseconds.</span>
<span class="sd">        sigma_rho (float): The sigma, :math:`\sigma_\rho`, of the</span>
<span class="sd">            Gaussian function used to approximate the trend of the</span>
<span class="sd">            correlation coefficient :math:`\rho` with pixel separation</span>
<span class="sd">            as stored in :attr:`cov_rho`.  That is:</span>

<span class="sd">            .. math::</span>

<span class="sd">                \rho_{ij} = \exp\left(\frac{-d^2_{ij}}{2</span>
<span class="sd">                \sigma^2_\rho}\right)</span>

<span class="sd">            where :math:`d_{ij}` is the distance between pixels</span>
<span class="sd">            :math:`i` and :math:`j`.</span>
<span class="sd">        cov_rho (`scipy.sparse.csr_matrix`_): The matrix :math:`{\mathbf</span>
<span class="sd">            R}` containing the correlation coefficents, :math:`\rho`,</span>
<span class="sd">            between elements of the covariance matrix, :math:`{\mathbf</span>
<span class="sd">            C}`, as approximated using the parameterization of</span>
<span class="sd">            :math:`\rho` with pixel separation.  This matrix will be</span>
<span class="sd">            *independent of wavelength*.  In general,</span>

<span class="sd">            .. math::</span>

<span class="sd">                {\mathbf C} = \left[</span>
<span class="sd">                \begin{array}{rrrr}</span>
<span class="sd">                    ... &amp; ... &amp; ... &amp; ... \\</span>
<span class="sd">                    ... &amp; \sigma^2_i &amp; \rho_{ij}\sigma_i\sigma_j &amp; ... \\</span>
<span class="sd">                    ... &amp; \rho_{ji}\sigma_j\sigma_i &amp; \sigma^2_j &amp; ... \\</span>
<span class="sd">                    ... &amp; ... &amp; ... &amp; ...</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right]</span>

<span class="sd">            such that</span>

<span class="sd">            .. math::</span>

<span class="sd">                {\mathbf R} = \left[</span>
<span class="sd">                \begin{array}{rrrr}</span>
<span class="sd">                    ... &amp; ... &amp; ... &amp; ... \\</span>
<span class="sd">                    ... &amp; 1.0 &amp; \rho_{ij} &amp; ... \\</span>
<span class="sd">                    ... &amp; \rho_{ji} &amp; 1.0 &amp; ... \\</span>
<span class="sd">                    ... &amp; ... &amp; ... &amp; ...</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right].</span>

<span class="sd">        bitmask(:class:`DRPFitsBitMask`): Object used to interpret the</span>
<span class="sd">            DRP bit mask values in the `MASK` extension.</span>
<span class="sd">        hdu (`astropy.io.fits.hdu.hdulist.HDUList`_): HDUList read from</span>
<span class="sd">            the DRP file</span>
<span class="sd">        ext (list): List of fits extensions in the file</span>
<span class="sd">        checksum (bool): Flag to check for file corruption when opening</span>
<span class="sd">            the HDU.</span>
<span class="sd">        wcs (`astropy.wcs.wcs.WCS`_): WCS object based on WCS keywords</span>
<span class="sd">            in the header of the FLUX extension.</span>
<span class="sd">        shape (tuple) : Shape of the main data arrays</span>
<span class="sd">        spatial_shape (tuple) : Shape of the spatial axes only.  For RSS</span>
<span class="sd">            files, this is a single element with the number of fibers;</span>
<span class="sd">            for CUBE files, this has the x and y dimensions of the data</span>
<span class="sd">            cube.  *These are transposed w.r.t. the read-in DRP file!*</span>
<span class="sd">        nspec (int) : Number of spectra in the DRP file; this is just:</span>
<span class="sd">            ::</span>
<span class="sd">                </span>
<span class="sd">                self.nspec = numpy.prod(self.spatial_shape)</span>
<span class="sd">        </span>
<span class="sd">        spatial_index (numpy.ndarray) : Array with tuples used to select</span>
<span class="sd">            spectra at specific locations within the data array.  This</span>
<span class="sd">            is mainly useful in ``CUBE`` mode, where this provides the</span>
<span class="sd">            indices in the spatial coordinates.  The order is</span>
<span class="sd">            :math:`(x,y)`; i.e. this is *different* that what you get if</span>
<span class="sd">            you read the DRP CUBE fits file directly using</span>
<span class="sd">            `astropy.io.fits`_.  In ``RSS`` mode, this is just the index</span>
<span class="sd">            of the spectrum in the 2D array.  See: :func:`select`.</span>
<span class="sd">        spectral_arrays (list) : List of viable keywords for the data</span>
<span class="sd">            arrays in the DRP file.  For CUBE files, these are &#39;FLUX&#39;,</span>
<span class="sd">            &#39;IVAR&#39;, and &#39;MASK&#39;; for RSS files, this also includes</span>
<span class="sd">            &#39;DISP&#39;, &#39;XPOS&#39;, and &#39;YPOS&#39;.</span>
<span class="sd">        dispaxis (int) : Index of the axis with the spectral channels.</span>
<span class="sd">            The internal data structure always has :attr:`dispaxis` as</span>
<span class="sd">            the *last* axis in the array.  So :attr:`dispaxis` is 2 for</span>
<span class="sd">            CUBE files and 1 for RSS files.  This means that the</span>
<span class="sd">            internal data array restructures the input fits data for the</span>
<span class="sd">            CUBE files.</span>
<span class="sd">        nwave (int): The number of wavelength channels; this is just:</span>
<span class="sd">            ::</span>

<span class="sd">                self.nwave = self.shape[self.dispaxis]</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    @profile</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redux_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">read</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Set the attributes, forcing a known type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plate</span> <span class="o">=</span> <span class="n">long</span><span class="p">(</span><span class="n">plate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span> <span class="o">=</span> <span class="n">long</span><span class="p">(</span><span class="n">ifudesign</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="c1"># Setup the directory path.</span>
        <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drpver</span> <span class="o">=</span> <span class="n">default_drp_version</span><span class="p">()</span> <span class="k">if</span> <span class="n">drpver</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">drpver</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span> <span class="o">=</span> <span class="n">default_redux_path</span><span class="p">(</span><span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">)</span> \
                              <span class="k">if</span> <span class="n">redux_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">redux_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="n">default_drp_directory_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span>
                                                             <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># THE DRP VERSION WILL NOT BE SPECIFIED!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drpver</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">directory_path</span><span class="p">)</span>

        <span class="c1"># Initialize the image dimensions and their parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_buffer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Provide internal variables to keep the currently available</span>
        <span class="c1"># regridding transfer matrix for computing a plane of the data</span>
        <span class="c1"># cube, the index of the wavelength channel defining that plane,</span>
        <span class="c1"># and the properties used to create the matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span> <span class="o">=</span> <span class="kc">None</span>            
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_channel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_rlim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_sigma</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Provide internal variables to keep the rho matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_rho</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_rho</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try to define the BitMask object</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">DRPFitsBitMask</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unable to define bit mask for DRP file.  Can only distinguish between&#39;</span>
                          <span class="s1">&#39;masked (values greater than 0) and unmasked (values of 0).&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Setup the variables for the internal data structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># Do not automatically read the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># Extensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">checksum</span>        <span class="c1"># Check the file for corruption</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># WCS structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># Shape of the data array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="kc">None</span>       <span class="c1"># Shape of the spatial axes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># Total number of spectra (good or bad)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="kc">None</span>       <span class="c1"># Abstracted spatial indexing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="kc">None</span>     <span class="c1"># Arrays with spectral data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read the file, if requested</span>
        <span class="k">if</span> <span class="n">read</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>


<div class="viewcode-block" id="DRPFits.from_file"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_file</span><span class="p">,</span> <span class="n">plate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ifudesign</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to read a DRP-like data cube.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Work in progress.  Currently does not work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;./mimic_manga&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s1">&#39;./mimic_manga&#39;</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="s1">&#39;./mimic_manga/manga-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-LOGCUBE.fits.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;removing&#39;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="s1">&#39;./mimic_manga&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="n">read</span><span class="p">)</span></div>


<span class="c1">#    def __del__(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Deconstruct the DRPFits object by ensuring that the fits file is</span>
<span class="c1">#        properly closed.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        if self.hdu is None:</span>
<span class="c1">#            return</span>
<span class="c1">#        self.hdu.close()</span>
<span class="c1">#        self.hdu = None</span>
<span class="c1">#        self.wcs = None</span>
<span class="c1">#        self.shape = None</span>
<span class="c1">#        self.spatial_shape = None</span>
<span class="c1">#        self.nspec = None</span>
<span class="c1">#        self.spatial_index = None</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access elements of the hdu.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>


<div class="viewcode-block" id="DRPFits._cube_dimensions_undefined"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._cube_dimensions_undefined">[docs]</a>    <span class="k">def</span> <span class="nf">_cube_dimensions_undefined</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if any of the cube dimensions are None.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DRPFits._cube_dimensions_correct"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._cube_dimensions_correct">[docs]</a>    <span class="k">def</span> <span class="nf">_cube_dimensions_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the saved parameters that define the cube dimensions</span>
<span class="sd">        are the same as the desired values.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            recenter (bool): Flag to recenter the coordinate system</span>
<span class="sd">            width_buffer (int): Number of pixels to use as buffer for</span>
<span class="sd">                the image reconstruction</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the saved and desired values are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">!=</span> <span class="n">pixelscale</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span> <span class="o">!=</span> <span class="n">recenter</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">width_buffer</span> <span class="o">!=</span> <span class="n">width_buffer</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="DRPFits._regrid_transfer_undefined"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._regrid_transfer_undefined">[docs]</a>    <span class="k">def</span> <span class="nf">_regrid_transfer_undefined</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if :attr:`regrid_T` is None.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DRPFits._regrid_kernel_correct"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._regrid_kernel_correct">[docs]</a>    <span class="k">def</span> <span class="nf">_regrid_kernel_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the saved parameters used to define the image</span>
<span class="sd">        reconstruction kernel are the same as the desired values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the saved and desired values are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">!=</span> <span class="n">pixelscale</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_rlim</span> <span class="o">!=</span> <span class="n">rlim</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_sigma</span> <span class="o">!=</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="DRPFits._regrid_transfer_correct"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._regrid_transfer_correct">[docs]</a>    <span class="k">def</span> <span class="nf">_regrid_transfer_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the saved parameters used to construct the transfer</span>
<span class="sd">        matrix, :math:`{\mathbf T}`, are the same as the desired values.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the wavelength channel to</span>
<span class="sd">                reconstruct</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the saved and desired values are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_channel</span> <span class="o">!=</span> <span class="n">channel</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_kernel_correct</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits._regrid_defaults"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._regrid_defaults">[docs]</a>    <span class="k">def</span> <span class="nf">_regrid_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the saved regridding parameters are the same as the</span>
<span class="sd">        defaults.  See</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_pixelscale`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_recenter`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_width_buffer`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_rlim`, and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_sigma`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            recenter (bool): Flag to recenter the coordinate system</span>
<span class="sd">            width_buffer (int): Number of pixels to use as buffer for</span>
<span class="sd">                the image reconstruction</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the saved and default values are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pixelscale</span> <span class="o">!=</span> <span class="n">default_cube_pixelscale</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">recenter</span> <span class="o">!=</span> <span class="n">default_cube_recenter</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">width_buffer</span> <span class="o">!=</span> <span class="n">default_cube_width_buffer</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">rlim</span> <span class="o">!=</span> <span class="n">default_regrid_rlim</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">!=</span> <span class="n">default_regrid_sigma</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="DRPFits._init_regrid_pars"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._init_regrid_pars">[docs]</a>    <span class="k">def</span> <span class="nf">_init_regrid_pars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the regridding parameters.  If provided on input, the</span>
<span class="sd">        same value is returned.  Otherwise, the returned values are the</span>
<span class="sd">        defaults.  See the defaults defined in</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_pixelscale`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_recenter`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_width_buffer`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_rlim`, and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_sigma`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            recenter (bool): Flag to recenter the coordinate system</span>
<span class="sd">            width_buffer (int): Number of pixels to use as buffer for</span>
<span class="sd">                the image reconstruction</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float, bool, int, float, float: The validated regridding</span>
<span class="sd">            parameters in the same order as listed by the function</span>
<span class="sd">            arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pixelscale</span> <span class="o">=</span> <span class="n">default_cube_pixelscale</span><span class="p">()</span> <span class="k">if</span> <span class="n">pixelscale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pixelscale</span>
        <span class="n">recenter</span> <span class="o">=</span> <span class="n">default_cube_recenter</span><span class="p">()</span> <span class="k">if</span> <span class="n">recenter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">recenter</span>
        <span class="n">width_buffer</span> <span class="o">=</span> <span class="n">default_cube_width_buffer</span><span class="p">()</span> <span class="k">if</span> <span class="n">width_buffer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">width_buffer</span>
        <span class="n">rlim</span> <span class="o">=</span> <span class="n">default_regrid_rlim</span><span class="p">()</span> <span class="k">if</span> <span class="n">rlim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rlim</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">default_regrid_sigma</span><span class="p">()</span> <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sigma</span>

        <span class="k">return</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span></div>


<div class="viewcode-block" id="DRPFits._variance_correlation_undefined"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._variance_correlation_undefined">[docs]</a>    <span class="k">def</span> <span class="nf">_variance_correlation_undefined</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if :attr:`cov_rho` is None.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="DRPFits._variance_correlation_correct"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._variance_correlation_correct">[docs]</a>    <span class="k">def</span> <span class="nf">_variance_correlation_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the saved parameters used to construct the</span>
<span class="sd">        correlation coefficient matrix, :math:`{\mathbf R}`, are the</span>
<span class="sd">        same as the desired values.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            sigma_rho (float): The sigma of the Gaussian function used</span>
<span class="sd">                to approximate the trend of the correlation coefficient</span>
<span class="sd">                with pixel separation.</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the saved and desired values are the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_rho</span> <span class="o">!=</span> <span class="n">sigma_rho</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_kernel_correct</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits._cube_dimensions"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._cube_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">_cube_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the on-sky dimensions of the reconstructed image for</span>
<span class="sd">        all wavelength channels and save them in :attr:`xs`, :attr:`ys`,</span>
<span class="sd">        :attr:`nx`, and :attr:`ny`.</span>

<span class="sd">        For CUBE files, these dimensions are drawn directly from the WCS</span>
<span class="sd">        keywords in the header of the FLUX extension of the DRP fits</span>
<span class="sd">        file.  In this case, **any entered parameters are ignored and</span>
<span class="sd">        the class attributes are set to the default values used by the</span>
<span class="sd">        DRP**.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The calculation for the CUBE files is only valid if the WCS</span>
<span class="sd">            coordinate system has no rotation.</span>

<span class="sd">        For RSS files, the dimensions are determined using the data in</span>
<span class="sd">        the &#39;XPOS&#39; and &#39;YPOS&#39; extensions and the same algorithm used by</span>
<span class="sd">        the DRP; however, it is possible to provide different parameters</span>
<span class="sd">        that will alter the dimensions.</span>

<span class="sd">        See: :attr:`pixelscale`, :attr:`recenter`, :attr:`width_buffer`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            redo (bool): (**Optional**) Force the recalculation of the</span>
<span class="sd">                cube dimensions if they are already defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure that the fits file is ready for reading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>

        <span class="c1"># This will only be correct if the WCS coordinates have no rotation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">default_cube_pixelscale</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span> <span class="o">=</span> <span class="n">default_cube_recenter</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width_buffer</span> <span class="o">=</span> <span class="n">default_cube_width_buffer</span><span class="p">()</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="c1"># RA of first pixel edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CD1_1&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="c1"># Offset of first pixel edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">-</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJRA&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">]))</span><span class="o">*</span><span class="mf">3600.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>

            <span class="c1"># DEC of first pixel edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;CD2_2&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
            <span class="c1"># Offset of first pixel edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">-</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mf">3600.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="c1"># Set the default values for the input</span>
        <span class="k">if</span> <span class="n">pixelscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pixelscale</span> <span class="o">=</span> <span class="n">default_cube_pixelscale</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">recenter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recenter</span> <span class="o">=</span> <span class="n">default_cube_recenter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">width_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width_buffer</span> <span class="o">=</span> <span class="n">default_cube_width_buffer</span><span class="p">()</span>

        <span class="c1"># Check if the cube_dimensions already exist and were determined</span>
        <span class="c1"># using the correct parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">redo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions_undefined</span><span class="p">()</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions_correct</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Save the parameters used to create the dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">pixelscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recenter</span> <span class="o">=</span> <span class="n">recenter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_buffer</span> <span class="o">=</span> <span class="n">width_buffer</span>

        <span class="c1"># Get the size in each dimension</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;XPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;XPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">Dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">maxx</span><span class="o">-</span><span class="n">minx</span><span class="p">)</span>

        <span class="n">miny</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;YPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;YPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">Dy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">maxy</span><span class="o">-</span><span class="n">miny</span><span class="p">)</span>

        <span class="c1"># Force the size to be even and the same in both dimensions</span>
        <span class="n">Dx</span> <span class="o">=</span> <span class="n">Dx</span> <span class="k">if</span> <span class="n">Dx</span> <span class="o">&gt;</span> <span class="n">Dy</span> <span class="k">else</span> <span class="n">Dy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Dx</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">)</span><span class="o">+</span><span class="n">width_buffer</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
<span class="c1">#        print(&#39;CUBE size: {0} {1}\n&#39;.format(self.nx, self.ny))</span>

        <span class="c1"># Set the starting coordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">/</span><span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">/</span><span class="mf">2.</span>

        <span class="c1"># Offset to the center, if requested</span>
        <span class="k">if</span> <span class="n">recenter</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">minx</span><span class="o">+</span><span class="n">maxx</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">+</span> <span class="p">(</span><span class="n">miny</span><span class="o">+</span><span class="n">maxy</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span></div>
<span class="c1">#        print(self.xs, self.nx, self.ys, self.ny)</span>


<div class="viewcode-block" id="DRPFits._set_variance_correlation"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._set_variance_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">_set_variance_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                  <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce :attr:`cov_rho` based on the provided *sigma_rho*.</span>

<span class="sd">        By default, the details of the cube dimensions should be the</span>
<span class="sd">        same as the DRP used to produce the &#39;CUBE&#39; files from the &#39;RSS&#39;</span>
<span class="sd">        spectra; however, these can be changed.</span>

<span class="sd">        The resulting :attr:`cov_rho` is independent of wavelength and</span>
<span class="sd">        can be used in combination with the inverse-variance produced by</span>
<span class="sd">        the DRP to yield a wavelength-dependent covariance matrix that</span>
<span class="sd">        is close to the formal calculation.</span>

<span class="sd">        See: :attr:`cov_rho`, attr:`sigma_rho`, :attr:`pixelscale`,</span>
<span class="sd">        :attr:`recenter`, :attr:`width_buffer`, :attr:`rlim`,</span>
<span class="sd">        :attr:`sigma`.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            *sigma* is not actually used by this function.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Test the relation between *sigma*, *rlim*, and *sigma_rho*.</span>
<span class="sd">            It may be that sigma_rho should/can be determined by sigma.</span>

<span class="sd">        Args:</span>
<span class="sd">            sigma_rho (float): The sigma of the Gaussian function used</span>
<span class="sd">                to approximate the trend of the correlation coefficient</span>
<span class="sd">                with pixel separation.</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            redo (bool): (**Optional**) Force the recalculation of the</span>
<span class="sd">                cube dimensions if they are already defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Check if the variance correlation coefficients already exist</span>
        <span class="c1"># and were determined using the correct parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">redo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions_undefined</span><span class="p">()</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions_correct</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variance_correlation_undefined</span><span class="p">()</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variance_correlation_correct</span><span class="p">(</span><span class="n">sigma_rho</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_rho</span>

        <span class="c1"># Get the cube dimensions; may not necessarily match DRP calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions</span><span class="p">(</span><span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">)</span>

        <span class="c1"># Get the full covariance grid</span>
        <span class="n">nim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="c1"># Convert covariance pixel to two image pixels for the upper</span>
        <span class="c1"># triangle (including the diagonal):</span>
        <span class="n">i_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">i_i</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>

        <span class="n">i_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">i_j</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">i_i</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>

        <span class="n">j_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">j_i</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">jj</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>

        <span class="n">j_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">j_j</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">jj</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">j_i</span><span class="p">[</span><span class="n">jj</span> <span class="o">&gt;=</span> <span class="n">ii</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>

        <span class="c1">#Get the distances</span>
        <span class="n">dij</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">dij</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">j_i</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">i_i</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">j_j</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">i_j</span><span class="p">[</span><span class="n">jj</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">dij</span><span class="p">[</span><span class="n">dij</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">rlim</span><span class="o">/</span><span class="n">pixelscale</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1">#Set rho_ij</span>
        <span class="n">rho_ij</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="n">nim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">rho_ij</span><span class="p">[</span><span class="n">dij</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dij</span><span class="p">[</span><span class="n">dij</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">sigma_rho</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rho_ij</span><span class="p">[</span><span class="n">ii</span><span class="o">==</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Set the sparse rho matrix and save the parameters used to</span>
        <span class="c1"># generate it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_rho</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">rho_ij</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_rho</span> <span class="o">=</span> <span class="n">sigma_rho</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_rlim</span> <span class="o">=</span> <span class="n">rlim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_sigma</span> <span class="o">=</span> <span class="n">sigma</span></div>


<div class="viewcode-block" id="DRPFits._fix_header"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._fix_header">[docs]</a>    <span class="k">def</span> <span class="nf">_fix_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use of &#39;degrees&#39; in early versions of the DRP did not adhere to</span>
<span class="sd">        the fits standard causing the `astropy.wcs.wcs.WCS`_ to fail</span>
<span class="sd">        when initialized; see, e.g., :func:`world_mesh`. This changes</span>
<span class="sd">        the units to be &#39;deg&#39; instead.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function is *obsolete* as of v1_5_1 of the DRP and is</span>
<span class="sd">            not actively called in this implementation; see source for</span>
<span class="sd">            :func:`world_mesh`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CUNIT1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;CUNIT2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;deg&#39;</span></div>


<div class="viewcode-block" id="DRPFits._set_spectral_arrays"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._set_spectral_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">_set_spectral_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the list of extensions with spectral data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="s1">&#39;IVAR&#39;</span><span class="p">,</span> <span class="s1">&#39;MASK&#39;</span> <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span> <span class="ow">and</span> <span class="s1">&#39;DISP&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">+=</span> <span class="p">[</span> <span class="s1">&#39;DISP&#39;</span> <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span> <span class="ow">and</span> <span class="s1">&#39;PREDISP&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">+=</span> <span class="p">[</span> <span class="s1">&#39;PREDISP&#39;</span> <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span> <span class="o">+=</span> <span class="p">[</span> <span class="s1">&#39;XPOS&#39;</span><span class="p">,</span> <span class="s1">&#39;YPOS&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits._generate_spatial_index"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._generate_spatial_index">[docs]</a>    <span class="k">def</span> <span class="nf">_generate_spatial_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the tuples with the list of original indices in the</span>
<span class="sd">        input DRP file; see :attr:`spatial_index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span> <span class="p">]</span>
            <span class="k">return</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Set the coordinates to tuples in the ORIGINAL DRP fits file</span>
        <span class="c1"># (i.e., the DRP provides [lambda, y, x] whereas this class</span>
        <span class="c1"># transposes this order)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_index</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.mode_options"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.mode_options">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mode_options</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the allowed modes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of the allowed DRP fits file modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.check_mode"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.check_mode">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the mode is valid.</span>

<span class="sd">        Args:</span>

<span class="sd">            mode (str): Mode value to check.  Valid modes are `CUBE` and</span>
<span class="sd">            `RSS`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="o">.</span><span class="n">mode_options</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown mode </span><span class="si">{0}</span><span class="s1">.  Must be in: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span></div>


<div class="viewcode-block" id="DRPFits.sampling_options"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.sampling_options">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sampling_options</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the allowed wavelength sampling modes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of the allowed DRP fits wavelength sampling</span>
<span class="sd">            modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span> <span class="s1">&#39;LIN&#39;</span><span class="p">,</span> <span class="s1">&#39;LOG&#39;</span> <span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.default_paths"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.default_paths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_paths</span><span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redux_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the primary directory and file name with the DRP fits</span>
<span class="sd">        LOG-binned file.</span>
<span class="sd">            plate (int): Plate number of the observation.</span>
<span class="sd">            ifudesign (int): IFU design number of the observation.</span>
<span class="sd">            mode (str): 3D mode of the DRP file; must be either &#39;RSS&#39; or</span>
<span class="sd">                &#39;CUBE&#39;</span>
<span class="sd">            drpver (str): (**Optional**) DRP version.  Default set by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_drp_version`.</span>
<span class="sd">            redux_path (str): (**Optional**) The path to the top level</span>
<span class="sd">                directory containing the DRP output files for a given</span>
<span class="sd">                DRP version.  Default is defined by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_redux_path`.</span>
<span class="sd">            directory_path (str): (**Optional**) The exact path to the</span>
<span class="sd">                DAP reduction assessments file.  Default set by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_dap_common_path`.</span>
<span class="sd">            output_file (str): (**Optional**) The name of the file with</span>
<span class="sd">                the DRP data.  Default set by</span>
<span class="sd">                :func:`mangadap.config.defaults.default_manga_fits_root`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Two strings with the path to and name of the DRP data</span>
<span class="sd">            file.</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">_directory_path</span> <span class="o">=</span> <span class="n">default_drp_directory_path</span><span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="n">drpver</span><span class="p">,</span> <span class="n">redux_path</span><span class="o">=</span><span class="n">redux_path</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="n">directory_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">directory_path</span>
        <span class="n">_output_file</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.fits.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">default_manga_fits_root</span><span class="p">(</span><span class="n">plate</span><span class="p">,</span> <span class="n">ifudesign</span><span class="p">,</span>
                                                                    <span class="s1">&#39;LOG</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span> \
                            <span class="k">if</span> <span class="n">output_file</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_file</span>
        <span class="k">return</span> <span class="n">_directory_path</span><span class="p">,</span> <span class="n">_output_file</span></div>


<div class="viewcode-block" id="DRPFits.file_name"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.file_name">[docs]</a>    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the DRP file&quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">default_manga_fits_root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;LOG</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.fits.gz&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">root</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.file_path"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.file_path">[docs]</a>    <span class="k">def</span> <span class="nf">file_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the full path to the DRP file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">())</span></div>


<div class="viewcode-block" id="DRPFits.finding_chart_path"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.finding_chart_path">[docs]</a>    <span class="k">def</span> <span class="nf">finding_chart_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the full path to the PNG finding chart for the targetted</span>
<span class="sd">        object.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Move this to the defaults file?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.open_hdu"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.open_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">open_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the fits file.</span>
<span class="sd">        </span>
<span class="sd">        For security purposes, the fits file is *always* opened as read</span>
<span class="sd">        only.  If :attr:`hdu` is not None, this function assumes the</span>
<span class="sd">        data has already been read and returns to the calling process.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            checksum (bool): (**Optional**) Check for file corruption.</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError: Raised if the DRP file does not exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;Cannot open file: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

        <span class="c1"># Open the fits file, but do NOT allow the file to be</span>
        <span class="c1"># overwritten.</span>
        <span class="c1"># TODO: This takes a while because it&#39;s restructuring ALL of the</span>
        <span class="c1"># image arrays.  Can I expedite this somehow?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">permissions</span><span class="o">=</span><span class="s1">&#39;readonly&#39;</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="p">[</span> <span class="n">h</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_spectral_arrays</span><span class="p">()</span>

<span class="c1">#        # Reformat and initialize properties of the data</span>
<span class="c1">#        if self.mode == &#39;CUBE&#39;:</span>
<span class="c1">#            DAPFitsUtil.restructure_cube(self.hdu, ext=self.spectral_arrays)</span>
<span class="c1">#        elif self.mode == &#39;RSS&#39;:</span>
<span class="c1">#            DAPFitsUtil.restructure_rss(self.hdu, ext=self.spectral_arrays)</span>

        <span class="c1"># If RSS data, transpose the hdus so that the spectra are</span>
        <span class="c1"># organized along rows.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">transpose_image_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">get_spatial_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nwave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_spatial_index</span><span class="p">()</span></div>

   
<div class="viewcode-block" id="DRPFits.info"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the HDU info page.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Shapes returned in </span><span class="se">\&#39;</span><span class="s1">Dimensions</span><span class="se">\&#39;</span><span class="s1"> may be wrong!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">info</span><span class="p">()</span></div>


<div class="viewcode-block" id="DRPFits.do_not_fit_flags"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.do_not_fit_flags">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">do_not_fit_flags</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the maskbit names that should not be fit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;DONOTUSE&#39;</span><span class="p">,</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.do_not_stack_flags"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.do_not_stack_flags">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">do_not_stack_flags</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the maskbit names that should not be stacked.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;DONOTUSE&#39;</span><span class="p">,</span> <span class="s1">&#39;FORESTAR&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.select"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a specific vector from the fits data arrays.  The spatial</span>
<span class="sd">        position within the original file accessed by index ``i`` is</span>
<span class="sd">        given by :attr:`spatial_index`.  For CUBE files this is a tuple</span>
<span class="sd">        with the relevant pixel indices from the original DRP file.</span>
<span class="sd">        This function is setup such that, e.g.::</span>

<span class="sd">            from mangadap.drpfits import DRPFits</span>
<span class="sd">            from astropy.io import fits</span>
<span class="sd">            import numpy</span>
<span class="sd">            drpf = DRPFits(7495, 1901, &#39;CUBE&#39;, read=True)</span>
<span class="sd">            hdu = fits.open(drpf.file_path())</span>

<span class="sd">            # should be no difference</span>
<span class="sd">            flux_direct = hdu[&#39;FLUX&#39;].data[:,15,16]</span>
<span class="sd">            flux_class = drpf.select( (15,16), order=&#39;yx&#39; )</span>
<span class="sd">            assert not numpy.any( numpy.absolute(flux_direct - flux_class) &gt; 0 ), \</span>
<span class="sd">                &#39;Selection error!&#39;</span>

<span class="sd">            # Or to use more natural x y order</span>
<span class="sd">            flux_class = drpf.select( (16,15) )</span>
<span class="sd">            assert not numpy.any( numpy.absolute(flux_direct - flux_class) &gt; 0 ), \</span>
<span class="sd">                &#39;Selection error!&#39;</span>

<span class="sd">            # Or select the spectrum based on its index</span>
<span class="sd">            for i,t in enumerate(drpf.spatial_index):</span>
<span class="sd">                if t == (15,16):</span>
<span class="sd">                    break</span>
<span class="sd">            flux_class = drpf.select(i)</span>
<span class="sd">            assert not numpy.any( numpy.absolute(flux_direct - flux_class) &gt; 0 ), \</span>
<span class="sd">                &#39;Selection error!&#39;</span>

<span class="sd">            # Or use index and the provided spatial_index tuple</span>
<span class="sd">            i = 550</span>
<span class="sd">            t = drpf.spatial_index[i]</span>
<span class="sd">            flux_direct = hdu[&#39;FLUX&#39;].data[:,t[0],t[1]]</span>
<span class="sd">            flux_class = drpf.select(i)</span>
<span class="sd">            assert not numpy.any( numpy.absolute(flux_direct - flux_class) &gt; 0 ), \</span>
<span class="sd">                &#39;Selection error!&#39;</span>
<span class="sd">            </span>
<span class="sd">            flux_class = drpf.select(t)</span>
<span class="sd">            assert not numpy.any( numpy.absolute(flux_direct - flux_class) &gt; 0 ), \</span>
<span class="sd">                &#39;Selection error!&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            t (tuple or int) : If an integer, this is the flattened</span>
<span class="sd">                index of the spectrum to return.  If a tuple, this is</span>
<span class="sd">                the position *within the original DRP file* for the</span>
<span class="sd">                non-spectral axes.  See the examples above.</span>
<span class="sd">            ext (str) : (**Optional**) Name of the extension from which</span>
<span class="sd">                to draw the data.  Must be allowed for the current</span>
<span class="sd">                :attr:`mode`; see :attr:`spectral_arrays`.  Default is</span>
<span class="sd">                ``&#39;FLUX&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Vector with the data values as a function of</span>
<span class="sd">            wavelength.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError : Raised if the selected extension cannot be used.</span>
<span class="sd">            ValueError : Raised if the input selection object is not an</span>
<span class="sd">                int or a tuple.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Add select_near function that uses on-sky coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Cannot access </span><span class="si">{0}</span><span class="s1"> extension.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span> <span class="k">else</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dispaxis</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
            <span class="n">_t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;yx&#39;</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">_t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be int or tuple.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">)[</span><span class="n">_t</span><span class="p">,:]</span></div>
        

<span class="c1">#    def wavelength_mask(self, waverange=None, toarray=False):</span>
<span class="c1">#        r&quot;&quot;&quot;</span>
<span class="c1">#        Return a mask boolean array with flags for pixels that fall</span>
<span class="c1">#        within the selected wavelength range.  If no wavelength range is</span>
<span class="c1">#        provided, the function just returns a fully False array with the</span>
<span class="c1">#        correct shape.</span>
<span class="c1">#</span>
<span class="c1">#        .. todo::</span>
<span class="c1">#        </span>
<span class="c1">#            This method is used by other similar objects; see, e.g.,</span>
<span class="c1">#            :class:`mangadap.proc.spatiallybinnedspectra.SpatiallyBinnedSpectra`.</span>
<span class="c1">#</span>
<span class="c1">#            These and other such methods should be pulled out into a</span>
<span class="c1">#            base class that these common classes are derived from.  E.g.</span>
<span class="c1">#            :class:`DAPFitsUtil`?</span>
<span class="c1">#</span>
<span class="c1">#        Args:</span>
<span class="c1">#            waverange (array-like) : (**Optional**) A two-element array</span>
<span class="c1">#                with the minimum and maximum wavelength to include.</span>
<span class="c1">#            toarray (bool) : (**Optional**) Return an array with same</span>
<span class="c1">#                shape as the flux array.  Default is to provide only the</span>
<span class="c1">#                single vector.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            numpy.ndarray: Boolean mask array.</span>
<span class="c1">#</span>
<span class="c1">#        Raises:</span>
<span class="c1">#            ValueError: Raised if the input wavelength range does not</span>
<span class="c1">#                have two elements.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        outshape = self.shape if toarray else (self.nwave,)</span>
<span class="c1">#        if waverange is None:</span>
<span class="c1">#            return numpy.full(outshape, False, dtype=numpy.bool)</span>
<span class="c1">#        if len(waverange) != 2:</span>
<span class="c1">#            raise ValueError(&#39;Input wavelength range must have 2 and only 2 elements!&#39;)</span>
<span class="c1">#</span>
<span class="c1">#        if self.dispaxis is None:</span>
<span class="c1">#            self.dispaxis = len(outshape)-1</span>
<span class="c1">#        _waverange = waverange if waverange[0] &lt; waverange[1] else [waverange[1], waverange[0]]</span>
<span class="c1">#        selected = (self.hdu[&#39;WAVE&#39;].data &lt; _waverange[0]) | (self.hdu[&#39;WAVE&#39;].data &gt; _waverange[1])</span>
<span class="c1">#        return numpy.array([selected]*self.nspec).reshape(outshape) if toarray else selected</span>

    
<div class="viewcode-block" id="DRPFits.copy_to_array"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.copy_to_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_array`</span>
<span class="sd">        specific for :class:`DRPFits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                         <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.copy_to_masked_array"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.copy_to_masked_array">[docs]</a>    <span class="k">def</span> <span class="nf">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for</span>
<span class="sd">        :func:`mangadap.util.fitsutil.DAPFitsUtil.copy_to_masked_array`</span>
<span class="sd">        specific for :class:`DRPFits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAPFitsUtil</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">mask_ext</span><span class="o">=</span><span class="s1">&#39;MASK&#39;</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span>
                                                <span class="n">bitmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="p">,</span>
                                                <span class="n">allowed_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral_arrays</span><span class="p">,</span>
                                                <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.spectral_resolution"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.spectral_resolution">[docs]</a>    <span class="k">def</span> <span class="nf">spectral_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">toarray</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">median</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the spectral resolution at each spatial and spectral</span>
<span class="sd">        position.</span>

<span class="sd">        Select the extension &#39;DISP&#39; or &#39;SPECRES&#39;.  To get the</span>
<span class="sd">        pre-pixelized versions, set pre=True.  If you set the extension</span>
<span class="sd">        to &#39;PREDISP&#39; and pre=True, it will try to find the extension</span>
<span class="sd">        &#39;PREPREDISP&#39; and fault.</span>

<span class="sd">        Args:</span>
<span class="sd">            ext (:obj:`str`, optional):</span>
<span class="sd">                Specify the extension with the spectral estimate to use.</span>
<span class="sd">                Should be in [ None, &#39;DISP&#39;, &#39;SPECRES&#39;].  The default is</span>
<span class="sd">                None, which means it will return, in order of</span>
<span class="sd">                precedence, the data in &#39;DISP&#39;, &#39;SPECRES&#39;, or a None</span>
<span class="sd">                value if neither are present.</span>
<span class="sd">            toarray (:obj:`bool`, optiional):</span>
<span class="sd">                Return the spectral resolution as a 2D array: Nspec x</span>
<span class="sd">                Nwave, even if the DRP file is a CUBE object, similar to</span>
<span class="sd">                :func:`DRPFits.copy_to_array`.  Default is to return an</span>
<span class="sd">                object with the same shape as the flux array.</span>
<span class="sd">            fill (:obj:`bool`, optional):</span>
<span class="sd">                Fill masked values by interpolation.  Default is to</span>
<span class="sd">                leave masked pixels in returned array.</span>
<span class="sd">            pre (:obj:`bool`, optional):</span>
<span class="sd">                Read the pre-pixelized version of the spectral</span>
<span class="sd">                resolution, instead of the post-pixelized version.  This</span>
<span class="sd">                prepends &#39;PRE&#39; to the extension name.</span>
<span class="sd">            median (:obj:`bool`, optional):</span>
<span class="sd">                Return a single vector with the median spectral</span>
<span class="sd">                resolution instead of a per spectrum array.  When using</span>
<span class="sd">                the `SPECRES` extension, this just returns the vector</span>
<span class="sd">                provided by the DRP file; when using the `DISP`</span>
<span class="sd">                extension, this performs a masked median across the</span>
<span class="sd">                array and then interpolates any wavelengths that were</span>
<span class="sd">                masked in all vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `numpy.ma.MaskedArray`_ : Even if interpolated such that</span>
<span class="sd">            there should be not masked values, the function returns a</span>
<span class="sd">            masked array.  Array contains the spectral resolution</span>
<span class="sd">            (:math:`R = \lambda/\Delta\lambda`) pulled from the DRP</span>
<span class="sd">            file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the fits file has been opened</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="c1"># Check the selected base extension exists</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DISP&#39;</span><span class="p">,</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No extension: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="c1"># Set the base extension</span>
        <span class="n">_ext</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;DISP&#39;</span> <span class="k">if</span> <span class="s1">&#39;DISP&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="k">else</span> <span class="s1">&#39;SPECRES&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ext</span>
        <span class="c1"># Add the &#39;PRE&#39; qualifier if requested and check that it exists</span>
        <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No </span><span class="si">{0}</span><span class="s1"> extension in DRP file.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span><span class="p">))</span>
            <span class="n">_ext</span> <span class="o">=</span> <span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span>

        <span class="c1"># Build the spectral resolution vectors</span>
        <span class="n">sres</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;DISP&#39;</span> <span class="ow">in</span> <span class="n">_ext</span><span class="p">:</span>
            <span class="n">disp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy_to_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="n">_ext</span><span class="p">))</span>
            <span class="c1"># Mask any non-positive value</span>
            <span class="n">disp</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">disp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
            <span class="c1"># Convert from sigma in angstroms to spectral resolution</span>
            <span class="c1"># (based on FWHM)</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">DAPConstants</span><span class="o">.</span><span class="n">sig2fwhm</span> <span class="o">*</span> <span class="n">disp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;SPECRES&#39;</span> <span class="ow">in</span> <span class="n">_ext</span><span class="p">:</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">_ext</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="n">median</span>
                                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">_ext</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">]</span> 
                                                            <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)))</span>
            <span class="n">sres</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sres</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Extension </span><span class="si">{0}</span><span class="s1"> invalid.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ext</span><span class="p">))</span>

        <span class="c1"># Interpolate over any masked values</span>
        <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
            <span class="n">outshape</span> <span class="o">=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">interpolate_masked_vector</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                                   <span class="n">sres</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">sres</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                                                        <span class="k">else</span> <span class="n">sres</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">outshape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                                        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">median</span> <span class="ow">and</span> <span class="n">sres</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Determine the median over all spectra if requested and</span>
            <span class="c1"># necessary</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sres</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">toarray</span><span class="p">:</span>
            <span class="c1"># Convert back to datacube format if array format not</span>
            <span class="c1"># requested</span>
            <span class="n">sres</span> <span class="o">=</span> <span class="n">sres</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sres</span></div>


<div class="viewcode-block" id="DRPFits.spectral_resolution_header"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.spectral_resolution_header">[docs]</a>    <span class="k">def</span> <span class="nf">spectral_resolution_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a fits header for the spectral resolution array.  Copies</span>
<span class="sd">        the basic header from the relevant extension in the DRP file.</span>

<span class="sd">        Args:</span>
<span class="sd">            ext (str): (**Optional**) Specify the extension with the</span>
<span class="sd">                spectral estimate to use.  Should be in [ None, &#39;DISP&#39;,</span>
<span class="sd">                &#39;SPECRES&#39;].  The default is None, which means it will</span>
<span class="sd">                return, in order of precedence, the header for &#39;DISP&#39;,</span>
<span class="sd">                &#39;SPECRES&#39;, or an empty header if neither are present.</span>
<span class="sd">            pre (bool): (**Optional**) Read the pre-pixelized version of</span>
<span class="sd">                the spectral resolution, instead of the post-pixelized</span>
<span class="sd">                version.  This prepends &#39;PRE&#39; to the extension name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DISP&#39;</span><span class="p">,</span><span class="s1">&#39;SPECRES&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No extension: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="c1"># Set the extension</span>
        <span class="n">_ext</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;DISP&#39;</span> <span class="k">if</span> <span class="s1">&#39;DISP&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="k">else</span> <span class="s1">&#39;SPECRES&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ext</span>

        <span class="k">if</span> <span class="n">pre</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No </span><span class="si">{0}</span><span class="s1"> extension in DRP file.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span><span class="p">))</span>
            <span class="n">_ext</span> <span class="o">=</span> <span class="s1">&#39;PRE&#39;</span><span class="o">+</span><span class="n">_ext</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">_ext</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
        
<span class="c1">#        if ext in [&#39;DISP&#39;,&#39;SPECRES&#39;] and ext not in self.ext:</span>
<span class="c1">#            raise ValueError(&#39;No extension: {0}&#39;.format(ext))</span>
<span class="c1">#</span>
<span class="c1">#        if ext == &#39;DISP&#39; or (ext is None and &#39;DISP&#39; in self.ext):</span>
<span class="c1">#            return self.hdu[&#39;DISP&#39;].header.copy()</span>
<span class="c1">#        elif ext == &#39;SPECRES&#39; or (ext is None and &#39;SPECRES&#39; in self.ext):</span>
<span class="c1">#            return self.hdu[&#39;SPECRES&#39;].header.copy()</span>
<span class="c1">#        return fits.Header()</span>


<div class="viewcode-block" id="DRPFits.object_data"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.object_data">[docs]</a>    <span class="k">def</span> <span class="nf">object_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the MaNGA ID (&#39;MANGAID&#39;), object right ascension</span>
<span class="sd">        (&#39;OBJRA&#39;), and object declination (&#39;OBJDEC&#39;) taken from the DRP</span>
<span class="sd">        file *primary* header.  The HDUList is opened if hasn&#39;t been</span>
<span class="sd">        already.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str, float, float: MaNGA ID and object RA and DEC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;MANGAID&#39;</span><span class="p">],)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_coo</span><span class="p">()</span></div>


<div class="viewcode-block" id="DRPFits.object_coo"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.object_coo">[docs]</a>    <span class="k">def</span> <span class="nf">object_coo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the object right ascension (&#39;OBJRA&#39;) and declination</span>
<span class="sd">        (&#39;OBJDEC&#39;) taken from the DRP file *primary* header.  The</span>
<span class="sd">        HDUList is opened if hasn&#39;t been already.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Object RA and DEC in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJRA&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="DRPFits.created_today"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.created_today">[docs]</a>    <span class="k">def</span> <span class="nf">created_today</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the file was created today based on its time</span>
<span class="sd">        stamp.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Intended for use at the survey-level for a daily run of the</span>
<span class="sd">            DAP.  Likely not to be used though.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the current time</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>

        <span class="c1"># Last time the DRP file was created (or modified?)</span>
        <span class="n">created_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">gmtime</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getctime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">()))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">current_time</span><span class="o">.</span><span class="n">tm_year</span> <span class="o">==</span> <span class="n">created_time</span><span class="o">.</span><span class="n">tm_year</span> <span class="ow">and</span>
                <span class="n">current_time</span><span class="o">.</span><span class="n">tm_mon</span> <span class="o">==</span> <span class="n">created_time</span><span class="o">.</span><span class="n">tm_mon</span> <span class="ow">and</span> 
                <span class="n">current_time</span><span class="o">.</span><span class="n">tm_mday</span> <span class="o">==</span> <span class="n">created_time</span><span class="o">.</span><span class="n">tm_mday</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.pix_mesh"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.pix_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">pix_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses `numpy.meshgrid`_ to create and return the I and J *pixel*</span>
<span class="sd">        coordinates for an nx*ny mesh.</span>

<span class="sd">        For CUBE files, these dimensions are drawn directly from the WCS</span>
<span class="sd">        keywords in the header of the FLUX extension of the DRP fits</span>
<span class="sd">        file.  In this case, **any entered parameters are ignored and</span>
<span class="sd">        the class attributes are set to the default values used by the</span>
<span class="sd">        DRP**.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The calculation for the CUBE files is only valid if the WCS</span>
<span class="sd">            coordinate system has no rotation.</span>

<span class="sd">        For RSS files, the dimensions are determined using the data in</span>
<span class="sd">        the &#39;XPOS&#39; and &#39;YPOS&#39; extensions and the same algorithm used by</span>
<span class="sd">        the DRP; however, it is possible to provide different parameters</span>
<span class="sd">        that will alter the dimensions.</span>

<span class="sd">        If *extent* is True, the returned mesh is of the pixel *edges*.</span>
<span class="sd">        That is, for a grid of size :math:`N`, there are :math:`N` pixel</span>
<span class="sd">        centers that run from 1 to :math:`N`; however, there are</span>
<span class="sd">        :math:`N+1` pixel edges that run from from :math:`0.5` to</span>
<span class="sd">        :math:`N+0.5`.</span>

<span class="sd">        See: :attr:`pixelscale`, :attr:`recenter`, :attr:`width_buffer`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            extent (bool): (**Optional**) Return a grid of the pixel</span>
<span class="sd">                *edges* instead of the coordinates of the pixel centers.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Two arrays with the pixel indices;</span>
<span class="sd">            `numpy.meshgrid`_ is run using::</span>

<span class="sd">                    indexing=&#39;ij&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions</span><span class="p">(</span><span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> \
                                  <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> \
                              <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.pix_mesh_range"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.pix_mesh_range">[docs]</a>    <span class="k">def</span> <span class="nf">pix_mesh_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the range in x and y of the reconstructed image pixels,</span>
<span class="sd">        including the size of the pixel.  Coordinate :math:`(1,1)` is</span>
<span class="sd">        the center of the first pixel, so its bottom corner is at</span>
<span class="sd">        :math:`(0.5,0.5)`.</span>

<span class="sd">        For CUBE files, these dimensions are drawn directly from the WCS</span>
<span class="sd">        keywords in the header of the FLUX extension of the DRP fits</span>
<span class="sd">        file.  In this case, **any entered parameters are ignored and</span>
<span class="sd">        the class attributes are set to the default values used by the</span>
<span class="sd">        DRP**.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The calculation for the CUBE files is only valid if the WCS</span>
<span class="sd">            coordinate system has no rotation.</span>

<span class="sd">        For RSS files, the dimensions are determined using the data in</span>
<span class="sd">        the &#39;XPOS&#39; and &#39;YPOS&#39; extensions and the same algorithm used by</span>
<span class="sd">        the DRP; however, it is possible to provide different parameters</span>
<span class="sd">        that will alter the dimensions.</span>

<span class="sd">        See: :attr:`pixelscale`, :attr:`recenter`, :attr:`width_buffer`.</span>

<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Two arrays with, respectively, the lower and</span>
<span class="sd">            upper x range and the lower and upper y range.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions</span><span class="p">(</span><span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mf">0.5</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mf">0.5</span><span class="p">])</span></div>


<div class="viewcode-block" id="DRPFits.world_mesh"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.world_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">world_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skyright</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the world X and Y coordinate for the :attr:`nx` by</span>
<span class="sd">        :attr:`ny` mesh of the reconstructed image.  The pixel</span>
<span class="sd">        coordinates are first determined using :func:`pix_mesh` and then</span>
<span class="sd">        converted to the world coordinate system.</span>

<span class="sd">        For &#39;CUBE&#39; files, this is done using the WCS information in the</span>
<span class="sd">        header of the &#39;FLUX&#39; extension.  See :attr:`wcs`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Prior to v1_5_1 of the DRP, this function required a</span>
<span class="sd">            correction to the DRP header because of its use of</span>
<span class="sd">            &#39;degrees&#39;, which does not adhere to the fits standard</span>
<span class="sd">            causing the `astropy.wcs.wcs.WCS`_ to fail when initialized.</span>
<span class="sd">            This call is not longer made.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Make check of DRP version &#39;VERSDRP&#39; to determine if header</span>
<span class="sd">              fix is necessary.</span>

<span class="sd">        For an &#39;RSS&#39; file, the returned mesh is based on the offset in</span>
<span class="sd">        arcseconds as determined by the dimensions of the reconstructed</span>
<span class="sd">        image.  The *skyright* option will force the mesh to have a</span>
<span class="sd">        *decreasing* x coordinate as a function of increasing index.</span>
<span class="sd">        I.e.; the front edge of the first pixel is set to::</span>

<span class="sd">            x0 = self.xs+self.nx*self.pixelscale if skyright else self.xs</span>

<span class="sd">        and the offset per pixel is set to::</span>

<span class="sd">            dx = -self.pixelscale if skyright else self.pixelscale</span>
<span class="sd">        </span>
<span class="sd">        Recall that :attr:`xs` and :attr:`ys` are defined at the</span>
<span class="sd">        bottom-left edge of the first image pixel.</span>

<span class="sd">        Args:</span>
<span class="sd">            skyright (bool): If True, return the mesh with x coordinates</span>
<span class="sd">                *decreasing* as a function of increase index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Two arrays with the world x and y</span>
<span class="sd">            coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
            <span class="c1"># x and y are at the center of the pixel</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pix_mesh</span><span class="p">()</span>
            <span class="c1"># x0 is the front edge of the first pixel if not skyright an</span>
            <span class="c1"># the back edge of the last pixel if skyright</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="k">if</span> <span class="n">skyright</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="k">if</span> <span class="n">skyright</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: Allow this to fix the header if MPL requires it?</span>
<span class="c1">#            self._fix_header()</span>
<span class="c1">#            print(self.hdu[&#39;FLUX&#39;].header)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">,</span><span class="n">fix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">naxis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pix_mesh</span><span class="p">()</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">all_pix2world</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="n">XY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span></div>
<span class="c1">#        print(self.wcs)</span>
<span class="c1">#        print(xy[0:self.nx,0])</span>
<span class="c1">#        print(xy[0:self.nx,1])</span>
<span class="c1">#        print(XY[0:self.nx,0])</span>
<span class="c1">#        print(XY[0:self.nx,1])</span>



<div class="viewcode-block" id="DRPFits.world_mesh_range"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.world_mesh_range">[docs]</a>    <span class="k">def</span> <span class="nf">world_mesh_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skyright</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the range in the world X and Y coordinates including the</span>
<span class="sd">        size of the pixel.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;RSS&#39; files, converts the result of :func:`pix_mesh_range`</span>
<span class="sd">        to world coordinates using the same calculation as in</span>
<span class="sd">        :func:`world_mesh`.</span>

<span class="sd">        For &#39;CUBE&#39; files, converts the result of :func:`pix_mesh` with</span>
<span class="sd">        *extent=True* to world coordinates using the same calculation as</span>
<span class="sd">        in :func:`world_mesh`.  The returned arrays give the range in X</span>
<span class="sd">        and Y respectively.</span>

<span class="sd">        .. warning:: </span>
<span class="sd">            May not be accurate if the reconstructed image has an on-sky</span>
<span class="sd">            rotation.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            skyright (bool): Return the range in X such that the order</span>
<span class="sd">                is [max(X), min(X)] if True; otherwise, values are</span>
<span class="sd">                returned as [min(X), max(X)].</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Two arrays with, respectively, the range in X</span>
<span class="sd">            and Y.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Prior to v1_5_1 of the DRP, this function required a</span>
<span class="sd">            correction to the DRP header because of its use of</span>
<span class="sd">            &#39;degrees&#39;, which does not adhere to the fits standard</span>
<span class="sd">            causing the `astropy.wcs.wcs.WCS`_ to fail when initialized.</span>
<span class="sd">            This call is not longer made.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Make check of DRP version &#39;VERSDRP&#39; to determine if header</span>
<span class="sd">              fix is necessary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
            <span class="c1"># x and y are at the edges of the pixel</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pix_mesh_range</span><span class="p">()</span>
<span class="c1">#            print(x, y)</span>
            <span class="c1"># x0 is the front edge of the first pixel if not skyright an</span>
            <span class="c1"># the back edge of the last pixel if skyright</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="k">if</span> <span class="n">skyright</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="k">if</span> <span class="n">skyright</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span>
<span class="c1">#            print(x0, dx)</span>
<span class="c1">#            print((x-0.5)*dx+x0, (y-0.5)*self.pixelscale+self.ys)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">x0</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="c1">#            self._fix_header()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">,</span><span class="n">fix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">naxis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pix_mesh</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ncoo</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ncoo</span><span class="p">),</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ncoo</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">all_pix2world</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skyright</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])],</span> \
                   <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])]</span> 

        <span class="k">return</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])],</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">XY</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])]</span> </div>


<span class="c1">#    def gri_composite(self):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Return the world coordinates (see :func:`world_mesh`) and flux</span>
<span class="c1">#        in the reconstructed gri image data (in nanomaggies).  The shape</span>
<span class="c1">#        of the Z array is (NX,NY,3), with the g, r, and i image data in</span>
<span class="c1">#        Z[:,:,0], Z[:,:,1], and Z[:,:,2], respectively.</span>
<span class="c1">#</span>
<span class="c1">#        .. warning::</span>
<span class="c1">#            The reconstructed imaging data are not provided as part of</span>
<span class="c1">#            the &#39;RSS&#39; files; three &#39;None&#39;s are returned for &#39;RSS&#39; files.</span>
<span class="c1">#</span>
<span class="c1">#        Returns:</span>
<span class="c1">#            numpy.ndarray: Three arrays with, respectively, the world X,</span>
<span class="c1">#            world Y, and Z.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#        if self.mode == &#39;RSS&#39;:</span>
<span class="c1">#            return None, None, None</span>
<span class="c1">#</span>
<span class="c1">#        X, Y = self.world_mesh() </span>
<span class="c1">#        #X,Y = self.pix_mesh()</span>
<span class="c1">#</span>
<span class="c1">#        Z = numpy.transpose(numpy.array([ self.hdu[&#39;GIMG&#39;].data.T, self.hdu[&#39;RIMG&#39;].data.T, \</span>
<span class="c1">#                            self.hdu[&#39;IIMG&#39;].data.T ] ), axes=(1,2,0))</span>
<span class="c1">#</span>
<span class="c1">#        return X, Y, Z</span>


<div class="viewcode-block" id="DRPFits.regrid_transfer_matrix"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.regrid_transfer_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">regrid_transfer_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rej_flag</span><span class="o">=</span><span class="s1">&#39;3DREJECT&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the transfer matrix used to produce a reconstructed</span>
<span class="sd">        image of the fiber data at the specified wavelength channel.</span>
<span class="sd">        See: :attr:`regrid_T`.</span>

<span class="sd">        For &#39;RSS&#39; files, this is done directly using the available</span>
<span class="sd">        on-sky x and y coordinates of each fiber as a function of</span>
<span class="sd">        wavelength taken from the &#39;XPOS&#39; and &#39;YPOS&#39; extensions.</span>

<span class="sd">        For &#39;CUBE&#39; files, the function will attempt to use the &#39;RSS&#39;</span>
<span class="sd">        counterpart of the file to produce transfer matrix.  In this</span>
<span class="sd">        case, the input parameters *must* be the defaults.</span>

<span class="sd">        The default behavior is to use the same parameters as used by</span>
<span class="sd">        the DRP.  For the defaults, see</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_pixelscale`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_recenter`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_cube_width_buffer`,</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_rlim`, and</span>
<span class="sd">        :func:`mangadap.config.defaults.default_regrid_sigma`.  However,</span>
<span class="sd">        the code allows the parameters to be freely chosen by the user.</span>

<span class="sd">        See: :attr:`pixelscale`, :attr:`recenter`, :attr:`width_buffer`,</span>
<span class="sd">        :attr:`regrid_rlim`, :attr:`regrid_sigma`, :attr:`regrid_T`.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            - Give more detail on the pixels at which the radius is</span>
<span class="sd">              calculated.</span>
<span class="sd">            - The details of this calculation need to be checked against</span>
<span class="sd">              what is done by the DRP:</span>

<span class="sd">                - Are the positions in XPOS sky-right in the sense that</span>
<span class="sd">                  positive XPOS is toward positive RA or not?</span>
<span class="sd">                - Does the DRP rebin the data using a kernel that</span>
<span class="sd">                  defines the coordinate of a pixel at the pixel center</span>
<span class="sd">                  or at the pixel edge?</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The internal data structure of the RSS data is not different</span>
<span class="sd">            from simply reading the fits file using `astropy.io.fits`_.</span>
<span class="sd">            This means you can use this function and apply the result to</span>
<span class="sd">            a separate read of the RSS file (not that you would ever</span>
<span class="sd">            want to do that).  But after doing that, the output will be</span>
<span class="sd">            transposed wrt the CUBE file spatial orientation!  See</span>
<span class="sd">            :func:`regrid_wavelength_plane`.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which</span>
<span class="sd">                to calculate the transfer matrix.</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            `scipy.sparse.csr_matrix`_ : Transfer matrix :math:`{\mathbf</span>
<span class="sd">            T}`</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised for &#39;CUBE&#39; files if the input parameters</span>
<span class="sd">                are not the defaults.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Check if the calculation is necessary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_transfer_undefined</span><span class="p">()</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions_correct</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_transfer_correct</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span>

        <span class="c1"># Allow for calculation for CUBE files under certain conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>

            <span class="c1"># Do not perform the calculation if the parameters are not</span>
            <span class="c1"># the default used by the DRP to create the CUBE file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_defaults</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must use default pixel scale, rlim, and sigma to get transfer &#39;</span>
                                 <span class="o">+</span> <span class="s1">&#39;matrix for DRP-produced CUBE files.&#39;</span><span class="p">)</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Attempting to use RSS counter-part for calculation.&#39;</span><span class="p">)</span>
            <span class="c1"># Get the RSS counterpart</span>
            <span class="n">drpf</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> \
                           <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="c1"># Get the transfer matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">regrid_transfer_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regrid_channel</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">regrid_channel</span>
            <span class="c1"># Save the parameters (should be the defaults)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">pixelscale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regrid_rlim</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">regrid_rlim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regrid_sigma</span> <span class="o">=</span> <span class="n">drpf</span><span class="o">.</span><span class="n">regrid_sigma</span>
            <span class="c1"># Also need to make sure dimensions are set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions</span><span class="p">()</span>
        
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span>

        <span class="c1"># Get the cube dimensions; may not necessarily match DRP calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube_dimensions</span><span class="p">(</span><span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">)</span>

        <span class="c1"># Dimensions of the sparse matrix are</span>
        <span class="n">nim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>                   <span class="c1"># The number of image pixels</span>
        <span class="c1"># by the number of fiber spectra (self.nspec)</span>

        <span class="c1"># Get the list of non-zero pixel values in the transfer matrix</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
        <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>         <span class="c1"># Mesh of i,j pixel indices</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>    <span class="c1"># Holds spectrum index</span>
        <span class="n">ij</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">+</span><span class="n">jj</span><span class="p">)</span>                                        <span class="c1"># Holds image pixel index</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>    <span class="c1"># Holds radii</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>   <span class="c1"># Holds the sum of the weights</span>

        <span class="n">s2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma</span><span class="o">/</span><span class="n">pixelscale</span><span class="p">)</span>                 <span class="c1"># sigma^2 of Gaussian</span>
        <span class="n">rl2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">rlim</span><span class="o">/</span><span class="n">pixelscale</span><span class="p">)</span>                 <span class="c1"># radius^2 of Gaussian limit</span>

        <span class="n">non_zero_spc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>    <span class="c1"># Holds triplet spectrum index</span>
        <span class="n">non_zero_pix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>    <span class="c1"># Holds triplet image index</span>
        <span class="n">non_zero_wgt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># Holds triplet weight</span>

        <span class="c1"># Do not include any pixels with zero inverse variance or pixels</span>
        <span class="c1"># that have been flagged with the provided mask bits</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">channel</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rej_flag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_rej_flag</span> <span class="o">=</span> <span class="n">rej_flag</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rej_flag</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rej_flag</span> <span class="o">!=</span> <span class="s1">&#39;any&#39;</span> <span class="k">else</span> <span class="kc">None</span>
<span class="c1">#            print(&#39;rejected pixels&#39;)</span>
<span class="c1">#            print(numpy.sum(self.bitmask.flagged(self.hdu[&#39;MASK&#39;].data[:,channel],</span>
<span class="c1">#                                                  flag=_rej_flag)))</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitmask</span><span class="o">.</span><span class="n">flagged</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;MASK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">channel</span><span class="p">],</span> <span class="n">flag</span><span class="o">=</span><span class="n">_rej_flag</span><span class="p">)</span>

<span class="c1">#       print(self.xs, self.nx, self.ys, self.ny)</span>

        <span class="c1"># TODO: Can optimize this further</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Fill spectrum index</span>
            <span class="n">sp</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># NOTE: Calculating full matrix is actually faster than</span>
            <span class="c1"># determining submatrix for calculation</span>

            <span class="c1"># Calcuate the distance</span>
            <span class="c1"># ---- WITH RESPECT TO THE EDGE OF THE FIRST PIXEL ----</span>
            <span class="c1">#  - matches DRP, but why?!?!</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;XPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">channel</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span><span class="o">/</span><span class="n">pixelscale</span> <span class="o">-</span> <span class="n">ii</span><span class="p">)</span> \
                 <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;YPOS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">channel</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span><span class="o">/</span><span class="n">pixelscale</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span>
            <span class="c1"># ---- WITH RESPECT TO THE CENTER OF THE FIRST PIXEL ----</span>
<span class="c1">#           r2 = numpy.square( (self.hdu[&#39;XPOS&#39;].data[k,channel]-self.xs)/pixelscale-0.5 - ii) \</span>
<span class="c1">#                + numpy.square((self.hdu[&#39;YPOS&#39;].data[k,channel]-self.ys)/pixelscale-0.5 - jj)</span>

            <span class="c1"># Append new indices and weights within rlim</span>
            <span class="c1"># TODO: Can this be done quicker if I&#39;m not appending things?</span>
            <span class="n">non_zero_spc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_zero_spc</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">r2</span> <span class="o">&lt;</span> <span class="n">rl2</span><span class="p">])</span>
            <span class="n">non_zero_pix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_zero_pix</span><span class="p">,</span> <span class="n">ij</span><span class="p">[</span><span class="n">r2</span> <span class="o">&lt;</span> <span class="n">rl2</span><span class="p">])</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r2</span><span class="p">[</span><span class="n">r2</span> <span class="o">&lt;</span> <span class="n">rl2</span><span class="p">]</span><span class="o">/</span><span class="n">s2</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="n">tot</span><span class="p">[</span><span class="n">r2</span><span class="o">&lt;</span><span class="n">rl2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wgt</span>
            <span class="n">non_zero_wgt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">non_zero_wgt</span><span class="p">,</span> <span class="n">wgt</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Transfer Matrix </span><span class="si">{:2.1%}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Transfer Matrix Done                     &#39;</span><span class="p">)</span>

        <span class="c1"># Save the regridding input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_rlim</span> <span class="o">=</span> <span class="n">rlim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">pixelscale</span>

        <span class="c1"># Normalize the result and scale by the pixel size to ensure the</span>
        <span class="c1"># output cube is in units of calibrated flux density per pixel</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">pixelscale</span><span class="o">*</span><span class="n">pixelscale</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">non_zero_wgt</span> <span class="o">*=</span> <span class="n">scale</span><span class="o">/</span><span class="n">tot</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">non_zero_pix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">))]</span>

        <span class="c1"># Set the transfer matrix to a sparse object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span> <span class="p">(</span><span class="n">non_zero_wgt</span><span class="p">,</span> <span class="p">(</span><span class="n">non_zero_pix</span><span class="p">,</span> <span class="n">non_zero_spc</span><span class="p">)),</span> \
                                                   <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c1"># Return the transfer matrix</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span></div>


<div class="viewcode-block" id="DRPFits.regrid_wavelength_plane"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.regrid_wavelength_plane">[docs]</a>    <span class="k">def</span> <span class="nf">regrid_wavelength_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_ivar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_covar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reconstructed image for the specified wavelength</span>
<span class="sd">        channel.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;CUBE&#39; files, the input parameters *must* be the same as the</span>
<span class="sd">        defaults.  If they are, the function simply returns the selected</span>
<span class="sd">        2D array from the &#39;FLUX&#39; extension.</span>

<span class="sd">        For &#39;RSS&#39; files, the transfer matrix is first calculated using</span>
<span class="sd">        :func:`regrid_transfer_matrix` and then used to calculate:</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            {\mathbf T} \times {\mathbf F} = {\mathbf I}</span>

<span class="sd">        where :math:`{\mathbf F}` is the vector of fluxes in the</span>
<span class="sd">        selected wavelength channel for all the fiber measurements in</span>
<span class="sd">        the field of view and :math:`{\mathbf I}` is the pre-formatted</span>
<span class="sd">        (flattened) reconstructed image of that wavelength channel.</span>

<span class="sd">        **On output, :math:`{\mathbf I}` is rearranged into a 2D array</span>
<span class="sd">        of size :attr:`nx` by :attr:`ny`.**</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Because the internal data structure is transposed with</span>
<span class="sd">            respect to the DRP file, the result is transposed on output</span>
<span class="sd">            so that it will match the similar operation done directly on</span>
<span class="sd">            a DRP file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which</span>
<span class="sd">                to calculate the transfer matrix.</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>
<span class="sd">            return_ivar (bool): (**Optional**) Return the nominal</span>
<span class="sd">                inverse variance image (i.e. the diagonal of the</span>
<span class="sd">                covariance matrix).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The reconstructed image for the specified</span>
<span class="sd">            wavelength channel.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: Raised for &#39;CUBE&#39; files when the input parameters</span>
<span class="sd">                are not the same as the defaults.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Allow CUBE output under certain conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>

            <span class="c1"># Do not perform the calculation if the parameters are not</span>
            <span class="c1"># the default used by the DRP to create the CUBE file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_defaults</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must use default pixel scale, rlim, and sigma to get &#39;</span>
                                 <span class="o">+</span> <span class="s1">&#39;wavelength-channel image for DRP-produced CUBE files.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set the transfer matrix (set to self.regrid_T; don&#39;t need to</span>
        <span class="c1"># keep the returned matrix)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_transfer_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">quiet</span><span class="p">)</span>

        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;FLUX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">channel</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span>
        <span class="c1"># Return the regridded data with the proper shape (nx by ny)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ivar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flux</span>

        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span>
                                               <span class="n">sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_covar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flux</span><span class="p">,</span> <span class="n">covar</span>
            
        <span class="k">return</span> <span class="n">flux</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">covar</span><span class="o">.</span><span class="n">toarray</span><span class="p">()),</span> \
                                    <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits._formal_covariance_matrix"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._formal_covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">_formal_covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                  <span class="n">csr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formal covariance matrix as defined by</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">             {\mathbf C} = {\mathbf T} \times {\mathbf \Sigma} \times</span>
<span class="sd">             {\mathbf T}^{\rm T},</span>

<span class="sd">        where :math:`{\mathbf \Sigma}` is the covariance matrix for the</span>
<span class="sd">        &#39;RSS&#39; spectra for the specified wavelength channel.  For &#39;CUBE&#39;</span>
<span class="sd">        files, the function will attempt to use the &#39;RSS&#39; counterpart of</span>
<span class="sd">        the file to produce the transfer matrix, :math:`{\mathbf T}`.</span>
<span class="sd">        In this case, the input parameters *must* be the defaults.</span>

<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            The current DRP does not produce spectral covariance</span>
<span class="sd">            matrices for the &#39;RSS&#39; spectra.  Here, it is assumed that</span>
<span class="sd">            the spectral covariance matrix is zero everywhere except</span>
<span class="sd">            along the diagonal, which contains the inverse of the values</span>
<span class="sd">            in the &#39;IVAR&#39; extension.</span>

<span class="sd">        The use of this function should **not** be used with the &#39;CUBE&#39;</span>
<span class="sd">        files for efficiency sake.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which to</span>
<span class="sd">                calculate the transfer matrix.</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            recenter (bool): Flag to recenter the coordinate system</span>
<span class="sd">            width_buffer (int): Number of pixels to use as buffer for</span>
<span class="sd">                the image reconstruction</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>
<span class="sd">            csr (bool): (**Optional**) Instead of reaturning a</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object,</span>
<span class="sd">                return the covariance matrix as a</span>
<span class="sd">                `scipy.sparse.csr_matrix`_ object.  Primarily used by</span>
<span class="sd">                :func:`covariance_cube` for collating the covariance</span>
<span class="sd">                matrix of each wavelength channel before combining them</span>
<span class="sd">                into a single</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`mangadap.util.covariance.Covariance` or</span>
<span class="sd">            `scipy.sparse.csr_matrix`_: The covariance matrix for the</span>
<span class="sd">            designated wavelength channel.  The return type depends on</span>
<span class="sd">            *csr*.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised for &#39;CUBE&#39; files when the input</span>
<span class="sd">                parameters are not the same as the defaults.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allow CUBE output under certain conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>

            <span class="c1"># Do not perform the calculation if the parameters are not</span>
            <span class="c1"># the default used by the DRP to create the CUBE file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_defaults</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must use default pixel scale, rlim, and sigma to get &#39;</span>
                                 <span class="o">+</span> <span class="s1">&#39;covariance matrices for DRP-produced CUBE files.&#39;</span><span class="p">)</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Attempting to use RSS counter-part for calculation.&#39;</span><span class="p">)</span>
            <span class="n">drpf</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> \
                           <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">drpf</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span>
                                          <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="o">=</span><span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                                          <span class="n">csr</span><span class="o">=</span><span class="n">csr</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Set the transfer matrix (set to self.regrid_T; don&#39;t need</span>
        <span class="c1"># to keep the returned matrix)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_transfer_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span>
                                    <span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Get the variance values, ignoring those that are &lt;= 0</span>
<span class="c1">#        var = numpy.zeros(self.nspec, dtype=numpy.float64)</span>
<span class="c1">#        indx = numpy.where(self.hdu[&#39;IVAR&#39;].data[:,channel] &gt; 0.)</span>
<span class="c1">#        var[indx] = 1.0/self.hdu[&#39;IVAR&#39;].data[indx,channel]</span>

        <span class="c1"># TODO: Change to using Covariance.from_matrix_multiplication</span>

        <span class="c1"># Set the covariance matrix of the spectra to be a diagonal</span>
        <span class="c1"># matrix with the provided variances</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">channel</span><span class="p">],</span>
                                                  <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))),</span> \
                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspec</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c1"># Return the covariance matrix from the spatial rebinning</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sigma</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span><span class="o">.</span><span class="n">transpose</span><span class="p">())))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">csr</span> <span class="k">else</span> <span class="n">C</span></div>


<div class="viewcode-block" id="DRPFits._approximate_covariance_matrix"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._approximate_covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">_approximate_covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span>
                                       <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an approximate calculation of the covariance matrix</span>
<span class="sd">        assuming</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>

<span class="sd">            C_{ij} = \frac{\rho_{ij}}{(V^{-1}_{ii} V^{-1}_{jj})^{1/2}}</span>
<span class="sd">            </span>
<span class="sd">        where :math:`\rho_{ij}` is approximated by a Gaussian with a</span>
<span class="sd">        standard deviation defined by the provided *sigma_rho*.  See the</span>
<span class="sd">        description of attributes :attr:`cov_rho` and :attr:`sigma_rho`.</span>
<span class="sd">        For this to work, the variance matrix of the reconstructed image</span>
<span class="sd">        must have been already calculated, meaning that this approach is</span>
<span class="sd">        most appropriately used with the &#39;CUBE&#39; files.  For &#39;RSS&#39; files,</span>
<span class="sd">        the covariance matrix is determined in this case by calling</span>
<span class="sd">        :func:`covariance_matrix` on the &#39;CUBE&#39; file, which will raise</span>
<span class="sd">        an exception if the parameters defining the dimensions of the</span>
<span class="sd">        reconstructed image and kernel are not the defaults.</span>

<span class="sd">        In general, this function should **not** be used with &#39;RSS&#39;</span>
<span class="sd">        files for efficiency sake.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which to</span>
<span class="sd">                calculate the transfer matrix.</span>
<span class="sd">            pixelscale (float): Desired pixel scale in arcsec</span>
<span class="sd">            recenter (bool): Flag to recenter the coordinate system</span>
<span class="sd">            width_buffer (int): Number of pixels to use as buffer for</span>
<span class="sd">                the image reconstruction</span>
<span class="sd">            rlim (float): The limiting radius of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): The sigma of the image reconstruction kernel</span>
<span class="sd">                in arcseconds.</span>
<span class="sd">            sigma_rho (float): The sigma of the Gaussian function used</span>
<span class="sd">                to approximate the trend of the correlation coefficient</span>
<span class="sd">                with pixel separation.</span>
<span class="sd">            csr (bool): (**Optional**) Instead of reaturning a</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object,</span>
<span class="sd">                return the covariance matrix as a</span>
<span class="sd">                `scipy.sparse.csr_matrix`_ object.  Primarily used by</span>
<span class="sd">                :func:`covariance_cube` for collating the covariance</span>
<span class="sd">                matrix of each wavelength channel before combining them</span>
<span class="sd">                into a single</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`mangadap.util.covariance.Covariance` or</span>
<span class="sd">            `scipy.sparse.csr_matrix`_: The covariance matrix for the</span>
<span class="sd">            designated wavelength channel.  The return type depends on</span>
<span class="sd">            `csr`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised for &#39;CUBE&#39; files when the input</span>
<span class="sd">                parameters are not the same as the defaults.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Allow to process RSS if necessary, but warn user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Attempting to use CUBE counter-part for calculation.&#39;</span><span class="p">)</span>
            <span class="n">drpf</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> \
                           <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">drpf</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span>
                                          <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">csr</span><span class="p">,</span> <span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Get the variance correlation (rho) matrix (returns</span>
        <span class="c1"># existing matrix if available for same parameters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_variance_correlation</span><span class="p">(</span><span class="n">sigma_rho</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="n">recenter</span><span class="p">,</span>
                                       <span class="n">width_buffer</span><span class="o">=</span><span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="o">=</span><span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Get the non-zero elements</span>
        <span class="n">ci</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_rho</span><span class="p">)</span>

        <span class="c1"># Get the cube pixels</span>
        <span class="n">i_i</span> <span class="o">=</span> <span class="n">ci</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
        <span class="n">i_j</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-</span><span class="n">i_i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
        <span class="n">j_i</span> <span class="o">=</span> <span class="n">cj</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
        <span class="n">j_j</span> <span class="o">=</span> <span class="n">cj</span><span class="o">-</span><span class="n">j_i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span>

        <span class="c1"># Use the available inverse variance cube to approximately</span>
        <span class="c1"># calculate the full covariance matrix</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i_i</span><span class="p">,</span><span class="n">i_j</span><span class="p">,</span><span class="n">channel</span><span class="p">]</span>
                         <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="s1">&#39;IVAR&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">j_i</span><span class="p">,</span><span class="n">j_j</span><span class="p">,</span><span class="n">channel</span><span class="p">])</span>
        <span class="n">cov</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cov</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cov</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">ci</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">cj</span><span class="p">[</span><span class="n">cov</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])),</span> 
                              <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">csr</span> <span class="k">else</span> <span class="n">C</span></div>


<div class="viewcode-block" id="DRPFits._interpolated_response_function"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._interpolated_response_function">[docs]</a>    <span class="k">def</span> <span class="nf">_interpolated_response_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response_func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">response_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">response_func</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">response_func</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits._covariance_wavelength"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits._covariance_wavelength">[docs]</a>    <span class="k">def</span> <span class="nf">_covariance_wavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">response_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the wavelength at which to calculate the covariance</span>
<span class="sd">        matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            waverange (array-like): (**Optional**) Starting and ending</span>
<span class="sd">                wavelength over which to calculate the statistics.</span>
<span class="sd">                Default is to use the full wavelength range.</span>
<span class="sd">            response_func (array-like): (**Optional**) A two-column</span>
<span class="sd">                array with the wavelength and transmission of a</span>
<span class="sd">                broad-band response function to use for the calculation.</span>
<span class="sd">            per_pixel (bool): (**Optional**) When providing a response</span>
<span class="sd">                function, continue to calculate the statistics per</span>
<span class="sd">                pixel, as opposed to per angstrom.  Default is to</span>
<span class="sd">                compute the statistics on a per pixel basis.</span>
<span class="sd">            flag (str or list): (**Optional**) (List of) Flag names that</span>
<span class="sd">                are considered when deciding if a pixel should be</span>
<span class="sd">                masked.  The names *must* be a valid bit name as defined</span>
<span class="sd">                by :attr:`bitmask` (see :class:`DRPFitsBitMask`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The response-weighted center of the wavelength region</span>
<span class="sd">            used to calculate the S/N, which will be where the</span>
<span class="sd">            covariance matrix is calculated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">waverange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">response_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span>

        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

        <span class="n">dw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">per_pixel</span> <span class="k">else</span> \
                    <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span><span class="o">*</span><span class="n">wave</span>

        <span class="n">_response_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolated_response_function</span><span class="p">(</span><span class="n">response_func</span><span class="p">)</span>
        <span class="n">response_integral</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
                                        <span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
                                                <span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">*</span> <span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span>
                                                       <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">response_integral</span><span class="p">))</span></div>


<div class="viewcode-block" id="DRPFits.covariance_matrix"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.covariance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">covariance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                          <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the covariance matrix for the specified wavelength</span>
<span class="sd">        channel.</span>

<span class="sd">        For a regrided cube image with :math:`N_x\times N_y` pixels, the</span>
<span class="sd">        covariance matrix has a size that is :math:`(N_x N_y)\times (N_x</span>
<span class="sd">        N_y)`; however, the majority of these pixels will be zero.</span>
<span class="sd">        Therefore, the covariance matrix is stored as a sparse matrix</span>
<span class="sd">        and interfaced with using the</span>
<span class="sd">        :class:`mangadap.util.covariance.Covariance` object class.</span>

<span class="sd">        The value of the covariance matrix at pixel :math:`(i,j)` is the</span>
<span class="sd">        covariance between pixels :math:`(n_{x,0},n_{y,0})` and</span>
<span class="sd">        :math:`(n_{x,1},n_{y,1})` at the specified wavelength channel of</span>
<span class="sd">        the reconstructed CUBE image, where</span>

<span class="sd">        .. math::</span>

<span class="sd">            n_{x,0} &amp;= \lfloor i / N_y \rfloor \\</span>
<span class="sd">            n_{y,0} &amp;= i - n_{x,0} N_y \\</span>
<span class="sd">            n_{x,1} &amp;= \lfloor j / N_y \rfloor \\</span>
<span class="sd">            n_{y,1} &amp;= j - n_{x,1} N_y</span>

<span class="sd">        and :math:`\lfloor m\rfloor` is the &quot;floor&quot; of :math:`m`.  The</span>
<span class="sd">        diagonal of the covariance matrix (:math:`i=j`) should directly</span>
<span class="sd">        provide the inverse of the IVAR values provided by the DRP.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            THIS IS IMPORTANT.  Because the sense of the pixel</span>
<span class="sd">            coordinates, :math:`(n_x,n_y)`, is flipped with respect to a</span>
<span class="sd">            direct read of the DRP fits file using `astropy.io.fits`_,</span>
<span class="sd">            it is important that you appreciate this ordering in</span>
<span class="sd">            handling the coordinates in the output covariance matrix</span>
<span class="sd">            using the equation above.  I.e., if you want to get the</span>
<span class="sd">            covariance between two pixels in the DRP file, make sure you</span>
<span class="sd">            understand which is the :math:`x` pixel and which is the</span>
<span class="sd">            :math:`y` pixel!</span>

<span class="sd">        You can compare the CUBE provide inverse variance matrix and the</span>
<span class="sd">        inverse variance matrix provided along the diagonal of a</span>
<span class="sd">        covariance matrix calculated using this function as follows::</span>

<span class="sd">            from matplotlib import pyplot</span>
<span class="sd">            from mangadap.drpfits import DRPFits</span>
<span class="sd">            from astropy.io import fits</span>

<span class="sd">            drpf = DRPFits(7495, 3701, &#39;CUBE&#39;, read=False)</span>
<span class="sd">            hdu = fits.open(drpf.file_path())</span>
<span class="sd">            drpf = DRPFits(7495, 3701, &#39;RSS&#39;, read=True)</span>

<span class="sd">            channel = 2000</span>
<span class="sd">            C = drpf.covariance_matrix(channel)</span>

<span class="sd">            ivar = numpy.diag(C.toarray()).reshape(-1, \</span>
<span class="sd">                                    numpy.sqrt(C.shape[0])).T.copy()</span>
<span class="sd">            indx = ivar &gt; 0</span>
<span class="sd">            ivar[indx] = 1./ivar[indx]</span>
<span class="sd">            ivar[numpy.invert(indx)] = 0.</span>

<span class="sd">            fig = pyplot.figure(figsize=(pyplot.figaspect(1)))</span>
<span class="sd">            ax = fig.add_axes([0.05, 0.3, 0.35, 0.35])</span>
<span class="sd">            ax.imshow(ivar, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;,</span>
<span class="sd">                      cmap=&#39;inferno&#39;, aspect=&#39;auto&#39;)</span>
<span class="sd">            ax.set_title(&#39;regrid&#39;)</span>
<span class="sd">            ax = fig.add_axes([0.5, 0.3, 0.35, 0.35])</span>
<span class="sd">            cax = fig.add_axes([0.86, 0.3, 0.01, 0.35])</span>
<span class="sd">            ax.set_title(&#39;DRP&#39;)</span>
<span class="sd">            cs = ax.imshow(hdu[&#39;IVAR&#39;].data[channel,:,:], origin=&#39;lower&#39;,</span>
<span class="sd">                           interpolation=&#39;nearest&#39;, cmap=&#39;inferno&#39;)</span>
<span class="sd">            pyplot.colorbar(cs, cax=cax)</span>
<span class="sd">            pyplot.show()</span>

<span class="sd">        Differences between the inverse variance values should be small</span>
<span class="sd">        (:math:`\approx 10^{-3}`, which is about 1 part in</span>
<span class="sd">        :math:`10^7`).</span>

<span class="sd">        The covariance matrix can be generated in one of two ways:</span>

<span class="sd">        1. If *sigma_rho* is None, the returned matrix is the formal</span>
<span class="sd">        covariance matrix defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">             {\mathbf C} = {\mathbf T} \times {\mathbf \Sigma} \times</span>
<span class="sd">             {\mathbf T}^{\rm T},</span>

<span class="sd">        where :math:`{\mathbf \Sigma}` is the covariance matrix for the</span>
<span class="sd">        &#39;RSS&#39; spectra for the specified wavelength channel.  For &#39;CUBE&#39;</span>
<span class="sd">        files, the function will attempt to use the &#39;RSS&#39; counterpart of</span>
<span class="sd">        the file to produce the transfer matrix, :math:`{\mathbf T}`.</span>
<span class="sd">        In this case, the input parameters *must* be the defaults.</span>

<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            The current DRP does not produce spectral covariance</span>
<span class="sd">            matrices for the &#39;RSS&#39; spectra.  Here, it is assumed that</span>
<span class="sd">            the spectral covariance matrix is zero everywhere except</span>
<span class="sd">            along the diagonal, which contains the inverse of the values</span>
<span class="sd">            in the &#39;IVAR&#39; extension.</span>

<span class="sd">        2. If *sigma_rho* is not None, the returned matrix is an</span>
<span class="sd">        approximation of the covariance matrix determined by</span>
<span class="sd">        *sigma_rho*.  See the description of :attr:`cov_rho` and</span>
<span class="sd">        :attr:`sigma_rho`.  For this to work, the variance matrix of the</span>
<span class="sd">        reconstructed image must have been already calculated, meaning</span>
<span class="sd">        that this approach is most appropriately used with the &#39;CUBE&#39;</span>
<span class="sd">        files.  For &#39;RSS&#39; files, the covariance matrix is determined in</span>
<span class="sd">        this case by calling :func:`covariance_matrix` on the &#39;CUBE&#39;</span>
<span class="sd">        file, which will raise an exception if the parameters defining</span>
<span class="sd">        the dimensions of the reconstructed image and kernel are not the</span>
<span class="sd">        defaults.</span>

<span class="sd">        In general, use of *sigma_rho* should **not** be used with &#39;RSS&#39;</span>
<span class="sd">        files and the use of the formal calculation should **not** be</span>
<span class="sd">        used with the &#39;CUBE&#39; files for efficiency.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which</span>
<span class="sd">                to calculate the transfer matrix.</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma_rho (float): (**Optional**) The sigma of the Gaussian</span>
<span class="sd">                function used to approximate the trend of the</span>
<span class="sd">                correlation coefficient with pixel separation.</span>
<span class="sd">            csr (bool): (**Optional**) Instead of reaturning a</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object,</span>
<span class="sd">                return the covariance matrix as a</span>
<span class="sd">                `scipy.sparse.csr_matrix`_ object.  Primarily used by</span>
<span class="sd">                :func:`covariance_cube` for collating the covariance</span>
<span class="sd">                matrix of each wavelength channel before combining them</span>
<span class="sd">                into a single</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`mangadap.util.covariance.Covariance` or</span>
<span class="sd">            `scipy.sparse.csr_matrix`_: The covariance matrix for the</span>
<span class="sd">            designated wavelength channel.  The return type depends on</span>
<span class="sd">            `csr`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised for &#39;CUBE&#39; files when the input</span>
<span class="sd">                parameters are not the same as the defaults.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Need to make sure that the correct masks are being used for</span>
<span class="sd">            the RSS files.  Should be 3DREJECT but nothing else?</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formal_covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span>
                                               <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="n">csr</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span> \
               <span class="k">if</span> <span class="n">sigma_rho</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">_approximate_covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span>
                                                    <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="n">csr</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.covariance_cube"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.covariance_cube">[docs]</a>    <span class="k">def</span> <span class="nf">covariance_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the covariance matrices for all wavelength channels; see</span>
<span class="sd">        :func:`covariance_matrix`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma_rho (float): (**Optional**) The sigma of the Gaussian</span>
<span class="sd">                function used to approximate the trend of the</span>
<span class="sd">                correlation coefficient with pixel separation.</span>
<span class="sd">            csr (bool): (**Optional**) Instead of reaturning a</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object,</span>
<span class="sd">                return a numpy.ndarray of the covariance matrices for</span>
<span class="sd">                each channel, which are `scipy.sparse.csr_matrix`_</span>
<span class="sd">                objects.  Primarily used by :func:`covariance_cube` for</span>
<span class="sd">                collating the covariance matrix of each wavelength</span>
<span class="sd">                channel before combining them into a single</span>
<span class="sd">                :class:`mangadap.util.covariance.Covariance` object</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`mangadap.util.covariance.Covariance` or</span>
<span class="sd">            numpy.ndarray: The return type depends on `csr`: if True,</span>
<span class="sd">            the returned object is an ndarray of</span>
<span class="sd">            `scipy.sparse.csr_matrix`_ types.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: Raised for &#39;CUBE&#39; files when the input parameters</span>
<span class="sd">                are not the same as the defaults.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Allow CUBE output under certain conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>

            <span class="c1"># Do not perform the calculation if the parameters are not</span>
            <span class="c1"># the default used by the DRP to create the CUBE file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_defaults</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must use default pixel scale, rlim, and sigma to get &#39;</span>
                                <span class="o">+</span> <span class="s1">&#39;covariance matrices for DRP-produced CUBE files.&#39;</span><span class="p">)</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Attempting to use RSS counter-part for calculation.&#39;</span><span class="p">)</span>
            <span class="n">drpf</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> \
                           <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">drpf</span><span class="o">.</span><span class="n">covariance_cube</span><span class="p">(</span><span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="o">=</span><span class="n">sigma_rho</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="n">csr</span><span class="p">,</span>
                                        <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checksum</span><span class="p">)</span>

        <span class="c1"># The number of wavelength channels</span>
        <span class="n">_channels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">)</span> <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>

        <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_channels</span><span class="p">)</span>
        <span class="n">CovCube</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">)</span>   <span class="c1"># Empty ndarray</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance Cube </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nc</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">CovCube</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">_channels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span>
                                                <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma_rho</span><span class="p">,</span> <span class="n">csr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance Cube Done                     &#39;</span><span class="p">)</span>

        <span class="c1"># Don&#39;t provide input indices if the full cube is calculated</span>
        <span class="k">return</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">CovCube</span><span class="p">,</span> <span class="n">input_indx</span><span class="o">=</span><span class="n">_channels</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">csr</span> <span class="k">else</span> <span class="n">CovCube</span></div>


<div class="viewcode-block" id="DRPFits.instrumental_dispersion_plane"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.instrumental_dispersion_plane">[docs]</a>    <span class="k">def</span> <span class="nf">instrumental_dispersion_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">dispersion_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixelscale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">recenter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">pre</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the instrumental dispersion for the reconstructed &#39;CUBE&#39;</span>
<span class="sd">        wavelength plane.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;CUBE&#39; files, the input parameters *must* be the same as the</span>
<span class="sd">        defaults.  If they are, the function must be able to find and</span>
<span class="sd">        access the &#39;RSS&#39; file to construct the instrumental dispersion</span>
<span class="sd">        map because the necessary information is not in the &#39;CUBE&#39;</span>
<span class="sd">        files (before MPL-6).</span>

<span class="sd">        .. todo::</span>
<span class="sd">            - Need to implement something that will recognize that the</span>
<span class="sd">              &#39;DISP&#39; extension exists in the MPL-6 and later DRP CUBE</span>
<span class="sd">              files.</span>
<span class="sd">        </span>
<span class="sd">        For &#39;RSS&#39; files, the transfer matrix, :math:`{\mathbf T}`, is</span>
<span class="sd">        first calculated using :func:`regrid_transfer_matrix`.  The</span>
<span class="sd">        transfer matrix is used to construct the &#39;CUBE&#39; wavelength plane</span>
<span class="sd">        image, :math:`{\mathbf I}`, by computing :math:`{\mathbf T}</span>
<span class="sd">        \times {\mathbf F} = {\mathbf I}`, where :math:`{\mathbf F}` is</span>
<span class="sd">        the vector of the fiber fluxes.  Under the assumption that the</span>
<span class="sd">        line-spread-function (LSF) is Gaussian, we determine the</span>
<span class="sd">        instrumental dispersion for the data in the wavelength channel</span>
<span class="sd">        of the reconstructed CUBE by calculating the second moment of</span>
<span class="sd">        the weighted sum of Gaussians of the appropriate dispersion.</span>
<span class="sd">        Assuming all the Gaussians have the normalized form:</span>

<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \mathcal{N}(x|\mu=0,\sigma) = \frac{1}{\sqrt{2\pi}\sigma}</span>
<span class="sd">            \exp\left(-\frac{x^2}{2\sigma^2}\right),</span>

<span class="sd">        the combined instrumental dispersion becomes</span>

<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \sigma_{\rm inst,j}^2 = \frac{\sum_i T_{ij}</span>
<span class="sd">            \sigma^2_i}{\sum_i T_{ij}},</span>

<span class="sd">        where :math:`T_{ij}` are the elements of the transfer matrix.</span>
<span class="sd">        In terms of matrix multiplications, this can be written as</span>

<span class="sd">        .. math::</span>

<span class="sd">            {\mathbf S} = \frac{ {\mathbf T} \times {\mathbf V} }{</span>
<span class="sd">            {\mathbf T_c} },</span>

<span class="sd">        where :math:`{\mathbf T_c} = {\mathbf T_c} \times {\mathbf 1}`</span>
<span class="sd">        is the vector with the sum :math:`\sum_j T_{ij}`,</span>
<span class="sd">        :math:`{\mathbf V}` is the instrumental variance for all fibers</span>
<span class="sd">        at the designated wavelength plane, and :math:`{\mathbf S}` is</span>
<span class="sd">        the variance for all the spaxels in the reconstructed wavelength</span>
<span class="sd">        image; the division by :math:`{\mathbf T_c}` is element-wise.</span>

<span class="sd">        The returned matrix is the element-wise square-root of</span>
<span class="sd">        :math:`{\mathbf S}`, rearranged into a 2D array of size</span>
<span class="sd">        :attr:`ny` by :attr:`nx`.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Because the internal data structure is transposed with</span>
<span class="sd">            respect to the DRP file, the result is transposed on output</span>
<span class="sd">            so that it will match the pixel coordinates in the</span>
<span class="sd">            reconstructed image pulled directly from a DRP file.  See</span>
<span class="sd">            :func:`regrid_wavelength_channel`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channel (int): Index of the spectral channel for which to</span>
<span class="sd">                calculate the transfer matrix.</span>
<span class="sd">            dispersion_factor (float): (**Optional**) Artificially</span>
<span class="sd">                multiply the dispersion measurements by this factor</span>
<span class="sd">                before calculating the reconstructed dispersion.</span>
<span class="sd">            pixelscale (float): (**Optional**) Desired pixel scale in</span>
<span class="sd">                arcsec</span>
<span class="sd">            recenter (bool): (**Optional**) Flag to recenter the</span>
<span class="sd">                coordinate system</span>
<span class="sd">            width_buffer (int): (**Optional**) Number of pixels to use</span>
<span class="sd">                as buffer for the image reconstruction</span>
<span class="sd">            rlim (float): (**Optional**) The limiting radius of the</span>
<span class="sd">                image reconstruction kernel in arcseconds.</span>
<span class="sd">            sigma (float): (**Optional**) The sigma of the image</span>
<span class="sd">                reconstruction kernel in arcseconds.</span>
<span class="sd">            pre (bool): (**Optional**) Read the pre-pixelized version of</span>
<span class="sd">                the spectral resolution, instead of the post-pixelized</span>
<span class="sd">                version.  This prepends &#39;PRE&#39; to the extension name.</span>
<span class="sd">            quiet (bool): (**Optional**) Suppress terminal output</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The reconstructed image for the specified</span>
<span class="sd">            wavelength channel.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised for &#39;CUBE&#39; files when the input parameters</span>
<span class="sd">                are not the same as the defaults.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the default values for the input</span>
        <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_regrid_pars</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Allow CUBE output under certain conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>

            <span class="c1"># Do not perform the calculation if the parameters are not</span>
            <span class="c1"># the default used by the DRP to create the CUBE file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid_defaults</span><span class="p">(</span><span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must use default pixel scale, rlim, and sigma to get &#39;</span>
                                 <span class="o">+</span> <span class="s1">&#39;wavelength-channel image for DRP-produced CUBE files.&#39;</span><span class="p">)</span>

            <span class="n">drpf</span> <span class="o">=</span> <span class="n">DRPFits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifudesign</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">,</span> <span class="n">drpver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drpver</span><span class="p">,</span> \
                           <span class="n">redux_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">redux_path</span><span class="p">,</span> <span class="n">directory_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">drpf</span><span class="o">.</span><span class="n">instrumental_dispersion_plane</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">dispersion_factor</span><span class="o">=</span><span class="n">dispersion_factor</span><span class="p">,</span>
                                                      <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Set the transfer matrix (set to self.regrid_T; don&#39;t need to</span>
        <span class="c1"># keep the returned matrix)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regrid_transfer_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">pixelscale</span><span class="p">,</span> <span class="n">recenter</span><span class="p">,</span> <span class="n">width_buffer</span><span class="p">,</span> <span class="n">rlim</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">quiet</span><span class="p">)</span>

        <span class="c1"># Get the dispersion factor</span>
        <span class="n">_df</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">dispersion_factor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dispersion_factor</span>

        <span class="c1"># Return the regridded data with the proper shape (nx by ny)</span>
        <span class="n">Tc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">Tc</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">Tc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>                <span class="c1"># Control for zeros</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;PREDISP&#39;</span> <span class="k">if</span> <span class="n">pre</span> <span class="k">else</span> <span class="s1">&#39;DISP&#39;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">regrid_T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_df</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">channel</span><span class="p">]))</span>
                                                <span class="o">/</span> <span class="n">Tc</span> <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.pointing_offset"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.pointing_offset">[docs]</a>    <span class="k">def</span> <span class="nf">pointing_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the offsets in RA and DEC between the pointing</span>
<span class="sd">        coordinates (IFURA, IFUDEC) and the designated object center</span>
<span class="sd">        coordinates (OBJRA, OBJDEC), drawn from the primary header of</span>
<span class="sd">        the DRP fits file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Sky-right arcsecond offsets in RA and DEC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;IFURA&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJRA&#39;</span><span class="p">])</span> \
                    <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">]))</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">),</span> \
               <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;IFUDEC&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">)</span></div>


<div class="viewcode-block" id="DRPFits.mean_sky_coordinates"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.mean_sky_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">mean_sky_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">response_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fluxwgt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mean sky coordinates for each spectrum.</span>
<span class="sd">        </span>
<span class="sd">        For CUBE files, this just returns the spaxel coordinates in</span>
<span class="sd">        arcseconds relative to the object center, where the object</span>
<span class="sd">        center is :math:`(\alpha_0,\delta_0) = ({\rm OBJRA},{\rm</span>
<span class="sd">        OBJDEC)` as provided in the primary header, and</span>

<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            x &amp;= (\alpha - \alpha_0) \cos \delta_0 \\</span>
<span class="sd">            y &amp;= (\delta - \delta_0)</span>

<span class="sd">        The coordinate grid, :math:`(\alpha, \delta)` is based on the</span>
<span class="sd">        WCS coordinates in the header as returned by :func:`world_mesh`.</span>

<span class="sd">        For RSS files, this returns either the unweighted or</span>
<span class="sd">        flux-weighted XPOS and YPOS values.  For observations where the</span>
<span class="sd">        pointing center is different from the object center, the</span>
<span class="sd">        returned coordinates are relative to the object center if</span>
<span class="sd">        offset=True (default) and relative to the pointing center if</span>
<span class="sd">        offset=False.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            </span>
<span class="sd">            Flux-weighting the coordinates can produce spurious results</span>
<span class="sd">            in low-flux regimes.</span>

<span class="sd">        Args:</span>
<span class="sd">            waverange (array-like): (**Optional**) Two-element array</span>
<span class="sd">                with the first and last wavelength to include in the</span>
<span class="sd">                computation.  Default is to use the full wavelength</span>
<span class="sd">                range.</span>
<span class="sd">            response_func (array-like): (**Optional**) A two-column</span>
<span class="sd">                array with the wavelength and transmission of a</span>
<span class="sd">                broad-band response function to use for the calculation.</span>
<span class="sd">            per_pixel (bool): (**Optional**) When providing a response</span>
<span class="sd">                function, continue to calculate the statistics per</span>
<span class="sd">                pixel, as opposed to per angstrom.  Default is to</span>
<span class="sd">            offset (bool) : Offset the coordinates to the object</span>
<span class="sd">                coordinates.</span>
<span class="sd">            flag (str or list): (**Optional**) (List of) Flag names that</span>
<span class="sd">                are considered when deciding if a pixel should be</span>
<span class="sd">                masked.  The names *must* be a valid bit name as defined</span>
<span class="sd">                by :attr:`bitmask` (see :class:`DRPFitsBitMask`).</span>
<span class="sd">            fluxwgt (bool) : (**Optional**) Flag to weight by the flux</span>
<span class="sd">                when determining the mean coordinates for the RSS spectra.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : A 1D array with the coordinates of each</span>
<span class="sd">            spectrum.  The index of the vector matches the index in</span>
<span class="sd">            :attr:`spatial_index` in case you want to recreate the a map</span>
<span class="sd">            for the CUBE files.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">world_mesh</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJRA&#39;</span><span class="p">])</span> \
                    <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">]))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;OBJDEC&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">*</span><span class="mf">3600.</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">*</span><span class="mf">3600.</span>

        <span class="c1"># The negative here is because the XPOS extension has negative</span>
        <span class="c1"># offsets going toward increasing RA.</span>
        <span class="n">xoff</span><span class="p">,</span> <span class="n">yoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointing_offset</span><span class="p">()</span> <span class="k">if</span> <span class="n">offset</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="n">xoff</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;XPOS&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">ypos</span> <span class="o">=</span> <span class="n">yoff</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;YPOS&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fluxwgt</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;FLUX&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

        <span class="c1"># Set the response function</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">per_pixel</span> <span class="k">else</span> \
                    <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span><span class="o">*</span><span class="n">wave</span>
        <span class="n">_response_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolated_response_function</span><span class="p">(</span><span class="n">response_func</span><span class="p">)</span>

        <span class="c1"># Get the normalization and return the flux- or un-weighted coordinates</span>
        <span class="k">if</span> <span class="n">fluxwgt</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flux</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flux</span><span class="o">*</span><span class="n">xpos</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flux</span><span class="o">*</span><span class="n">ypos</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">xpos</span><span class="p">))</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
                                <span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xpos</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ypos</span><span class="o">*</span><span class="n">_response_func</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">*</span><span class="n">dw</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span></div>


<div class="viewcode-block" id="DRPFits.flux_stats"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.flux_stats">[docs]</a>    <span class="k">def</span> <span class="nf">flux_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">response_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">covar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">covar_wave</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mean flux, propagated error in the mean flux, and</span>
<span class="sd">        mean S/N over the specified wavelength range; if the wavelength</span>
<span class="sd">        range is not specified, the quantities are calculated over the</span>
<span class="sd">        full spectral range.</span>

<span class="sd">        If an RSS file, no covariance is calculated.</span>

<span class="sd">        If a CUBE file and covar is True, the code will calculate the</span>
<span class="sd">        covariance matrix at the specified wavelength (see</span>
<span class="sd">        :func:`covariance_matrix`).  If covar_wave is not provided, the</span>
<span class="sd">        covariance is calculated at the center wavelength of the</span>
<span class="sd">        provided wavelength range.</span>

<span class="sd">        Args:</span>
<span class="sd">            waverange (array-like): (**Optional**) Starting and ending</span>
<span class="sd">                wavelength over which to calculate the statistics.</span>
<span class="sd">                Default is to use the full wavelength range.</span>
<span class="sd">            response_func (array-like): (**Optional**) A two-column</span>
<span class="sd">                array with the wavelength and transmission of a</span>
<span class="sd">                broad-band response function to use for the calculation.</span>
<span class="sd">            per_pixel (bool): (**Optional**) When providing a response</span>
<span class="sd">                function, continue to calculate the statistics per</span>
<span class="sd">                pixel, as opposed to per angstrom.  Default is to</span>
<span class="sd">                compute the statistics on a per pixel basis.</span>
<span class="sd">            flag (str or list): (**Optional**) (List of) Flag names that</span>
<span class="sd">                are considered when deciding if a pixel should be</span>
<span class="sd">                masked.  The names *must* be a valid bit name as defined</span>
<span class="sd">                by :attr:`bitmask` (see :class:`DRPFitsBitMask`).</span>
<span class="sd">            covar (bool): (**Optional**) Flag to calculate covariance</span>
<span class="sd">                matrix.</span>
<span class="sd">            correlation (bool): (**Optional**) Flag to convert the</span>
<span class="sd">                covariance matrix to a correlation matrix on ouput.</span>
<span class="sd">            covar_wave (double): (**Optional**) Wavelength to use for</span>
<span class="sd">                the covariance calculation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Four objects are returned: the mean flux, the</span>
<span class="sd">            propagated variance in the mean flux, the mean S/N, and the</span>
<span class="sd">            covariance/correlation matrix for a single wavelength</span>
<span class="sd">            channel.  If the object is an RSS file or no covariance</span>
<span class="sd">            calculation is requested, the last returned object is None.</span>
<span class="sd">    </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised of a provided wavelength range object</span>
<span class="sd">                does not have two elements.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">waverange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">waverange</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided wavelength range must be a two-element vector.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">response_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">response_func</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Response function object must be two dimensional.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">response_func</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Response function object must only have two columns.&#39;</span><span class="p">)</span>

        <span class="c1"># Grab the masked arrays</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;WAVE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">ivar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_to_masked_array</span><span class="p">(</span><span class="n">ext</span><span class="o">=</span><span class="s1">&#39;IVAR&#39;</span><span class="p">,</span> <span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="n">flux</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span>

        <span class="c1"># Set the response function</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nwave</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">if</span> <span class="n">per_pixel</span> <span class="k">else</span> \
                    <span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span><span class="o">*</span><span class="n">wave</span>
        <span class="n">_response_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolated_response_function</span><span class="p">(</span><span class="n">response_func</span><span class="p">)</span>

<span class="c1">#        print(flux.shape)</span>
<span class="c1">#        n = numpy.ma.sum(numpy.invert(numpy.ma.getmaskarray(flux)), axis=1)</span>
<span class="c1">#        print(n)</span>
<span class="c1">#        i = numpy.argsort(n)[-1]</span>
<span class="c1">#        print(i)</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.plot(self[&#39;WAVE&#39;].data, dw)</span>
<span class="c1">#        pyplot.plot(self[&#39;WAVE&#39;].data, flux[i,:])</span>
<span class="c1">#        pyplot.plot(self[&#39;WAVE&#39;].data, ivar[i,:])</span>
<span class="c1">#        pyplot.plot(self[&#39;WAVE&#39;].data, snr[i,:])</span>
<span class="c1">#        pyplot.plot(self[&#39;WAVE&#39;].data, _response_func)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#        exit()</span>

        <span class="c1"># Get the moments</span>
        <span class="n">response_integral</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
                                        <span class="o">*</span><span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flux</span><span class="o">*</span><span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">response_integral</span><span class="p">)</span>
        <span class="n">variance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span> \
                                    <span class="o">*</span> <span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">response_integral</span><span class="p">)</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">snr</span><span class="o">*</span><span class="p">(</span><span class="n">_response_func</span><span class="o">*</span><span class="n">dw</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                              <span class="n">response_integral</span><span class="p">)</span>

<span class="c1">#        pyplot.imshow(response_integral.reshape(self.spatial_shape).T, origin=&#39;lower&#39;,</span>
<span class="c1">#                      interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.imshow(signal.reshape(self.spatial_shape).T, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.imshow(variance.reshape(self.spatial_shape).T, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>
<span class="c1">#</span>
<span class="c1">#        pyplot.imshow(snr.reshape(self.spatial_shape).T, origin=&#39;lower&#39;, interpolation=&#39;nearest&#39;)</span>
<span class="c1">#        pyplot.show()</span>

        <span class="c1"># No computation of spatial covariance needed or requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">covar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signal</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Only calculate the covariance at the central, or input, wavelength</span>
        <span class="n">_covar_wave</span> <span class="o">=</span> <span class="n">covar_wave</span> <span class="k">if</span> <span class="n">covar_wave</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covariance_wavelength</span><span class="p">(</span><span class="n">waverange</span><span class="o">=</span><span class="n">waverange</span><span class="p">,</span>
                                                         <span class="n">response_func</span><span class="o">=</span><span class="n">response_func</span><span class="p">,</span>
                                                         <span class="n">per_pixel</span><span class="o">=</span><span class="n">per_pixel</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

        <span class="n">channel</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">wave</span> <span class="o">-</span> <span class="n">_covar_wave</span><span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">#        t = self.bitmask.flagged(self.hdu[&#39;MASK&#39;].data[:,:,channel],</span>
<span class="c1">#                                 flag=[&#39;NOCOV&#39;, &#39;LOWCOV&#39;, &#39;DEADFIBER&#39;])</span>
<span class="c1">#        tt = self.bitmask.flagged(self.hdu[&#39;MASK&#39;].data[:,:,channel],</span>
<span class="c1">#                                  flag=[&#39;FORESTAR&#39;, &#39;DONOTUSE&#39;])</span>
<span class="c1">#        print(numpy.sum(t))</span>
<span class="c1">#        print(numpy.sum(tt))</span>
<span class="c1">#        print(numpy.sum(t &amp; ~tt))</span>

        <span class="c1"># Return the nominal stats and the covariance matrix</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_matrix</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">correlation</span><span class="p">:</span>
            <span class="n">C</span><span class="o">.</span><span class="n">to_correlation</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">signal</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">snr</span><span class="p">,</span> <span class="n">C</span></div>


<div class="viewcode-block" id="DRPFits.binned_on_sky_area"><a class="viewcode-back" href="../../mangadap.drpfits.html#mangadap.drpfits.DRPFits.binned_on_sky_area">[docs]</a>    <span class="k">def</span> <span class="nf">binned_on_sky_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_indx</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the on-sky area of a set of binned spectra.  For CUBE</span>
<span class="sd">        files, this is just the number of spaxels in the bin times the</span>
<span class="sd">        spaxel area (as given by :attr:`pixelscale`).</span>

<span class="sd">        For RSS files, this will try to calculate the overlapping area</span>
<span class="sd">        of the fibers using the `shapely`_ python package:</span>

<span class="sd">            - The fibers &quot;beams&quot; are all renormalized to have an area of</span>
<span class="sd">              pi arcsec^2 by the DRP, so it&#39;s radius 1 arcsec</span>
<span class="sd">            - This function will provide the *total* area, not the</span>
<span class="sd">              integration-weighted effective area.</span>

<span class="sd">        Args:</span>
<span class="sd">            bin_indx (array-like): A vector with size :math:`N_{\rm</span>
<span class="sd">                spec}` the gives which spaxels or fibers were included</span>
<span class="sd">                in each bin.  Valid bins have indices of :math:`\geq 0`.</span>
<span class="sd">            x (array-like): (**Optional**) On-sky :math:`x` coordinate.</span>
<span class="sd">                Default is to calculate :math:`x` and :math:`y` using</span>
<span class="sd">                :func:`mean_sky_coordinates` with no arguments.</span>
<span class="sd">            y (array-like): (**Optional**) On-sky :math:`y` coordinate.</span>
<span class="sd">                Default is to calculate :math:`x` and :math:`y` using</span>
<span class="sd">                :func:`mean_sky_coordinates` with no arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray : The on-sky area of each bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unique_bins</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bin_indx</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">unique_bins</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nbin</span> <span class="o">=</span> <span class="n">bin_count</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;CUBE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span> <span class="o">=</span> <span class="n">default_cube_pixelscale</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nbin</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelscale</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_sky_coordinates</span><span class="p">()</span>
            <span class="n">good_bins</span> <span class="o">=</span> <span class="n">unique_bins</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

            <span class="n">area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nbin</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">good_bins</span><span class="p">):</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">bin_indx</span> <span class="o">==</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">bin_indx</span> <span class="o">==</span> <span class="n">b</span><span class="p">]</span>

                <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cascaded_union</span><span class="p">([</span> <span class="n">Point</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> \
                                                        <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span><span class="n">_y</span><span class="p">)</span> <span class="p">])</span><span class="o">.</span><span class="n">area</span>
            <span class="k">return</span> <span class="n">area</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Could not use </span><span class="se">\&#39;</span><span class="s1">shapely</span><span class="se">\&#39;</span><span class="s1"> package to compute overlapping fiber area.&#39;</span> \
                          <span class="s1">&#39;Return the total fiber area.&#39;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nbin</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div></div>
        

<span class="c1">#   def white_light(self, mask_list=None):</span>
<span class="c1">#       &quot;&quot;&quot;</span>
<span class="c1">#       Return the X and Y coordinate grid, and a &quot;white-light&quot; flux density (in</span>
<span class="c1">#       10^{-17} erg/s/cm^2/angstrom) integrated over the full spectral range,</span>
<span class="c1">#       ignoring masked pixels:</span>

<span class="c1">#                               \int f dl</span>
<span class="c1">#                          wl = ---------    .</span>
<span class="c1">#                                \int dl</span>

<span class="c1">#       The pixels to be masked are those that are flagged with any of</span>
<span class="c1">#       the maskbits provided (mask_list).</span>

<span class="c1">#       For RSS files, this takes into account the changing XPOS and</span>
<span class="c1">#       YPOS with wavelength.  For CUBE files, this is a more</span>
<span class="c1">#       straight-forward integration of the cube.</span>

<span class="c1">#       ARGUMENTS:</span>
<span class="c1">#           - mask_list: numpy string array with the list of</span>
<span class="c1">#             &#39;MANGA_DRPPIXFLAG&#39; values to ignore in the integration</span>

<span class="c1">#             If None, ignore any non-zero pixel in the MASK extension.</span>

<span class="c1">#       &quot;&quot;&quot;</span>

<span class="c1">#       if mask_list is not None:</span>
<span class="c1">#           print(&quot;Cannot yet interpret mask_list. Ignoring.&quot;)</span>

<span class="c1">#       self.dlogl = 0.0001</span>

<span class="c1">#   TODO: Add log sampling to header of RSS files        </span>

<span class="c1">#       mask = numpy.zeros(self.hdu[&#39;MASK&#39;].data.shape, dtype=numpy.float64)</span>
<span class="c1">#       mask[ self.hdu[&#39;MASK&#39;].data.shape &gt; 0. ] = 1.0</span>

<span class="c1">#       if mode is &#39;RSS&#39;:</span>
<span class="c1">#           X, Y = self.pix_mesh()</span>
<span class="c1">#           X = (X-1)*self.pixelscale+self.xs</span>
<span class="c1">#           X = (Y-1)*self.pixelscale+self.ys</span>
<span class="c1">#           ipos = (self.hdu[&#39;XPOS&#39;].data - self.xs)/self.pixelscale</span>
<span class="c1">#           jpos = (self.hdu[&#39;YPOS&#39;].data - self.ys)/self.pixelscale</span>

<span class="c1">#           Z = numpy.zeros(X.shape, dtype=numpy.float64)</span>

<span class="c1">#           wgt = numpy.zeros(X.shape, dtype=numpy.float64)</span>
<span class="c1">#           nwave = (self.hdu[&#39;FLUX&#39;].header[&#39;NAXIS1&#39;])</span>
<span class="c1">#           nspec = (self.hdu[&#39;FLUX&#39;].header[&#39;NAXIS2&#39;])</span>

<span class="c1">#           for i in range(0,nspec):</span>
<span class="c1">#               for j in range(0,nwave):</span>
<span class="c1">#                   tmp = mask[i,j] * dlogl * self.hdu[&#39;WAVE&#39;].data[i,j]</span>
<span class="c1">#                   Z[ipos[i,j], jpos[i,j]] += tmp * self.hdu[&#39;FLUX&#39;].data[i,j]</span>
<span class="c1">#                   wgt[ipos[i,j], jpos[i,j]] += tmp</span>

<span class="c1">#           Z[wgt &gt; 0.] /= wgt[wgt &gt; 0.]</span>

<span class="c1">#           return X, Y, Z</span>

<span class="c1">#       else:</span>
<span class="c1">#           X, Y = self.world_mesh()</span>

<span class="c1">#           nwave = (self.hdu[&#39;FLUX&#39;].header[&#39;NAXIS3&#39;])</span>
<span class="c1">#           Z = self.hdu[&#39;FLUX&#39;].data</span>
<span class="c1">#           for i in range(0,nwave):</span>
<span class="c1">#               mask[:,:,i]</span>

<span class="c1">#           ipos = numpy.zeros(self.hdu[&#39;FLUX&#39;].data.shape, dtype=numpy.int32)</span>
<span class="c1">#           jpos = numpy.zeros(self.hdu[&#39;FLUX&#39;].data.shape, dtype=numpy.int32)</span>
<span class="c1">#           ipos[:,:,0], jpos[:,:,0] = numpy.meshgrid( numpy.arange(0, self.nx), \</span>
<span class="c1">#                                                      numpy.arange(0,self.ny), indexing=&#39;ij&#39;)</span>
<span class="c1">#           ipos[:,:,1:-1] = ipos[:,:,0]</span>
<span class="c1">#           </span>
<span class="c1">#       Z = numpy.zeros(X.shape)</span>
<span class="c1">#           </span>
<span class="c1">#  </span>
<span class="c1">#       # x_grid will ensure that the hdu is read</span>
<span class="c1">#       x = self.x_grid()</span>
<span class="c1">#       y = self.y_grid()</span>
<span class="c1">#       X, Y = numpy.meshgrid(x, y)</span>



        

    
        




</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>