

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mangadap.contrib.xjmc &mdash; mangadap 2.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="mangadap 2.2.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> mangadap
          

          
          </a>

          
            
            
              <div class="version">
                2.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mangadap.html">mangadap package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">mangadap</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mangadap.contrib.xjmc</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mangadap.contrib.xjmc</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements an emission-line fitting function using pPXF.</span>

<span class="sd">*License*:</span>
<span class="sd">    Copyright (c) 2018, SDSS-IV/MaNGA Pipeline Group</span>
<span class="sd">        Licensed under BSD 3-clause license - see LICENSE.rst</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/contrib/xjmc.py</span>

<span class="sd">*Imports and python version compliance*:</span>
<span class="sd">    ::</span>

<span class="sd">        from __future__ import division</span>
<span class="sd">        from __future__ import print_function</span>
<span class="sd">        from __future__ import absolute_import</span>
<span class="sd">        from __future__ import unicode_literals</span>

<span class="sd">        import sys</span>
<span class="sd">        if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">            long = int</span>

<span class="sd">        import warnings</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        from scipy import fftpack</span>
<span class="sd">        from scipy.ndimage import rank_filter</span>

<span class="sd">        import astropy.constants</span>

<span class="sd">        from captools import ppxf, capfit</span>

<span class="sd">*Class usage examples*:</span>
<span class="sd">        Add examples</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **31 Aug 2017**: First commit by Xihan Ji (XJ)</span>
<span class="sd">    | **06 Feb 2018**: K. Westfall (KBW) added documentation</span>
<span class="sd">    | **09 Feb 2018**: (KBW) Return the bin matching vector</span>
<span class="sd">    | **20 Mar 2018**: (KBW) Correct error in carrying around pixels</span>
<span class="sd">        rejected during fit</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">fftpack</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">rank_filter</span>

<span class="kn">import</span> <span class="nn">astropy.constants</span>

<span class="kn">from</span> <span class="nn">captools</span> <span class="k">import</span> <span class="n">ppxf</span><span class="p">,</span> <span class="n">capfit</span>

<span class="c1"># For debugging</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="c1"># from mangadap.proc.ppxffit import PPXFModel</span>

<div class="viewcode-block" id="calculate_noise"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc.calculate_noise">[docs]</a><span class="k">def</span> <span class="nf">calculate_noise</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">101</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Robust determination of the error spectrum as 1/2 of the interval</span>
<span class="sd">    enclosing 68% of the values in a given running window.  Created by</span>
<span class="sd">    Michele Cappellari (23 September 2017)</span>

<span class="sd">    Args:</span>

<span class="sd">        residuals (numpy.ndarray): Vector of residuals between the model</span>
<span class="sd">            and data</span>
<span class="sd">        width (int): (**Optional**) Size of the window for the</span>
<span class="sd">            statistics.  Should be an odd number and larger and 10.</span>
<span class="sd">            Default is 101.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Vector with the same size as the input residuals</span>
<span class="sd">        with half of the 68% confidence interval of the residuals within</span>
<span class="sd">        a box of size `width` centered at each position.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if the width is not an odd number or if it is</span>
<span class="sd">            less than 11 elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">width</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provided odd number width.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Width must be 11 or higher.&#39;</span><span class="p">)</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.6827</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>  <span class="c1"># 1sigma</span>
    <span class="n">lo</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>

    <span class="n">upper</span> <span class="o">=</span> <span class="n">rank_filter</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">up</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">rank_filter</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">lo</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">noise</span></div>


<div class="viewcode-block" id="_ppxf_component_setup"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc._ppxf_component_setup">[docs]</a><span class="k">def</span> <span class="nf">_ppxf_component_setup</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">single_gas_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">gas_start</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup the component, moment, and starting point arrays for a</span>
<span class="sd">    ppxf-fitting interation.</span>

<span class="sd">    This primarily just sets all the gas components to a single</span>
<span class="sd">    component if requested.  It also restructures the moment and</span>
<span class="sd">    starting point arrays as necessary to reflect this change.</span>

<span class="sd">    ..warning::</span>

<span class="sd">        This function requires that all stellar components have</span>
<span class="sd">        component numbers that are **less than** any gas components.</span>
<span class="sd">        However, this **is not checked** by the function.</span>

<span class="sd">    Args:</span>
<span class="sd">        component (numpy.ndarray): The full list of components for all</span>
<span class="sd">            templates.  The total number of components is NCOMP.</span>
<span class="sd">        gas_template (numpy.ndarray): A boolean array identifying the</span>
<span class="sd">            gas templates.</span>
<span class="sd">        start (list, numpy.ndarray): The starting kinematics to use for</span>
<span class="sd">            each object spectrum.  Shape is (NOBJ,); each element has</span>
<span class="sd">            shape (NCOMP,); each component element has shape (NMOM,),</span>
<span class="sd">            such that the number of moments can be different for each</span>
<span class="sd">            component.  NCOMP and NMOM should be the same for all object</span>
<span class="sd">            spectra.</span>
<span class="sd">        single_gas_component (bool): (**Optional**) Flag to force all</span>
<span class="sd">            gas components to have the same kinematics.</span>
<span class="sd">        gas_start (list, numpy.ndarray): (**Optional**) The starting</span>
<span class="sd">            kinematics to use for the gas components.  Shape must be</span>
<span class="sd">            (NOBJ,2).</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Three arrays: (1) The list of downselected and</span>
<span class="sd">        renumbered, if necessary, kinematic components, (2) the</span>
<span class="sd">        downselected and reordered, if necessary, number of moments to</span>
<span class="sd">        fit, and (3) the downselected and reordered starting guesses for</span>
<span class="sd">        each component.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if the provided gas starting kinematics is</span>
<span class="sd">            not correct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Number of object spectra to fit</span>
    <span class="n">nobj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gas_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gas_start</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nobj</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided gas starting kinematics has incorrect shape.&#39;</span><span class="p">)</span>

    <span class="c1"># Get the gas component numbers</span>
    <span class="n">gas_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="n">gas_template</span><span class="p">])</span>

    <span class="c1"># Component assignments for each template</span>
    <span class="n">_component</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_gas_components</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">single_gas_component</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">gas_components</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_gas_components</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_component</span><span class="p">[</span><span class="n">gas_template</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="o">~</span><span class="n">gas_template</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>

    <span class="c1"># Shape of start is (nobj,); each element of start has shape (ncomp,);</span>
    <span class="c1"># each component has shape (nmom,), which can be different for each</span>
    <span class="c1"># component</span>
    <span class="n">stellar_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">gas_components</span><span class="p">))</span>
    <span class="n">_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">])</span>
    <span class="n">_moments</span><span class="p">[</span><span class="n">stellar_components</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">n_gas_components</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Force a single gas component</span>
        <span class="n">_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">_moments</span><span class="p">[</span><span class="n">_moments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span> <span class="mi">2</span> <span class="p">])</span>

    <span class="c1"># Reset the starting values for the kinematics</span>
    <span class="n">_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="n">_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">stellar_components</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stellar_components</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">gas_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_gas_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">gas_components</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> \
                                <span class="k">if</span> <span class="n">n_gas_components</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">gas_components</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_gas_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">gas_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span><span class="o">*</span><span class="n">n_gas_components</span>
        <span class="n">_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">_gas_start</span>
        
    <span class="k">return</span> <span class="n">_component</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">_start</span></div>

<span class="c1"># NOT USED</span>
<span class="c1">#def _ppxf_fit_matrix(start, npix_obj, templates_rfft, npix_tpl, npad, component, vsyst, moments,</span>
<span class="c1">#                     velscale, velscale_ratio):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Mimic the first bit of ppxf._linear_fit()</span>
<span class="c1">#</span>
<span class="c1">#    Limited as follows:</span>
<span class="c1">#        - no additive or multiplicative polynomial</span>
<span class="c1">#        - no reddening</span>
<span class="c1">#        - only single galaxy spectrum (ppxf.nspec = 1)</span>
<span class="c1">#        - no sigma_diff</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Template and component shape</span>
<span class="c1">#    ntpl, nl = templates_rfft.shape</span>
<span class="c1">#    if len(component) != ntpl:</span>
<span class="c1">#        raise ValueError(&#39;Component length must match the number of templates.&#39;)</span>
<span class="c1">#    ncomp = np.max(component)+1</span>
<span class="c1">#</span>
<span class="c1">#    # Convert from km/s to pixel coordinates</span>
<span class="c1">#    _start = np.array(start) #, dtype=object)</span>
<span class="c1">#    for j in range(ncomp):</span>
<span class="c1">#        _start[j][:2] /= velscale</span>
<span class="c1">#    _vsyst = vsyst/velscale</span>
<span class="c1">#</span>
<span class="c1">#    # Parameter vector:</span>
<span class="c1">#    # pars = [vel_1, sigma_1, h3_1, h4_1, ... # Velocities are in pixels.</span>
<span class="c1">#    #         ...                             # For all kinematic components</span>
<span class="c1">#    #         vel_n, sigma_n, h3_n, h4_n, ...</span>
<span class="c1">#    pars = _start.ravel()</span>
<span class="c1">#</span>
<span class="c1">#    # FFT of the LOSVD</span>
<span class="c1">#    losvd_rfft = ppxf._losvd_rfft(pars, 1, np.abs(moments), nl, ncomp, _vsyst, velscale_ratio, 0.)</span>
<span class="c1">#</span>
<span class="c1">#    # Construct and return the convolved templates</span>
<span class="c1">#    c = np.zeros((ntpl, npix_obj), dtype=float)</span>
<span class="c1">#    for i, tpl_rfft in enumerate(templates_rfft):</span>
<span class="c1">#        pr = tpl_rfft * losvd_rfft[:, component[i], 0]</span>
<span class="c1">#        tt = np.fft.irfft(pr, npad)</span>
<span class="c1">#        c[i,:] = tt[:npix_obj] if velscale_ratio == 1 else \</span>
<span class="c1">#                    ppxf.rebin(tt[:npix_tpl*velscale_ratio], velscale_ratio)[:npix_obj]</span>
<span class="c1">#    return c</span>


<div class="viewcode-block" id="_validate_templates_components"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc._validate_templates_components">[docs]</a><span class="k">def</span> <span class="nf">_validate_templates_components</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">tied</span><span class="p">,</span>
                                   <span class="n">tpl_to_use</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that templates are valid in the sense that they have non-zero</span>
<span class="sd">    components in valid pixel regions.  If all templates are valid, the</span>
<span class="sd">    returned data is identical to the input.  If not, the returned data</span>
<span class="sd">    are restructured as necessary for running pPXF.</span>
<span class="sd">    </span>
<span class="sd">    The start vector is used to set the guess offset (including vsyst)</span>
<span class="sd">    between the provided mask and the template.  The tpl_to_use vector</span>
<span class="sd">    is used to set a tempate as invalid.</span>

<span class="sd">    ..warning::</span>
<span class="sd">        Unclear what happens if an entire component is lost!</span>

<span class="sd">    Args:</span>
<span class="sd">        templates (numpy.ndarray): Templates library to use for fitting.</span>
<span class="sd">            Shape is (NTPLPIX,NTPL).</span>
<span class="sd">        gas_template (numpy.ndarray): Boolean vector that selects the</span>
<span class="sd">            gas templates.  Shape is (NTPL,).</span>
<span class="sd">        component (numpy.ndarray): Integer vector identifying the</span>
<span class="sd">            kinematic component for each template.  Shape is (NTPL,).</span>
<span class="sd">        moments (numpy.ndarray): Integer vector with the number of</span>
<span class="sd">            kinematic moments for each component.  Shape is (NCOMP,).</span>
<span class="sd">        mask (numpy.ndarray): Boolean vector that selects the pixels in</span>
<span class="sd">            the object spectrum to fit (i.e., mask=True for pixels to</span>
<span class="sd">            fit and mask=False for pixels to ignore).  As in pPXF, the</span>
<span class="sd">            length is expected to be less than or equal to NTPLPIX in</span>
<span class="sd">            the template spectra.</span>
<span class="sd">        start (list): The starting kinematics for each kinematic</span>
<span class="sd">            component.  Length is NCOMP.</span>
<span class="sd">        tied (list): The pPXF tying list establishing which parameters</span>
<span class="sd">            should be tied during the fit.  Length is NCOMP, and each</span>
<span class="sd">            component has length NMOM.</span>
<span class="sd">        tpl_to_use (numpy.ndarray):  In addition to removing</span>
<span class="sd">            unconstrained templates, this boolean vector selects that</span>
<span class="sd">            should even be considered in the fit.  Shape is (NTPL,).</span>
<span class="sd">        velscale (float): The pixel scale of the object spectrum to fit</span>
<span class="sd">            in km/s.</span>
<span class="sd">        velscale_ratio (int): (**Optional**) The ratio between the</span>
<span class="sd">            object and template pixel scale.</span>
<span class="sd">        vsyst (float): (**Optional**) The pseudo velocity shift between</span>
<span class="sd">            the template and object spectra just due to the difference</span>
<span class="sd">            in the starting wavelength.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Eight arrays are returned: (1) Boolean vector</span>
<span class="sd">        with which templates were valid (length is NTPL), (2) the valid</span>
<span class="sd">        set of templates to pass to pPXF [shape is (NTPLPIX,_NTPL)], (3)</span>
<span class="sd">        the boolean vector selecting gas templates (length is _NTPL),</span>
<span class="sd">        (4) an integer vector mapping the input component number to the</span>
<span class="sd">        output component number (i.e., component_map[0] is the original</span>
<span class="sd">        component number for the downselected 0th component; length is</span>
<span class="sd">        _NCOMP), (5) the new component number for the downselected</span>
<span class="sd">        templates (length is _NTPL), (6) the number of moments for the</span>
<span class="sd">        new components (length is _NCOMP), (7) the starting kinematics</span>
<span class="sd">        for each new component (length is _NCOMP), and (8) the parameter</span>
<span class="sd">        tying object reordered as necessary for the new component list</span>
<span class="sd">        (**this needs to be checked**).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if no templates are valid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    # Get the FFT of the templates</span>
<span class="c1">#    npix_tpl = templates.shape[1]</span>
<span class="c1">#    npad = fftpack.next_fast_len(npix_tpl)</span>
<span class="c1">#    templates_rfft = np.fft.rfft(templates, npad, axis=1)</span>
<span class="c1">#</span>
<span class="c1">#    # Get the design matrix without any polynomial adjustment</span>
<span class="c1">#    c = _ppxf_fit_matrix(start, len(mask), templates_rfft, npix_tpl//velscale_ratio, npad,</span>
<span class="c1">#                         component, vsyst, moments, velscale, velscale_ratio)</span>
<span class="c1">#</span>
<span class="c1">#    # Determine which templates have constraining data</span>
<span class="c1">#    valid = np.max(np.absolute(c * mask.astype(float)[None,:]), axis=1) &gt; 1e3*np.finfo(float).eps</span>
<span class="c1">#    valid &amp;= tpl_to_use</span>
<span class="c1">#    ncomp = np.max(component)+1</span>
<span class="c1">#</span>
<span class="c1">#    for i in range(c.shape[0]):</span>
<span class="c1">#        if not gas_template[i]:</span>
<span class="c1">#            continue</span>
<span class="c1">#        plt.plot(c[i,:], zorder=1, linestyle=&#39;-&#39; if valid[i] else &#39;:&#39;)</span>
<span class="c1">#    plt.fill_between(np.arange(c.shape[1]),0, mask.astype(float)/4,</span>
<span class="c1">#                     color=&#39;k&#39;, alpha=0.3, zorder=0, lw=0)</span>
<span class="c1">#    plt.show()</span>

    <span class="c1"># Pulled from the pPXF test for consistency</span>
    <span class="n">npix_tpl</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">start</span><span class="p">])</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">vsyst</span> <span class="o">+</span> <span class="n">vmed</span><span class="p">)</span><span class="o">/</span><span class="n">velscale</span><span class="p">)</span>  <span class="c1"># Approximate velocity shift</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">templates</span> <span class="k">if</span> <span class="n">velscale_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">templates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">npix_tpl</span><span class="o">//</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:,:</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)]</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">&gt;</span> <span class="n">m1</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">valid</span> <span class="o">&amp;=</span> <span class="n">tpl_to_use</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

<span class="c1">#    for i in range(c.shape[0]):</span>
<span class="c1">#        if not gas_template[i]:</span>
<span class="c1">#            continue</span>
<span class="c1">#        plt.plot(c[i,:], zorder=1, linestyle=&#39;-&#39; if valid[i] else &#39;:&#39;)</span>
<span class="c1">#    plt.fill_between(np.arange(c.shape[1]),0, mask.astype(float)/4,</span>
<span class="c1">#                     color=&#39;k&#39;, alpha=0.3, zorder=0, lw=0)</span>
<span class="c1">#    plt.show()</span>

    <span class="c1"># All templates are valid, just return the input</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">valid</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">valid</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncomp</span><span class="p">),</span> <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">tied</span>

    <span class="c1"># None (!) of the templates are valid</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No valid templates in fit!&#39;</span><span class="p">)</span>

    <span class="c1"># Templates to fit</span>
    <span class="n">_templates</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="n">valid</span><span class="p">,:]</span>
    <span class="c1"># Set which are gas templates</span>
    <span class="n">_gas_template</span> <span class="o">=</span> <span class="n">gas_template</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="c1"># Sequential template numbers</span>
    <span class="n">_component</span> <span class="o">=</span> <span class="n">component</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="c1"># Map between old and new component numbers</span>
    <span class="n">component_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_component</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">component_map</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)):</span>
        <span class="c1"># Subset of components are not in sequence so they need to be remapped</span>
        <span class="n">remapped_component</span> <span class="o">=</span> <span class="n">_component</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Starting kinematics for each component</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_tied</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">tied</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">component_map</span><span class="p">):</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">_component</span> <span class="o">==</span> <span class="n">cm</span>
            <span class="n">remapped_component</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">_start</span> <span class="o">+=</span> <span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="n">cm</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">tied</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_tied</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tied</span><span class="p">[</span><span class="n">cm</span><span class="p">]]</span>
        <span class="n">_component</span> <span class="o">=</span> <span class="n">remapped_component</span>
        <span class="n">_moments</span> <span class="o">=</span> <span class="n">moments</span><span class="p">[</span><span class="n">component_map</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">_tied</span> <span class="o">=</span> <span class="n">tied</span>
        <span class="n">_moments</span> <span class="o">=</span> <span class="n">moments</span>

    <span class="k">return</span> <span class="n">valid</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">_component</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_tied</span></div>


<div class="viewcode-block" id="_reorder_solution"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc._reorder_solution">[docs]</a><span class="k">def</span> <span class="nf">_reorder_solution</span><span class="p">(</span><span class="n">ppsol</span><span class="p">,</span> <span class="n">pperr</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mf">999.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provided the best-fitting parameters from a ppxf instance,</span>
<span class="sd">    restructure the parameters to account for components that were</span>
<span class="sd">    removed during the template validation.</span>

<span class="sd">    Args:</span>
<span class="sd">        ppsol (list): The pPXF solution parameters</span>
<span class="sd">        pperr (list): The formal errors on the pPXF solution parameters</span>
<span class="sd">        component_map (numpy.ndarray): An integer vector mapping the</span>
<span class="sd">            input component number to the output component number; i.e.,</span>
<span class="sd">            component_map[0] is the original component number for the</span>
<span class="sd">            downselected 0th component; length is _NCOMP.</span>
<span class="sd">        moments (list): The number of moments for the *original* set of</span>
<span class="sd">            components; length is NCOMP.</span>
<span class="sd">        start (list): (**Optional**) The starting kinematics for the</span>
<span class="sd">            *original* set of components.  If provided, the starting</span>
<span class="sd">            values are included in the output parameter object for</span>
<span class="sd">            components that were not included in the pPPXF fit;</span>
<span class="sd">            otherwise, the unfit components are given placeholder</span>
<span class="sd">            parameter values.</span>
<span class="sd">        fill_value (float): (**Optional**) The placeholder value to give</span>
<span class="sd">            parameters and errors for components not included in the</span>
<span class="sd">            pPXF fit.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Two lists with the rearranged best-fitting parameters and</span>
<span class="sd">        errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If all the components were fit, just return the input</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">component_map</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">ppsol</span><span class="p">,</span> <span class="n">pperr</span>
    <span class="n">_ncomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_map</span><span class="p">)</span>

    <span class="c1"># Rearrange the output to match the input components</span>
    <span class="n">new_start</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_error</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncomp</span><span class="p">):</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="n">component_map</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_start</span> <span class="o">+=</span> <span class="p">([[</span><span class="n">fill_value</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">new_error</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">fill_value</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="k">continue</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">_ncomp</span><span class="p">)[</span><span class="n">indx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_start</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ppsol</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
        <span class="n">new_error</span> <span class="o">+=</span> <span class="p">[</span><span class="n">pperr</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">new_error</span></div>


<div class="viewcode-block" id="_fit_iteration"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc._fit_iteration">[docs]</a><span class="k">def</span> <span class="nf">_fit_iteration</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span>
                   <span class="n">tpl_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a single fit+rejection iteration of the pPXF fit for all input</span>
<span class="sd">    spectra with the provided set of constraints/options.</span>

<span class="sd">    Args: </span>
<span class="sd">        templates (numpy.ndarray): Full template library.  Shape is</span>
<span class="sd">            (NTPL,NTPLPIX).</span>
<span class="sd">        wave (numpy.ndarray): Wavelength vector.  Shape is (NPIX,).</span>
<span class="sd">        flux (numpy.ndarray): Object spectra to fit.  Shape is</span>
<span class="sd">            (NSPEC,NPIX).</span>
<span class="sd">        noise (numpy.ndarray): Error in the object spectra to fit.</span>
<span class="sd">            Shape is (NSPEC,NPIX).</span>
<span class="sd">        velscale (float): The pixel scale of the object spectra in km/s.</span>
<span class="sd">        start (list): The starting kinematics for each kinematic</span>
<span class="sd">            component.  Length is NCOMP.</span>
<span class="sd">        moments (numpy.ndarray): Integer vector with the number of</span>
<span class="sd">            kinematic moments for each component.  Shape is (NCOMP,).</span>
<span class="sd">        component (numpy.ndarray): Integer vector identifying the</span>
<span class="sd">            kinematic component for each template.  Shape is (NTPL,).</span>
<span class="sd">        gas_template (numpy.ndarray): Boolean vector that selects the</span>
<span class="sd">            gas templates.  Shape is (NTPL,).</span>
<span class="sd">        tpl_to_use (numpy.ndarray):  (**Optional**) Boolean vector</span>
<span class="sd">            selecting templates to consider during the fit.  Shape is</span>
<span class="sd">            (NTPL,).  If None, all templates are used in the fit.</span>
<span class="sd">        reject_boxcar (int): (**Optional**) Size of the window for the</span>
<span class="sd">            rejection statistics.  Should be an odd number and larger</span>
<span class="sd">            and 10.  Default is 101.  If None, no rejection iteration is</span>
<span class="sd">            performed.</span>
<span class="sd">        velscale_ratio (int): (**Optional**) The ratio between the</span>
<span class="sd">            object and template pixel scale.</span>
<span class="sd">        degree (int): (**Optional**) Order of the additive polynomial to</span>
<span class="sd">            include in the fit.  Not included by default.</span>
<span class="sd">        mdegree (int): (**Optional**) Order of the multiplicative</span>
<span class="sd">            polynomial to fit.  Not included by default.</span>
<span class="sd">        reddening (float): (**Optional**) Initial E(B-V) guess for</span>
<span class="sd">            reddening (uses ppxf-default Calzetti 2000 model).  No</span>
<span class="sd">            attentuation fit by default.</span>
<span class="sd">        tied (list): (**Optional**) List of parameters to tie during the</span>
<span class="sd">            fit.</span>
<span class="sd">        mask (numpy.ndarray): (**Optional**) Boolean vector that selects</span>
<span class="sd">            the pixels in the object spectra to fit (i.e., mask=True for</span>
<span class="sd">            pixels to fit and mask=False for pixels to ignore).  Shape</span>
<span class="sd">            is (NSPEC,NPIX).  All pixels are fit by default.</span>
<span class="sd">        vsyst (float): (**Optional**) The pseudo velocity shift between</span>
<span class="sd">            the template and object spectra just due to the difference</span>
<span class="sd">            in the starting wavelength.</span>
<span class="sd">        plot (bool): (**Optional**) Show the pPXF fit plot at each</span>
<span class="sd">            iteration.  Default is to skip the plot.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress output to the terminal</span>
<span class="sd">            (default).</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Eleven arrays are returned: (1) The best-fitting</span>
<span class="sd">        model for each spectrum [shape is (NSPEC,NPIX)]; (2) the</span>
<span class="sd">        best-fitting emission-line-only model for each spectrum [shape</span>
<span class="sd">        is (NSPEC,NPIX)]; (3) a boolean array that is True for all</span>
<span class="sd">        spectral pixels included in the fit [shape is (NSPEC,NPIX)]; (4)</span>
<span class="sd">        the best-fitting weight for each template in each spectrum</span>
<span class="sd">        [shape is (NSPEC,NTPL)]; (5) the error in the best-fitting</span>
<span class="sd">        template weights [shape is (NSPEC,NTPL)]; (6) the coefficients</span>
<span class="sd">        of the additive polynomial for each spectrum [shape is</span>
<span class="sd">        (NSPEC,DEGREE+1)]; (7) the coefficients of the multiplicative</span>
<span class="sd">        polynomial for each spectrum [shape is (NSPEC,MDEGREE)]; (8) the</span>
<span class="sd">        best-fitting reddening values for each spectrum [shape is</span>
<span class="sd">        (NSPEC,)]; (9) the input kinematics for each fit [shape is</span>
<span class="sd">        (NSPEC,sum(MOMENTS)]; (10) the best-fit kinematics for each fit</span>
<span class="sd">        [shape is (NSPEC,sum(MOMENTS)]; (11) the formal error in the</span>
<span class="sd">        best-fit kinematics for each fit [shape is (NSPEC,sum(MOMENTS)].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some useful shape numbers</span>
    <span class="n">nspec</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ntpl</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">))</span>

    <span class="c1"># Establish which templates should be used</span>
    <span class="n">_tpl_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">tpl_to_use</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tpl_to_use</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Initialize the output</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">eml_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">model_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tpl_wgts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">tpl_wgts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">addcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">multcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">mdegree</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">mdegree</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ebv</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kininp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kin_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># For debugging</span>
    <span class="n">linear</span><span class="o">=</span><span class="kc">False</span>
<span class="c1">#    linear=True</span>
<span class="c1">#    reject_boxcar=None</span>
<span class="c1">#    mdegree=0</span>

    <span class="c1"># Fit each spectrum individually</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>

        <span class="c1"># Report progress</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Run the first fit</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">valid_templates</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">_component</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> \
                <span class="n">_tied</span> <span class="o">=</span> <span class="n">_validate_templates_components</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span>
                                                       <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tied</span><span class="p">,</span>
                                                       <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">velscale</span><span class="p">,</span>
                                                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">)</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">_templates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">_moments</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                       <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="n">_tied</span><span class="p">,</span>
                       <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">_component</span><span class="p">,</span>
                       <span class="n">gas_component</span><span class="o">=</span><span class="n">_gas_template</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Reject 3-sigma outliers and refit, if requested by a provided</span>
        <span class="c1"># boxcar width</span>
        <span class="k">if</span> <span class="n">reject_boxcar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># - Calculate residuals</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span>
            <span class="c1"># - Select pixels included in the fit and not fit by</span>
            <span class="c1"># emission lines</span>
            <span class="n">reject_pixels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">goodpixels</span><span class="p">)</span>
                                    <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">))[</span><span class="n">pp</span><span class="o">.</span><span class="n">gas_bestfit</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">]))</span>
            <span class="c1"># - Calculate the 1-sigma confidence interval</span>
            <span class="n">NOISE</span> <span class="o">=</span> <span class="n">calculate_noise</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">reject_pixels</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="n">reject_boxcar</span><span class="p">)</span>
            <span class="c1"># - Reject pixels with &gt; 3-sigma residuals</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">reject_pixels</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">reject_pixels</span><span class="p">])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">NOISE</span><span class="p">))</span>
        
            <span class="c1"># Reorder the output; sets any omitted components to have</span>
            <span class="c1"># the starting values from the original input</span>
            <span class="n">sol</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">_reorder_solution</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Refit using best-fit kinematics from previous fit</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">valid_templates</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">_component</span><span class="p">,</span> <span class="n">_moments</span><span class="p">,</span> \
                    <span class="n">_start</span><span class="p">,</span> <span class="n">_tied</span> <span class="o">=</span> <span class="n">_validate_templates_components</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span>
                                                                   <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span>
                                                                   <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">sol</span><span class="p">,</span> <span class="n">tied</span><span class="p">,</span>
                                                                   <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">velscale</span><span class="p">,</span>
                                                                   <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                                                   <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">)</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">_templates</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span>
                           <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">_moments</span><span class="p">,</span>
                           <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span>
                           <span class="n">tied</span><span class="o">=</span><span class="n">_tied</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">_component</span><span class="p">,</span>
                           <span class="n">gas_component</span><span class="o">=</span><span class="n">_gas_template</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">#        # npoly assumed to be zero</span>
<span class="c1">#        print(&#39;GAS TEMPLATE SUM:&#39;)</span>
<span class="c1">#        print(pp.matrix.shape)</span>
<span class="c1">#        print(pp.lam.shape)</span>
<span class="c1">#        s = np.sum(pp.matrix[:,pp.gas_component], axis=0)</span>
<span class="c1">#        ws = np.sum(pp.matrix[:,pp.gas_component]*pp.weights[pp.gas_component], axis=0)</span>
<span class="c1">#        wi = np.sum((pp.matrix[:,pp.gas_component]*pp.weights[None,pp.gas_component])[:-1,:]</span>
<span class="c1">#                            * np.diff(pp.lam)[:,None], axis=0)</span>
<span class="c1">#</span>
<span class="c1">#        mw = np.ma.divide(np.sum((pp.lam[:,None] * pp.matrix[:,pp.gas_component] </span>
<span class="c1">#                                    * pp.weights[None,pp.gas_component])[:-1,:]</span>
<span class="c1">#                                        * np.diff(pp.lam)[:,None], axis=0),wi)</span>
<span class="c1">#        fmw = np.mean(pp.lam)</span>
<span class="c1">#        gc = np.unique(pp.component[pp.gas_component]).astype(int)</span>
<span class="c1">#        print(gc)</span>
<span class="c1">#        print([np.exp(pp.sol[i][0]/astropy.constants.c.to(&#39;km/s&#39;).value) for i in gc])</span>
<span class="c1">#        print(s)</span>
<span class="c1">#        print(ws)</span>
<span class="c1">#        print(wi)</span>
<span class="c1">#        print(np.ma.divide(wi,ws))</span>
<span class="c1">#        print(mw)</span>
<span class="c1">#        print(mw/fmw)</span>
<span class="c1">#        print(np.ma.divide(wi,ws)*(fmw/mw))</span>
<span class="c1">#</span>
<span class="c1">#        print(&#39;GAS FLUXES:&#39;)</span>
<span class="c1">#        print(pp.gas_flux)</span>

        <span class="c1"># Reorder the output; sets any omitted components to a default</span>
        <span class="c1"># value of -999.</span>
        <span class="n">sol</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">_reorder_solution</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">component_map</span><span class="p">,</span> <span class="n">moments</span><span class="p">)</span>

        <span class="c1"># Save the results</span>
        <span class="n">model</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span>
        <span class="n">eml_model</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">:][:,</span><span class="n">_gas_template</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">_gas_template</span><span class="p">])</span>

        <span class="n">tpl_wgts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">valid_templates</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">design_matrix</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matrix</span><span class="o">/</span><span class="n">pp</span><span class="o">.</span><span class="n">noise</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">tpl_wgts_err</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">valid_templates</span><span class="p">]</span> <span class="o">=</span> <span class="n">capfit</span><span class="o">.</span><span class="n">cov_err</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">degree</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">addcoef</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">polyweights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mdegree</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">multcoef</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">mpolyweights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">reddening</span>

        <span class="n">kininp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">kin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>
        <span class="n">kin_err</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
        
<span class="c1">#        plt.plot(flux[i,:], color=&#39;b&#39;, lw=2)</span>
<span class="c1">#        plt.plot(np.ma.MaskedArray(flux[i,:], mask=np.invert(model_mask[i,:])), color=&#39;k&#39;, lw=2)</span>
<span class="c1">#        plt.plot(model[i,:], color=&#39;C3&#39;, lw=1)</span>
<span class="c1">#        plt.plot(model[i,:]-eml_model[i,:], color=&#39;C2&#39;, lw=1)</span>
<span class="c1">#        plt.show()</span>

    <span class="c1"># Done</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting spectrum: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nspec</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">eml_model</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">tpl_wgts</span><span class="p">,</span> <span class="n">tpl_wgts_err</span><span class="p">,</span> <span class="n">addcoef</span><span class="p">,</span> <span class="n">multcoef</span><span class="p">,</span> <span class="n">ebv</span><span class="p">,</span> \
                    <span class="n">kininp</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">kin_err</span></div>


<div class="viewcode-block" id="_combine_stellar_templates"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc._combine_stellar_templates">[docs]</a><span class="k">def</span> <span class="nf">_combine_stellar_templates</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">wgts</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the optimal stellar template for each fitted spectrum.</span>

<span class="sd">    Args:</span>
<span class="sd">        templates (numpy.ndarray): Templates library to use for fitting.</span>
<span class="sd">            Shape is (NTPLPIX,NTPL).</span>
<span class="sd">        gas_template (numpy.ndarray): Boolean vector that selects the</span>
<span class="sd">            gas templates.  Shape is (NTPL,).</span>
<span class="sd">        wgts (numpy.ndarray):  The best-fitting template weights for</span>
<span class="sd">            each template in each spectrum.  Shape is (NSPEC,NTPL).</span>
<span class="sd">        component (numpy.ndarray): Integer vector identifying the</span>
<span class="sd">            kinematic component for each template.  Shape is (NTPL,).</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Five arrays are returned: (1) the weights of only</span>
<span class="sd">        the stellar templates used in constructing each optimal template</span>
<span class="sd">        [shape is (NSPEC,NTPL)]; (2) the optimal stellar templates for</span>
<span class="sd">        each spectrum with the gas templates appended [shape is</span>
<span class="sd">        (NSPEC+NGASTPL,NPIXTPL)]; (3) a boolean array that selects the</span>
<span class="sd">        gas templates [shape is (NSPEC+NGASTPL,); (4) boolean array</span>
<span class="sd">        selecting which templates to use with each spectrum [shape is</span>
<span class="sd">        (NSPEC,NSPEC+NGASTPL)]; (5) integer array setting the component</span>
<span class="sd">        associated with each template [shape is (NSPEC+NGASTPL)].</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if there is more than one stellar component.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the best-fit templates for each bin</span>
    <span class="n">stellar_wgts</span> <span class="o">=</span> <span class="n">wgts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">stellar_wgts</span><span class="p">[:,</span><span class="n">gas_template</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">optimal_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stellar_wgts</span><span class="p">,</span> <span class="n">templates</span><span class="p">)</span>

    <span class="c1"># Update the list of templates</span>
    <span class="n">_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">optimal_template</span><span class="p">),</span> <span class="n">templates</span><span class="p">[</span><span class="n">gas_template</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">_gas_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">_gas_template</span><span class="p">[:</span><span class="n">optimal_template</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
   
    <span class="c1"># Set which templates to use with each spectrum</span>
    <span class="n">nspec</span> <span class="o">=</span> <span class="n">wgts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">_tpl_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">_templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">_tpl_to_use</span><span class="p">[:,</span><span class="n">nspec</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Update the components</span>
    <span class="n">_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">component</span><span class="p">[</span><span class="n">gas_template</span><span class="p">])</span>

    <span class="c1"># Check that the components make sense</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_component</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">_component</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Problem constructing new component vector.  Likely more than one &#39;</span>
                         <span class="s1">&#39;stellar component.&#39;</span><span class="p">)</span>

    <span class="c1"># Return new template list</span>
    <span class="k">return</span> <span class="n">stellar_wgts</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">_tpl_to_use</span><span class="p">,</span> <span class="n">_component</span></div>


<div class="viewcode-block" id="emline_fitter_with_ppxf_edit"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc.emline_fitter_with_ppxf_edit">[docs]</a><span class="k">def</span> <span class="nf">emline_fitter_with_ppxf_edit</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="p">,</span>
                                 <span class="n">inp_component</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">inp_moments</span><span class="p">,</span> <span class="n">inp_start</span><span class="p">,</span>
                                 <span class="n">tied</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">degree</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">reject_boxcar</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux_binned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">noise_binned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_binned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_binned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_binned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main calling function for fitting stellar-continuum and nebular</span>
<span class="sd">    emission lines in many spectra using pPXF.</span>

<span class="sd">    This is a generalization of :func:`emline_fitter_with_ppxf` provided</span>
<span class="sd">    by Xihan Ji and Michele Cappellari.</span>
<span class="sd">    </span>
<span class="sd">    The function *does not* fit for the stellar kinematics; these are</span>
<span class="sd">    fixed during the fit (as provided in `inp_start`) and should have</span>
<span class="sd">    resulted from a previous fit to the stellar-continuum only.  The</span>
<span class="sd">    number of stellar kinematic moments must have been the same for all</span>
<span class="sd">    spectra, and there can only be one stellar component.</span>

<span class="sd">    The templates are expected to be an integer number of velscale_ratio</span>
<span class="sd">    in length; see</span>
<span class="sd">    :func:`mangadap.proc.ppxffit.PPXFFit.check_templates`.</span>

<span class="sd">    The fitting procedure can be performed for a single set of spectra,</span>
<span class="sd">    or a set of spectra that are remapped from an input set of binned</span>
<span class="sd">    spectra.  The latter operation is selected by providing the binned</span>
<span class="sd">    flux, error, and mask arrays and the binned and unbinned on-sky</span>
<span class="sd">    coordinates (see argument description below).</span>

<span class="sd">    When the binned spectra are provided, the fitting procedure is as</span>
<span class="sd">    follows:</span>
<span class="sd">        - The binned spectra are fit with the stellar components fixed</span>
<span class="sd">          to the provided kinematics in the starting value array and</span>
<span class="sd">          with all the gas templates part of a single kinematic</span>
<span class="sd">          component.  This first fit iteration includes any rejection</span>
<span class="sd">          iteration according to the provided boxcar width.</span>
<span class="sd">        - The nearest binned spectrum is then found for each provided</span>
<span class="sd">          spectrum based on the provided coordinates.  The fit to the</span>
<span class="sd">          binned spectrum is then used to set (1) the single optimal</span>
<span class="sd">          stellar template and (2) the initial guess for the gas</span>
<span class="sd">          kinematics to use for the subsequent fits to each individual</span>
<span class="sd">          spectrum</span>
<span class="sd">        - Each spectrum is fit for the first time with the stellar</span>
<span class="sd">          kinematics fixed to the result for the associated binned</span>
<span class="sd">          spectrum and, again, with all the gas templates free but part</span>
<span class="sd">          of the same kinematic component.  This fit iteration includes</span>
<span class="sd">          any rejection iteration according to the provided boxcar</span>
<span class="sd">          width.</span>
<span class="sd">        - Finally the spectra are fit without any rejection iteration</span>
<span class="sd">          and allowing the gas templates to be associated with multiple</span>
<span class="sd">          kinematic components as requested by the user.</span>

<span class="sd">    When no binned spectra are provided, the procedure is virtually the</span>
<span class="sd">    same except the initial fit to the binned spectra is skipped.  An</span>
<span class="sd">    initial fit to the spectra is performed to construct the optimal</span>
<span class="sd">    template, instead of basing the optimal template on the initial fit</span>
<span class="sd">    to the binned spectrum.</span>

<span class="sd">    Args:</span>
<span class="sd">        templates (numpy.ndarray): Templates library to use for fitting.</span>
<span class="sd">            Shape is (NTPLPIX,NTPL).</span>
<span class="sd">        wave (numpy.ndarray): Wavelength vector.  Shape is (NPIX,).</span>
<span class="sd">        flux (numpy.ndarray): Object spectra to fit.  Shape is</span>
<span class="sd">            (NSPEC,NPIX).</span>
<span class="sd">        noise (numpy.ndarray): Error in the object spectra to fit.</span>
<span class="sd">            Shape is (NSPEC,NPIX).</span>
<span class="sd">        mask (numpy.ndarray): Boolean vector that selects the pixels in</span>
<span class="sd">            the object spectra to fit (i.e., mask=True for pixels to fit</span>
<span class="sd">            and mask=False for pixels to ignore).  Shape is</span>
<span class="sd">            (NSPEC,NPIX).  All pixels are fit by default.</span>
<span class="sd">        velscale (float): The pixel scale of the object spectra in km/s.</span>
<span class="sd">        velscale_ratio (int): The ratio between the object and template</span>
<span class="sd">            pixel scale; must be an integer.</span>
<span class="sd">        inp_component (numpy.ndarray): Integer vector identifying the</span>
<span class="sd">            kinematic component for each template.  Shape is (NTPL,).</span>
<span class="sd">        gas_template (numpy.ndarray): Boolean vector that selects the</span>
<span class="sd">            gas templates.  Shape is (NTPL,).</span>
<span class="sd">        inp_moments (numpy.ndarray): Integer vector with the number of</span>
<span class="sd">            kinematic moments for each component.  Shape is (NCOMP,).</span>
<span class="sd">        inp_start (list, numpy.ndarray): The starting kinematics to use</span>
<span class="sd">            for each spectrum.  Shape is (NSPEC,); each element has</span>
<span class="sd">            shape (NCOMP,); each component element has shape (NMOM,),</span>
<span class="sd">            such that the number of moments can be different for each</span>
<span class="sd">            component.  NCOMP and NMOM should be the same for all object</span>
<span class="sd">            spectra.</span>
<span class="sd">        tied (list): (**Optional**) List of parameters to tie during the</span>
<span class="sd">            fit.  Shape is (NCOMP,).</span>
<span class="sd">        degree (int): (**Optional**) Order of the additive polynomial to</span>
<span class="sd">            include in the fit.  Not included by default.</span>
<span class="sd">        mdegree (int): (**Optional**) Order of the multiplicative</span>
<span class="sd">            polynomial to fit.  Not included by default.</span>
<span class="sd">        reddening (float): (**Optional**) Initial E(B-V) guess for</span>
<span class="sd">            reddening (uses ppxf-default Calzetti 2000 model).  No</span>
<span class="sd">            attentuation fit by default.</span>
<span class="sd">        reject_boxcar (int): (**Optional**) Size of the window for the</span>
<span class="sd">            rejection statistics.  Should be an odd number and larger</span>
<span class="sd">            and 10.  Default is 101.  If None, no rejection iterations</span>
<span class="sd">            are performed.</span>
<span class="sd">        vsyst (float): (**Optional**) The pseudo velocity shift between</span>
<span class="sd">            the template and object spectra just due to the difference</span>
<span class="sd">            in the starting wavelength. Default is 0 km/s.</span>
<span class="sd">        tpl_to_use (numpy.ndarray):  (**Optional**) Boolean vector</span>
<span class="sd">            selecting templates to consider during the fit.  If None,</span>
<span class="sd">            all templates are used in the fit.  If provided, the shape</span>
<span class="sd">            must be (NBIN,NTPL) when providing the binned data and</span>
<span class="sd">            (NSPEC,NTPL) when no binned data are provided.</span>
<span class="sd">        flux_binned (numpy.ndarray): (**Optional**) Binned spectra with</span>
<span class="sd">            previous fits to the stellar kinematics.  See purpose above.</span>
<span class="sd">        noise_binned (numpy.ndarray): (**Optional**) Error in the binned</span>
<span class="sd">            spectra.</span>
<span class="sd">        mask_binned (numpy.ndarray): (**Optional**) Mask for the binned</span>
<span class="sd">            spectra.</span>
<span class="sd">        x_binned (numpy.ndarray): (**Optional**) On-sky bin x</span>
<span class="sd">            coordinate; shape is (NBIN,).</span>
<span class="sd">        y_binned (numpy.ndarray): (**Optional**) On-sky bin y</span>
<span class="sd">            coordinate; shape is (NBIN,).</span>
<span class="sd">        x (numpy.ndarray): (**Optional**) On-sky spectrum x coordinates;</span>
<span class="sd">            shape is (NSPEC,)</span>
<span class="sd">        y (numpy.ndarray): (**Optional**) On-sky spectrum y coordinates;</span>
<span class="sd">            shape is (NSPEC,).</span>
<span class="sd">        plot (bool): (**Optional**) Show the pPXF fit plot at each</span>
<span class="sd">            iteration.  Default is to skip the plot.</span>
<span class="sd">        quiet (bool): (**Optional**) Suppress output to the terminal</span>
<span class="sd">            (default).</span>
<span class="sd">        debug (bool): (**Optional**) Run in debugging mode.  Currently,</span>
<span class="sd">            all this does is perform the initial setup and then return</span>
<span class="sd">            empty vectors of the correct shape.  No fits are performed.</span>
<span class="sd">   </span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Eleven arrays are returned: (1) The best-fitting</span>
<span class="sd">        model for each spectrum [shape is (NSPEC,NPIX)]; (2) the</span>
<span class="sd">        best-fitting emission-line-only model for each spectrum [shape</span>
<span class="sd">        is (NSPEC,NPIX)]; (3) a boolean array that is True for all</span>
<span class="sd">        spectral pixels included in the fit [shape is (NSPEC,NPIX)]; (4)</span>
<span class="sd">        the best-fitting weight for each template in each spectrum</span>
<span class="sd">        [shape is (NSPEC,NTPL)]; (5) the error in the best-fitting</span>
<span class="sd">        template weights [shape is (NSPEC,NTPL)]; (6) the coefficients</span>
<span class="sd">        of the additive polynomial for each spectrum [shape is</span>
<span class="sd">        (NSPEC,DEGREE+1)], None if not fit; (7) the coefficients of the</span>
<span class="sd">        multiplicative polynomial for each spectrum [shape is</span>
<span class="sd">        (NSPEC,MDEGREE)]; (8) the best-fitting reddening values for each</span>
<span class="sd">        spectrum [shape is (NSPEC,)], None if not fit; (9) the input</span>
<span class="sd">        kinematics for each fit [shape is (NSPEC,sum(MOMENTS)], None if</span>
<span class="sd">        not fit; (10) the best-fit kinematics for each fit [shape is</span>
<span class="sd">        (NSPEC,sum(MOMENTS)]; (11) the formal error in the best-fit</span>
<span class="sd">        kinematics for each fit [shape is (NSPEC,sum(MOMENTS)].</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: Raised if the number of stellar components</span>
<span class="sd">            is larger than 1.</span>
<span class="sd">        ValueError: Raised if: (1) some of the necessary bin-remapping</span>
<span class="sd">            data has not been provided (see function description); (2)</span>
<span class="sd">            the template flag object does not have the correct shape;</span>
<span class="sd">            (3) the wavelength and flux vectors do not match; and (4)</span>
<span class="sd">            the input list of kinematics does not have the correct</span>
<span class="sd">            length.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that there is either one or zero stellar components</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gas_template</span><span class="p">)</span> <span class="o">!=</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">inp_component</span><span class="p">[</span><span class="o">~</span><span class="n">gas_template</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Can only fit one stellar component!&#39;</span><span class="p">)</span>

    <span class="c1"># Confirm which binned datasets were provided (mask_binned can be</span>
    <span class="c1"># None)</span>
    <span class="n">binned_data_provided</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">flux_binned</span><span class="p">,</span> <span class="n">noise_binned</span><span class="p">,</span>
                                                              <span class="n">x_binned</span><span class="p">,</span> <span class="n">y_binned</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">binned_data_provided</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">binned_data_provided</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;To use bin-remapping mode, must provide all of the following: &#39;</span>
                         <span class="s1">&#39;flux_binned, noise_binned, x_binned, y_binned, x, y&#39;</span><span class="p">)</span>

    <span class="c1"># Set the fitting mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;fitBins&#39;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">binned_data_provided</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;noBins&#39;</span>

    <span class="c1"># Check the shape of provided template flags</span>
    <span class="k">if</span> <span class="n">tpl_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fitBins&#39;</span> <span class="ow">and</span> <span class="n">tpl_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">flux_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Template flag rows does not match number of binned spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;noBins&#39;</span> <span class="ow">and</span> <span class="n">tpl_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Template flag rows does not match number of spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tpl_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Template flags do not match the number of templates.&#39;</span><span class="p">)</span>

    <span class="c1"># Check the shape of the input flux, wavelength, and start objects</span>
    <span class="n">nspec</span><span class="p">,</span> <span class="n">nwave</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;noBins&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nspec</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input starting kinematic arrays do not match the input spectra.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nwave</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch of wavelength vector with provided spectra.&#39;</span><span class="p">)</span>

    <span class="c1"># Get the number of templates and the number of kinematic parameters</span>
    <span class="n">ntpl</span><span class="p">,</span> <span class="n">npix_tpl</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">inp_moments</span><span class="p">))</span>

    <span class="c1"># Instantiate the output</span>
    <span class="n">model_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">model_eml_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">model_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">tpl_wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">tpl_wgt_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">addcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">multcoef</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">mdegree</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">mdegree</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ebv</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">reddening</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">kininp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kin_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">nkin</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># If debugging, just return the initialized output</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;JUST DEBUGGING.  NO EMISSION-LINE FITS PERFORMED!!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fitBins&#39;</span><span class="p">:</span>
            <span class="c1"># - Get the index of the nearest bin for every spaxel</span>
            <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_binned</span><span class="p">)</span>
                                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_binned</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">kininp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inp_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span><span class="o">*</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="n">kininp</span>
        <span class="n">kinerr</span> <span class="o">=</span> <span class="n">kin</span><span class="o">/</span><span class="mi">10</span>
        <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">tpl_wgt</span><span class="p">,</span> <span class="n">tpl_wgt_err</span><span class="p">,</span> <span class="n">addcoef</span><span class="p">,</span> <span class="n">multcoef</span><span class="p">,</span> \
                    <span class="n">ebv</span><span class="p">,</span> <span class="n">kininp</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">kin_err</span><span class="p">,</span> <span class="n">nearest_bin</span>

    <span class="c1"># First fit the binned data</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fitBins&#39;</span><span class="p">:</span>

        <span class="c1"># If binned data provided, the input starting kinematics arrays</span>
        <span class="c1"># must be sized appropriately for the binned data </span>
        <span class="n">nbin</span> <span class="o">=</span> <span class="n">flux_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input starting kinematic arrays do not match the binned spectra.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">!=</span> <span class="n">flux_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mismatch of wavelength vector with provided binned spectra.&#39;</span><span class="p">)</span>

        <span class="c1"># First fit the binned data:</span>
        <span class="c1"># - Stellar components with fixed kinematics</span>
        <span class="c1"># - All gas templates in a single component</span>
        <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">_ppxf_component_setup</span><span class="p">(</span><span class="n">inp_component</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">inp_start</span><span class="p">,</span>
                                                          <span class="n">single_gas_component</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">binned_tpl_wgts</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">binned_kin</span><span class="p">,</span> <span class="n">_</span> \
                    <span class="o">=</span> <span class="n">_fit_iteration</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux_binned</span><span class="p">,</span> <span class="n">noise_binned</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                     <span class="n">moments</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">tpl_to_use</span><span class="p">,</span>
                                     <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">reject_boxcar</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span>
                                     <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span>
                                     <span class="n">mask</span><span class="o">=</span><span class="n">mask_binned</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

        <span class="n">valid_bin_str_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binned_tpl_wgts</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">gas_template</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">valid_bin_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binned_tpl_wgts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">nvalid_bin_str_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_bin_str_fit</span><span class="p">)</span>

        <span class="c1"># - Create new template set with the optimal stellar template</span>
        <span class="c1">#   for each spectrum, only using those with valid stellar</span>
        <span class="c1">#   weights</span>
        <span class="n">stellar_wgts</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">_tpl_to_use</span><span class="p">,</span> <span class="n">_component</span> \
                    <span class="o">=</span> <span class="n">_combine_stellar_templates</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">gas_template</span><span class="p">,</span>
                                                 <span class="n">binned_tpl_wgts</span><span class="p">[</span><span class="n">valid_bin_str_fit</span><span class="p">,:],</span>
                                                 <span class="n">inp_component</span><span class="p">)</span>

        <span class="c1"># - Get the index of the nearest bin for every spaxel</span>
        <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_binned</span><span class="p">[</span><span class="n">valid_bin_str_fit</span><span class="p">])</span> 
                                    <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_binned</span><span class="p">[</span><span class="n">valid_bin_str_fit</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># - Use the binned data as the starting guess for the nearest</span>
        <span class="c1">#   spaxel</span>
        <span class="n">stellar_wgts</span> <span class="o">=</span> <span class="n">stellar_wgts</span><span class="p">[</span><span class="n">nearest_bin</span><span class="p">,:]</span>
        <span class="n">_templates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_templates</span><span class="p">[:</span><span class="n">nvalid_bin_str_fit</span><span class="p">,:][</span><span class="n">nearest_bin</span><span class="p">,:],</span>
                                    <span class="n">_templates</span><span class="p">[</span><span class="n">nvalid_bin_str_fit</span><span class="p">:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">_gas_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">_gas_template</span><span class="p">[</span><span class="n">nspec</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">_tpl_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">_templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">_tpl_to_use</span><span class="p">[:,</span><span class="n">_gas_template</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_tpl_to_use</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">_component</span><span class="p">[</span><span class="n">nvalid_bin_str_fit</span><span class="p">:])</span>

        <span class="c1"># - Use the starting positions from the fit to the bins for the</span>
        <span class="c1">#   fit to the individual spaxels</span>
        <span class="n">n_gas_comp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_component</span><span class="p">[</span><span class="n">_gas_template</span><span class="p">]))</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="n">inp_start</span><span class="p">[</span><span class="n">nearest_bin</span><span class="p">]</span>
        <span class="n">gas_start</span> <span class="o">=</span> <span class="n">binned_kin</span><span class="p">[</span><span class="n">valid_bin_str_fit</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="mi">0</span><span class="p">]):][</span><span class="n">nearest_bin</span><span class="p">,:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspec</span><span class="p">):</span>
            <span class="n">_start</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="n">gas_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span><span class="o">*</span><span class="n">n_gas_comp</span> <span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nspec</span><span class="p">)</span>
        <span class="n">stellar_wgts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_templates</span> <span class="o">=</span> <span class="n">templates</span>
        <span class="n">_gas_template</span> <span class="o">=</span> <span class="n">gas_template</span>
        <span class="n">_tpl_to_use</span> <span class="o">=</span> <span class="n">tpl_to_use</span>
        <span class="n">_component</span> <span class="o">=</span> <span class="n">inp_component</span>
        <span class="n">_start</span> <span class="o">=</span> <span class="n">inp_start</span>


    <span class="c1"># Fit the data iteratively:</span>
    <span class="c1">#  - Fit with all the gas templates as part of one component</span>
    <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">_ppxf_component_setup</span><span class="p">(</span><span class="n">_component</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span>
                                                      <span class="n">single_gas_component</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">model_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">tpl_wgts</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">_</span> \
            <span class="o">=</span> <span class="n">_fit_iteration</span><span class="p">(</span><span class="n">_templates</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span>
                             <span class="n">_gas_template</span><span class="p">,</span> <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">_tpl_to_use</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="n">reject_boxcar</span><span class="p">,</span>
                             <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span>
                             <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                             <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;noBins&#39;</span><span class="p">:</span>
        <span class="c1"># - If no previous fit to binned spectra, create new template</span>
        <span class="c1">#   set with the optimal stellar template for each spectrum</span>
        <span class="c1"># TODO: Template modes:</span>
        <span class="c1">#   - use all</span>
        <span class="c1">#   - use anything that was non-zero in the first fit</span>
        <span class="c1">#   - use single, optimal template</span>
        <span class="n">stellar_wgts</span><span class="p">,</span> <span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">_tpl_to_use</span><span class="p">,</span> <span class="n">_component</span> \
                    <span class="o">=</span> <span class="n">_combine_stellar_templates</span><span class="p">(</span><span class="n">_templates</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">tpl_wgts</span><span class="p">,</span> <span class="n">_component</span><span class="p">)</span>

    <span class="c1"># - Use this result to reset the starting estimates for the gas kinematics</span>
    <span class="n">all_stellar_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">moments</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">gas_start</span> <span class="o">=</span> <span class="n">kin</span><span class="p">[:,</span><span class="n">all_stellar_moments</span><span class="p">:]</span>
    <span class="n">component</span><span class="p">,</span> <span class="n">moments</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">_ppxf_component_setup</span><span class="p">(</span><span class="n">_component</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span>
                                                      <span class="n">gas_start</span><span class="o">=</span><span class="n">gas_start</span><span class="p">)</span>

    <span class="c1"># - Refit without rejection but with the tying in place</span>
    <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">tpl_wgts</span><span class="p">,</span> <span class="n">tpl_wgts_err</span><span class="p">,</span> <span class="n">addcoef</span><span class="p">,</span> <span class="n">multcoef</span><span class="p">,</span> <span class="n">ebv</span><span class="p">,</span> \
            <span class="n">kininp</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">kin_err</span> <span class="o">=</span> <span class="n">_fit_iteration</span><span class="p">(</span><span class="n">_templates</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                                  <span class="n">moments</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">_gas_template</span><span class="p">,</span>
                                                  <span class="n">tpl_to_use</span><span class="o">=</span><span class="n">_tpl_to_use</span><span class="p">,</span> <span class="n">reject_boxcar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                                                  <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">reddening</span><span class="o">=</span><span class="n">reddening</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="n">tied</span><span class="p">,</span>
                                                  <span class="n">mask</span><span class="o">=</span><span class="n">model_mask</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">vsyst</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                                                  <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>

    <span class="c1"># - Use the single output weight to renormalize the individual</span>
    <span class="c1">#   stellar template weights (only one of the weights for the</span>
    <span class="c1">#   non-gas templates should be non-zero); stellar-weight errors are</span>
    <span class="c1">#   always returned as 0.</span>
    <span class="n">_tpl_wgts</span> <span class="o">=</span> <span class="n">stellar_wgts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tpl_wgts</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">_gas_template</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">_tpl_wgts</span><span class="p">[:,</span><span class="n">gas_template</span><span class="p">]</span> <span class="o">=</span> <span class="n">tpl_wgts</span><span class="p">[:,</span><span class="n">_gas_template</span><span class="p">]</span>
    <span class="n">_tpl_wgts_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nspec</span><span class="p">,</span><span class="n">ntpl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">_tpl_wgts_err</span><span class="p">[:,</span><span class="n">gas_template</span><span class="p">]</span> <span class="o">=</span> <span class="n">tpl_wgts_err</span><span class="p">[:,</span><span class="n">_gas_template</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">_tpl_wgts</span><span class="p">,</span> <span class="n">_tpl_wgts_err</span><span class="p">,</span> <span class="n">addcoef</span><span class="p">,</span> <span class="n">multcoef</span><span class="p">,</span> \
                    <span class="n">ebv</span><span class="p">,</span> <span class="n">kininp</span><span class="p">,</span> <span class="n">kin</span><span class="p">,</span> <span class="n">kin_err</span><span class="p">,</span> <span class="n">nearest_bin</span></div>

    


<span class="c1"># Function: emline_fitter_with_ppxf</span>
<span class="c1"># Input is:</span>
<span class="c1">#   - wave0: wavelength vector (in vacuum); shape is (Nwave,)</span>
<span class="c1">#   - flux: observed, unbinned flux; masked array with shape</span>
<span class="c1">#     (Nspaxel,Nwave)</span>
<span class="c1">#   - noise: error in observed, unbinned flux; masked array with</span>
<span class="c1">#     shape (Nspaxel,Nwave)</span>
<span class="c1">#   - sres: spectral resolution (R=lambda/delta lambda) as a</span>
<span class="c1">#     function of wavelength for each unbinned spectrum; shape</span>
<span class="c1">#     is (Nspaxel,Nwave)</span>
<span class="c1">#   - flux_binned: binned flux; masked array with shape</span>
<span class="c1">#     (Nbin,Nwave)</span>
<span class="c1">#   - noise_binned: noise in binned flux; masked array with</span>
<span class="c1">#     shape (Nbin,Nwave)</span>
<span class="c1">#   - sres_binned: spectral resolution (R=lambda/delta lambda)</span>
<span class="c1">#     as a function of wavelength for each binned spectrum;</span>
<span class="c1">#     shape is (Nbin,Nwave)</span>
<span class="c1">#   - velscale: Velocity step per pixel</span>
<span class="c1">#   - velscale_ratio: Ratio of velocity step per pixel in the</span>
<span class="c1">#     observed data versus in the template data</span>
<span class="c1">#   - dv: Velocity offset between the galaxy and template data</span>
<span class="c1">#     due to the difference in the initial wavelength of the</span>
<span class="c1">#     spectra</span>
<span class="c1">#   - stars_vel: Velocity of the stellar component; shape is</span>
<span class="c1">#     (Nbins,)</span>
<span class="c1">#   - stars_sig: Velocity dispersion of the stellar component;</span>
<span class="c1">#     shape is (Nbins,)</span>
<span class="c1">#   - templates: Template flux; shape is (Ntpl,Ntplwave)</span>
<span class="c1">#   - gas_tpl: Boolean array for extracting gas templates; shape</span>
<span class="c1">#     is (Ntpl,)</span>
<span class="c1">#   - guess_vel: Initial guess velocity for the gas components;</span>
<span class="c1">#     shape is (Nbins,)</span>
<span class="c1">#   - guess_sig: Initial guess velocity dispersion for the gas</span>
<span class="c1">#     components; shape is (Nbins,)</span>
<span class="c1">#   - gas_names: Name of the gas templats; shape is (Ngastpl,)</span>
<span class="c1">#   - eml_wave: Rest wavelength of gas templates (in vacuum);</span>
<span class="c1">#     shape is (Ngastpl,)</span>
<span class="c1">#   - eml_component: Component vector for ppxf (each kinimatic</span>
<span class="c1">#     group has a unique index, and an index below zero will</span>
<span class="c1">#     automatically fix the moments); shape is (Nkin_group,)</span>
<span class="c1">#   - eml_tied: Tied vector for ppxf (to decide the tying </span>
<span class="c1">#     relations among gas components); shape is (Nkin_group,</span>
<span class="c1">#     Nmoment)</span>
<span class="c1">#   - template_sres: spectral resolution (R=lambda/delta</span>
<span class="c1">#     lambda) as a function of wavelength for all the templates</span>
<span class="c1">#     templates; shape is (Ntplwave,)</span>
<span class="c1">#   - degree: Additive polynomial order</span>
<span class="c1">#   - mdegree: Multiplicative polynomial order</span>
<span class="c1">#   - x: On-sky spaxel x coordinates; shape is (Nspaxel,)</span>
<span class="c1">#   - y: On-sky spaxel y coordinates; shape is (Nspaxel,)</span>
<span class="c1">#   - x_binned: On-sky bin x coordinate; shape is (Nbin,)</span>
<span class="c1">#   - y_binned: On-sky bin y coordinate; shape is (Nbin,)</span>
<span class="c1">#   - mask_binned: Masks for binned spectra; shape is (Nbin,</span>
<span class="c1">#     Nwave)</span>
<span class="c1">#   - mask_drp: Masks for unbinned spectra; shape is (Nbin,</span>
<span class="c1">#     Nwave)</span>
<span class="c1">#   - nsa_z: NSA (or guess) redshift of the galaxy</span>
<span class="c1">#</span>
<span class="c1"># Output is:</span>
<span class="c1">#   - model_flux: stellar-continuum + emission-line model; shape</span>
<span class="c1">#     is (Nmod, Nwave); first axis is ordered by model ID number</span>
<span class="c1">#   - model_eml_flux: model emission-line flux only; shape is</span>
<span class="c1">#     (Nmod, Nwave); first axis is ordered by model ID number</span>
<span class="c1">#   - model_mask: boolean or bit mask for fitted models; shape</span>
<span class="c1">#     is (Nmod, Nwave); first axis is ordered by model ID number</span>
<span class="c1">#   - model_binid: ID numbers assigned to each spaxel with a</span>
<span class="c1">#     fitted model; any spaxel without a model should have</span>
<span class="c1">#     model_binid = -1; the number of &gt;-1 IDs must be Nmod;</span>
<span class="c1">#     shape is (Nspaxel,)</span>
<span class="c1">#   - weights: weights of the templates (the best fit template </span>
<span class="c1">#     can be obtained by setting: bestemp = templates @ weights);</span>
<span class="c1">#     shape is (Nmod, Ntpl)</span>
<span class="c1">#   - weights_err: 1 sigma formal error of weights; shape is</span>
<span class="c1">#     (Nmod, Ntpl)</span>
<span class="c1">#   - mweights: coefficients of multiplicative Legendre polynomials</span>
<span class="c1">#     of order &gt; 0; shape is (Nmod, mdegree)</span>
<span class="c1">#   - eml_kin: Kinematics (velocity and velocity dispersion) of</span>
<span class="c1">#     each emission line; shape is (Nmod,Neml,Nkin)</span>
<span class="c1">#   - eml_kinerr: Error in the kinematics of each emission line</span>
<span class="c1">#   - eml_sigmacorr: Quadrature corrections required to obtain</span>
<span class="c1">#     the astrophysical velocity dispersion; shape is</span>
<span class="c1">#     (Nmod,Neml); corrections are expected to be applied as</span>
<span class="c1">#     follows:</span>
<span class="c1">#       sigma = numpy.ma.sqrt( numpy.square(eml_kin[:,:,1])</span>
<span class="c1">#                               - eml_sigmacorr)</span>
<span class="c1">#     NOTE THAT: eml_sigmacorr here are actually in unit of </span>
<span class="c1">#     (km/s)^2 and could have negative values</span>
<span class="c1"># --------------------------------------------------------------</span>

<div class="viewcode-block" id="emline_fitter_with_ppxf"><a class="viewcode-back" href="../../../mangadap.contrib.xjmc.html#mangadap.contrib.xjmc.emline_fitter_with_ppxf">[docs]</a><span class="k">def</span> <span class="nf">emline_fitter_with_ppxf</span><span class="p">(</span><span class="n">wave0</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">flux_binned</span><span class="p">,</span> <span class="n">noise_bin</span><span class="p">,</span>
                            <span class="n">velscale</span><span class="p">,</span> <span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">templates</span><span class="p">,</span> <span class="n">gas_tpl</span><span class="p">,</span> 
                            <span class="n">vel_gas</span><span class="p">,</span> <span class="n">sig_gas</span><span class="p">,</span> <span class="n">gas_names</span><span class="p">,</span> <span class="n">eml_wave</span><span class="p">,</span> <span class="n">eml_component</span><span class="p">,</span> 
                            <span class="n">eml_tied</span><span class="p">,</span> <span class="n">templates_sres</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xbin</span><span class="p">,</span> 
                            <span class="n">ybin</span><span class="p">,</span> <span class="n">mask_binned</span><span class="p">,</span> <span class="n">mask_drp</span><span class="p">,</span> <span class="n">nsa_z</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bin_to_spaxel&#39;</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;JUST DEBUGGING.  NO EMISSION-LINE FITS PERFORMED!!&#39;</span><span class="p">)</span>
        <span class="n">n_spaxels</span><span class="p">,</span> <span class="n">nwave</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n_eml</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gas_tpl</span><span class="p">)</span>
        <span class="n">masked_fraction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_drp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">nwave</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">masked_fraction</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">model_binid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_spaxels</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">model_binid</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indx</span><span class="p">))</span>

        <span class="n">model_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_eml_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">model_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="n">eml_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_spaxels</span><span class="p">,</span><span class="n">n_eml</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">eml_fluxerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_spaxels</span><span class="p">,</span><span class="n">n_eml</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">eml_kin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_spaxels</span><span class="p">,</span><span class="n">n_eml</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">eml_kinerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_spaxels</span><span class="p">,</span><span class="n">n_eml</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
        <span class="n">eml_sigmacorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_spaxels</span><span class="p">,</span><span class="n">n_eml</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_binid</span><span class="p">,</span> <span class="n">eml_flux</span><span class="p">,</span> <span class="n">eml_fluxerr</span><span class="p">,</span> \
                    <span class="n">eml_kin</span><span class="p">,</span> <span class="n">eml_kinerr</span><span class="p">,</span> <span class="n">eml_sigmacorr</span>

    <span class="c1"># templates should have the shape (Nwave, Ntpl) for ppxf</span>
    <span class="n">templates</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Total number of bins</span>
    <span class="n">n_binnum</span> <span class="o">=</span> <span class="n">flux_binned</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Total number of spaxels</span>
    <span class="n">n_spaxels</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Total number of emission lines</span>
    <span class="n">n_eml</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gas_tpl</span><span class="p">)</span>
    
    <span class="c1"># Total number of stellar templates</span>
    <span class="n">n_temps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">gas_tpl</span><span class="p">)</span>

    <span class="n">gas_vel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_binnum</span><span class="p">)</span>
    <span class="n">gas_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_binnum</span><span class="p">)</span>
    <span class="n">gas_flux_binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_binnum</span><span class="p">,</span><span class="n">n_eml</span><span class="p">])</span>
    <span class="n">star_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_binnum</span><span class="p">,</span> <span class="n">n_temps</span><span class="p">])</span>
    <span class="n">star_weights_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_binnum</span><span class="p">,</span> <span class="n">n_temps</span><span class="p">])</span>
    <span class="n">bestfit_template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_binnum</span><span class="p">,</span> <span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    
    <span class="c1"># Testing use</span>
    <span class="c1">#beg = n_binnum if os.path.isfile(npz_file) else 0</span>
    
    <span class="c1"># &#39;bin&#39; mode contains only one iteration, fitting the binned data</span>
    <span class="c1"># &#39;bin_to_spaxel&#39; mode contains two iterations, fitting both the binned and</span>
    <span class="c1"># unbinned data</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span>
        <span class="n">beg1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">beg2</span> <span class="o">=</span> <span class="n">n_spaxels</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n_binnum</span>
        <span class="n">model_shape</span> <span class="o">=</span> <span class="n">flux_binned</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">model_binid</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin_to_spaxel&#39;</span><span class="p">:</span>
        <span class="n">beg1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">beg2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n_spaxels</span>
        <span class="n">model_shape</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">model_binid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spaxels</span><span class="p">)</span>
        <span class="n">id_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Get the index of the nearest bin for every spaxel</span>
        <span class="n">nearest_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">xbin</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">ybin</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Initialize output arrays</span>
    <span class="n">eml_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n_eml</span><span class="p">])</span>
    <span class="n">eml_fluxerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n_eml</span><span class="p">])</span>
    <span class="n">eml_kin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n_eml</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">eml_kinerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n_eml</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">weights_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">templates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">mweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">mdegree</span><span class="p">])</span>

    <span class="n">eml_sigmacorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n_eml</span><span class="p">])</span>

    <span class="n">model_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_shape</span><span class="p">)</span>
    <span class="n">model_eml_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_shape</span><span class="p">)</span>
    <span class="n">model_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model_shape</span><span class="p">)</span>
    
    <span class="c1"># First iteration</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">beg1</span><span class="p">,</span> <span class="n">n_binnum</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting bin: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n_binnum</span><span class="p">))</span>
        
        <span class="c1"># Normalize spectrum to avoid numerical issues</span>
        <span class="n">galaxy</span> <span class="o">=</span> <span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        
        <span class="n">noise_binned</span> <span class="o">=</span> <span class="n">noise_bin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        
        <span class="c1"># Use the first moment of Halpha line as the initial velocity</span>
        <span class="c1"># guess, and use the stellar velocity dispersion as initial</span>
        <span class="c1"># sigma guess for gas components</span>
        <span class="c1">#kin = [vel_gas[i], 100.]</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="p">[</span><span class="n">vel_gas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        
        <span class="c1"># Assign all emission lines with single component to tie their</span>
        <span class="c1"># kinematics (and the same for stellar templates)</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n_temps</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n_eml</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin_to_spaxel&#39;</span>\
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_temps</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># The negative moments automatically fix the stellar kinematics</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin_to_spaxel&#39;</span>\
        <span class="k">else</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">component</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Tie emission lines if one selects the &#39;bin&#39; mode</span>
        <span class="n">tied</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin_to_spaxel&#39;</span> <span class="k">else</span> <span class="n">eml_tied</span>
        
        <span class="c1"># Initial guess for components (for stellar components, these</span>
        <span class="c1"># are fixed values)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">[[</span><span class="n">vel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="p">[</span><span class="n">kin</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># Tie kinematics of all emission lines while fixing the stellar kinematics in the first</span>
        <span class="c1"># fit</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">noise_binned</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                       <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="n">tied</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave0</span><span class="p">,</span>
                       <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="n">component</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">gas_names</span><span class="o">=</span><span class="n">gas_names</span><span class="p">)</span>
        
        <span class="c1"># Calculate the residuals</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">galaxy</span> <span class="o">-</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span>
        
        <span class="c1"># Calculate the noises</span>
        <span class="n">NOISE</span> <span class="o">=</span> <span class="n">calculate_noise</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">reject_boxcar</span><span class="p">)</span>
        
        <span class="c1"># Mask out pixels with residuals &gt; 3 sigmas</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">NOISE</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        
        <span class="c1"># Add a three-sigma cut in the second fit while tying the kinematics as the first one</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">noise_binned</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span>
                       <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave0</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
                       <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="n">tied</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="n">component</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">gas_names</span><span class="o">=</span><span class="n">gas_names</span><span class="p">)</span>
        
        <span class="n">gas_vel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gas_sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Scale back the fluxes; note that the fluxes here are caculated by direct summing rather</span>
        <span class="c1"># than integration! If one uses ppxf_util to construct input templates, the ouput fluxes</span>
        <span class="c1"># should be corrected using pixel step near the lines</span>
        <span class="n">gas_flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gas_flux</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        <span class="n">star_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_temps</span><span class="p">]</span>
        <span class="n">bestfit_template</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[:,</span><span class="o">~</span><span class="n">gas_tpl</span><span class="p">]</span> <span class="o">@</span> <span class="n">star_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">design_matrix</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matrix</span><span class="o">/</span><span class="n">pp</span><span class="o">.</span><span class="n">noise</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">star_weights_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">capfit</span><span class="o">.</span><span class="n">cov_err</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n_temps</span><span class="p">]</span>
        
        <span class="c1"># The ouput of the fitting are parsed in the following lines</span>
        <span class="c1"># (for &#39;bin&#39; mode)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bin&#39;</span><span class="p">:</span>
            <span class="n">eml_kin</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eml_kin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">eml_kin</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># The errors are calculated according to docstring in ppxf.py</span>
            <span class="n">eml_kinerr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eml_kin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span>
            <span class="n">eml_kinerr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span>

            <span class="c1"># Full models of flux and models of emission lines</span>
            <span class="n">model_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>

            <span class="n">spectra</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">gas_spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[:,</span><span class="n">pp</span><span class="o">.</span><span class="n">gas_component</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">gas_component</span><span class="p">])</span>
            <span class="n">model_eml_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">gas_spectrum</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_binned</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>

            <span class="c1"># Masks for models</span>
            <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">mask</span>

            <span class="c1"># Calculate the sigma corrections</span>
            <span class="n">FWHM</span> <span class="o">=</span> <span class="n">wave0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sres</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">eml_wave_new</span> <span class="o">=</span> <span class="n">eml_wave</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">index_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wave0</span><span class="o">-</span><span class="n">eml_wave_new</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">FWHM_diff2</span> <span class="o">=</span> <span class="n">FWHM</span><span class="p">[</span><span class="n">index_new</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">FWHM</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">eml_sigmacorr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FWHM_diff2</span><span class="o">/</span><span class="p">((</span><span class="mf">2.355</span><span class="o">*</span><span class="n">step</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">velscale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Weights and weight errors of gas tempaltes</span>
            <span class="c1"># Note that the star weights errors should never be used</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">star_weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">weights_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">star_weights_err</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">gas_flux_error</span><span class="p">)</span>

            <span class="c1"># Coefficients of multiplicative Legendre polynomials of order &gt; 0</span>
            <span class="n">mweights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">mpolyweights</span>
        
        <span class="c1">#plt.clf()</span>
        <span class="c1">#pp.plot()</span>
        <span class="c1">#plt.show()</span>
    
<span class="c1">#    # Save the results (only for testing)</span>
<span class="c1">#    np.savez_compressed(&#39;/Users/mac/Documents/New_test_results/first_&#39;+plate+&#39;_&#39;+ifu+&#39;.npz&#39;, </span>
<span class="c1">#                        gas_vel = gas_vel, gas_sig = gas_sig,</span>
<span class="c1">#                        gas_flux_binned = gas_flux_binned,</span>
<span class="c1">#                        bestfit_template = bestfit_template)</span>

    <span class="c1"># Second iteration</span>
    <span class="c1"># Load data from the first iteration (only for testing)</span>
<span class="c1">#    first_iter = np.load(&#39;/Users/mac/Documents/New_test_results/first_&#39;+plate+&#39;_&#39;+ifu+&#39;.npz&#39;)</span>
<span class="c1">#    gas_vel = first_iter[&#39;gas_vel&#39;]</span>
<span class="c1">#    gas_sig = first_iter[&#39;gas_sig&#39;]</span>
<span class="c1">#    bestfit_template = first_iter[&#39;bestfit_template&#39;]</span>
    
     <span class="c1"># Testing use</span>
<span class="c1">#    if beg == 0:</span>
<span class="c1">#        print(&#39;writing {0}&#39;.format(npz_file))</span>
<span class="c1">#        np.savez_compressed(npz_file, gas_vel = gas_vel, gas_sig = gas_sig,</span>
<span class="c1">#                            gas_flux_binned = gas_flux_binned, bestfit_template = bestfit_template)</span>
<span class="c1">#    else:</span>
<span class="c1">#        print(&#39;reading {0}&#39;.format(npz_file))</span>
<span class="c1">#        inp = np.load(npz_file)</span>
<span class="c1">#        gas_vel = inp[&#39;gas_vel&#39;]</span>
<span class="c1">#        gas_sig = inp[&#39;gas_sig&#39;]</span>
<span class="c1">#        bestfit_template = inp[&#39;bestfit_template&#39;]</span>
    
<span class="c1">#    for i in range(1084,n_spaxels):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">beg2</span><span class="p">,</span> <span class="n">n_spaxels</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fitting spaxel: </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n_spaxels</span><span class="p">))</span>
        
        <span class="c1"># Here start the first half of the second iteration</span>
        
        <span class="n">mask_DRP</span> <span class="o">=</span> <span class="n">mask_drp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        
        <span class="c1"># Continue the loop if the current spaxel has no spectrum</span>
        <span class="c1"># TODO: decide if 1/3 is appropriate to indicate insufficient</span>
        <span class="c1"># pixels?</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">mask_DRP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">model_binid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model_binid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id_num</span>
            <span class="n">id_num</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Normalize spectrum to avoid numerical issues</span>
        <span class="n">galaxy</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
                
        <span class="n">noise_spaxel</span> <span class="o">=</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        <span class="n">noise_spaxel</span><span class="p">[(</span><span class="n">noise_spaxel</span><span class="o">&lt;=</span><span class="mf">0.</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">noise_spaxel</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">1.</span>
        
        <span class="c1"># This is the index of the nearest bin to the spaxel being used</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">nearest_bin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">gas_templates</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="n">gas_tpl</span><span class="p">]</span>
        <span class="n">templates_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">bestfit_template</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">gas_templates</span><span class="p">])</span>
        
        <span class="c1"># Only one stellar template is used in the second iteration</span>
        <span class="n">n_temps</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># This is the gas kinematics [V, sigma] of the nearest bin which</span>
        <span class="c1"># will be used as the initial guess for emission-line fitting</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="p">[</span><span class="n">gas_vel</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">gas_sig</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        
        <span class="c1"># Combine the input gas components and stellar ones</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n_temps</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n_eml</span><span class="p">)</span>
        
        <span class="n">moments</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># Adopt the same value in the first iteration for star component</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">[[</span><span class="n">vel</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span>
        <span class="c1"># Adopt the same starting value for all gas component</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="p">[</span><span class="n">kin</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># In the third fit, the tying of kinematics is the same as the first two while the initial</span>
        <span class="c1"># guess for gas components, input noise and mask are different</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">templates_sec</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">noise_spaxel</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_DRP</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span>
                       <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave0</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
                       <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="n">component</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">gas_names</span><span class="o">=</span><span class="n">gas_names</span><span class="p">)</span>
        
        <span class="c1"># Calculate the residuals</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">galaxy</span> <span class="o">-</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span>
        
        <span class="c1"># Calculate the noises</span>
        <span class="n">NOISE</span> <span class="o">=</span> <span class="n">calculate_noise</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">reject_boxcar</span><span class="p">)</span>
        
        <span class="c1"># Mask out pixels with residuals &gt; 3 sigmas</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">NOISE</span><span class="p">))</span><span class="o">&amp;</span><span class="n">mask_DRP</span>
        <span class="c1">#print(&#39;Outliers: &#39;+str(3109 - sum(mask)))</span>
        
        <span class="c1"># The forth fit adds a three-sigma cut after the third one</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">templates_sec</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">noise_spaxel</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span>
                       <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave0</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
                       <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="n">component</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">gas_names</span><span class="o">=</span><span class="n">gas_names</span><span class="p">)</span>
        
        <span class="c1"># Here start the second half of the second iteration</span>
        
        <span class="c1"># This is the gas kinematics [V, sigma] of the current spaxel from the last </span>
        <span class="c1"># call of ppxf which will be used as the initial guess for emission-line fitting</span>
        <span class="n">kin</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c1"># Combine the input gas components and stellar ones</span>
        <span class="c1"># Now each kinematic group has a unique component index (&gt;0)</span>
        <span class="n">component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_temps</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">moments</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">component</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Adopt the same value in the first iteration for star component</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">[[</span><span class="n">vel</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span>
        <span class="c1"># Adopt the same starting value for all gas component</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="p">[</span><span class="n">kin</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">moments</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># In the fifth fit, the velocities and sigmas of emission lines are tied as desired</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">ppxf</span><span class="o">.</span><span class="n">ppxf</span><span class="p">(</span><span class="n">templates_sec</span><span class="p">,</span> <span class="n">galaxy</span><span class="p">,</span> <span class="n">noise_spaxel</span><span class="p">,</span> <span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                       <span class="n">velscale_ratio</span><span class="o">=</span><span class="n">velscale_ratio</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_DRP</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">moments</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span> <span class="n">mdegree</span><span class="o">=</span><span class="n">mdegree</span><span class="p">,</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="n">wave0</span><span class="p">,</span>
                       <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span> <span class="n">tied</span><span class="o">=</span><span class="n">eml_tied</span><span class="p">,</span> <span class="n">gas_component</span><span class="o">=</span><span class="n">component</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">gas_names</span><span class="o">=</span><span class="n">gas_names</span><span class="p">)</span>
        
        <span class="c1"># The ouput of the fitting are parsed in the following lines</span>
        
        <span class="n">eml_kin</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eml_kin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">eml_kin</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># The errors are calculated according to docstring in ppxf.py</span>
        <span class="n">eml_kinerr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eml_kin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span>
        <span class="n">eml_kinerr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">error</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">eml_component</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span>
        
        <span class="c1"># Integral fluxes and their errors of all emission lines (not in the final output)</span>
        <span class="c1"># Reset pixel-step for each emline (since ppxf returns flux caculated by direct summing)</span>
        <span class="n">eml_wave0</span> <span class="o">=</span> <span class="n">eml_wave</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">nsa_z</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wave0</span><span class="o">-</span><span class="n">eml_wave0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">wave0</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wave0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c1"># Remain to be examined if /(1+nsa_z) correction is needed...</span>
        <span class="n">eml_flux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gas_flux</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">*</span><span class="n">step</span>
        <span class="n">eml_fluxerr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gas_flux_error</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">*</span><span class="n">step</span>
        
        <span class="c1"># Full models of flux and models of emission lines</span>
        <span class="n">model_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">bestfit</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">gas_spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[:,</span><span class="n">pp</span><span class="o">.</span><span class="n">gas_component</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">gas_component</span><span class="p">])</span>
        <span class="n">model_eml_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">gas_spectrum</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
        
        <span class="c1"># Masks for models</span>
        <span class="n">model_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">mask</span>
        
        <span class="c1"># Calculate the sigma corrections</span>
        <span class="n">FWHM</span> <span class="o">=</span> <span class="n">wave0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sres</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">eml_wave_new</span> <span class="o">=</span> <span class="n">eml_wave</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">index_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wave0</span><span class="o">-</span><span class="n">eml_wave_new</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FWHM_diff2</span> <span class="o">=</span> <span class="n">FWHM</span><span class="p">[</span><span class="n">index_new</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">FWHM</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">eml_sigmacorr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FWHM_diff2</span><span class="o">/</span><span class="p">((</span><span class="mf">2.355</span><span class="o">*</span><span class="n">step</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">velscale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Weights and weight errors of gas tempaltes</span>
        <span class="c1"># Note that the star weights errors should never be used</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">star_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">weights_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">star_weights_err</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">pp</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">gas_flux_error</span><span class="p">)</span>
        
        <span class="c1"># Coefficients of multiplicative Legendre polynomials of order &gt; 0</span>
        <span class="n">mweights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">mpolyweights</span>
        
        <span class="c1">#plt.clf()</span>
        <span class="c1">#pp.plot()</span>
        <span class="c1">#plt.show()</span>
    
<span class="c1">#    # Save the results (only for testing)</span>
<span class="c1">#    np.savez_compressed(&#39;/Users/mac/Documents/New_test_results/second_new&#39;+plate+&#39;_&#39;+ifu+&#39;.npz&#39;, </span>
<span class="c1">#                        model_flux = model_flux, model_eml_flux = model_eml_flux, model_mask = model_mask,</span>
<span class="c1">#                        model_binid = model_binid, eml_flux = eml_flux, eml_fluxerr = eml_fluxerr,</span>
<span class="c1">#                        eml_kin = eml_kin, eml_kinerr = eml_kinerr, eml_sigmacorr = eml_sigmacorr)</span>
<span class="c1">#    </span>
<span class="c1">#    second_iter = np.load(&#39;/Users/mac/Documents/New_test_results/second_new&#39;+plate+&#39;_&#39;+ifu+&#39;.npz&#39;)</span>
<span class="c1">#    model_flux = second_iter[&#39;model_flux&#39;]</span>
<span class="c1">#    model_eml_flux = second_iter[&#39;model_eml_flux&#39;]</span>
<span class="c1">#    model_mask = second_iter[&#39;model_mask&#39;]</span>
<span class="c1">#    model_binid = second_iter[&#39;model_binid&#39;]</span>
<span class="c1">#    eml_flux = second_iter[&#39;eml_flux&#39;]</span>
<span class="c1">#    eml_fluxerr = second_iter[&#39;eml_fluxerr&#39;]</span>
<span class="c1">#    eml_kin = second_iter[&#39;eml_kin&#39;]</span>
<span class="c1">#    eml_kinerr = second_iter[&#39;eml_kinerr&#39;]</span>
<span class="c1">#    eml_sigmacorr = second_iter[&#39;eml_sigmacorr&#39;]</span>
    
    <span class="k">return</span> <span class="n">model_flux</span><span class="p">,</span> <span class="n">model_eml_flux</span><span class="p">,</span> <span class="n">model_mask</span><span class="p">,</span> <span class="n">model_binid</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">weights_err</span><span class="p">,</span> <span class="n">mweights</span><span class="p">,</span>\
           <span class="n">eml_kin</span><span class="p">,</span> <span class="n">eml_kinerr</span><span class="p">,</span> <span class="n">eml_sigmacorr</span></div>


</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, SDSS-IV/MaNGA Pipeline Group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'2.2.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>