#!/usr/bin/env python3

from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from __future__ import unicode_literals

import os
import time
import numpy

from argparse import ArgumentParser

from matplotlib import pyplot, patches, colors, rc
from matplotlib.ticker import NullFormatter, MultipleLocator, LogLocator

from astropy.io import fits

from mangadap.drpfits import DRPFits
from mangadap.proc.reductionassessments import ReductionAssessments

from mangadap.util.fitsutil import DAPFitsUtil
from mangadap.proc.util import growth_lim
from mangadap.util.mapping import map_extent, map_beam_patch
from mangadap.config.defaults import default_redux_path, default_drp_directory_path
from mangadap.config.defaults import default_dap_method, default_dap_method_path
from mangadap.config.defaults import default_dap_plan_file


#-----------------------------------------------------------------------------
def init_image_ax(fig, pos):
    ax = fig.add_axes(pos, facecolor='0.9')
    ax.minorticks_on()
    ax.grid(True, which='major', color='0.8', zorder=0, linestyle='-')
    ax.minorticks_on()
    ax.tick_params(which='major', length=6, direction='in')
    ax.tick_params(which='minor', length=3, direction='in')
    return ax


# THIS IS A TEST FUNCTION!
def stellar_continuum_scatter(plt, ifu, daptype, binid, snr, r68, r99, rchi2,
                              signal, a, da, an, dan, gmr, t, dt, tn, dtn,
                              svel, ssigo, ssigcor, ssigc, extent=None, ofile=None):

    snr_lim = numpy.power(10., growth_lim(numpy.ma.log10(snr), 1.00, fac=1.05))
    snr_lim[0] = max(0.1, snr_lim[0])
    r68_lim = numpy.power(10., growth_lim(numpy.ma.log10(r68), 0.90, fac=1.05))
    r99_lim = numpy.power(10., growth_lim(numpy.ma.log10(r99), 0.90, fac=1.05))
    chi_lim = growth_lim(rchi2, 0.90, fac=1.05)

    s_lim = numpy.power(10., growth_lim(numpy.ma.log10(signal), 1.00, fac=1.10))
    a_lim = growth_lim(numpy.ma.log10(a), 0.99, fac=1.10)
    da_lim = growth_lim(numpy.ma.log10(da), 0.99, fac=1.10)
    an_lim = growth_lim(numpy.ma.log10(an), 1.00, fac=1.10)
    dan_lim = growth_lim(numpy.ma.log10(dan), 1.00, fac=1.10)
    an_lim = numpy.power(10, an_lim)
    dan_lim = numpy.power(10, dan_lim)

    gmr_lim = None if gmr is None else growth_lim(gmr, 0.95, fac=1.10)
    t_lim = growth_lim(numpy.ma.log10(t), 0.99, fac=1.10)
    dt_lim = growth_lim(numpy.ma.log10(dt), 0.99, fac=1.10)
    tn_lim = growth_lim(numpy.ma.log10(tn), 1.00, fac=1.10)
    dtn_lim = growth_lim(numpy.ma.log10(dtn), 1.00, fac=1.10)
    dtn_lim = numpy.power(10, dtn_lim)
    tn_lim = numpy.power(10, tn_lim)

    sv_lim = growth_lim(svel, 0.90, fac=1.2, midpoint=0)
    so_lim = numpy.power(10., growth_lim(numpy.ma.log10(ssigo), 1.00, fac=1.05))
    sc_lim = growth_lim(ssigcor, 0.90, fac=1.05)
    ss_lim = numpy.power(10., growth_lim(numpy.ma.log10(ssigc), 0.90, fac=1.05))

#    so_lim = [ min(so_lim[0],ss_lim[0]), max(so_lim[1],ss_lim[1]) ]
#    ss_lim = so_lim.copy()


    uniq, indx = numpy.unique(binid, return_index=True)
    if uniq[0] == -1:
        indx = indx[1:]

#    fig = pyplot.figure()
#    ax = fig.add_subplot(111, projection='3d')
#
#    ax.scatter(numpy.ma.log10(dtn[indx]), numpy.ma.log10(dan[indx]), numpy.ma.log10(ssigo[indx]),
#               c=snr[indx], cmap='viridis', norm=colors.LogNorm(vmin=snr_lim[0], vmax=snr_lim[1]))
#
#    ax.set_xlim(numpy.log10(dtn_lim))
#    ax.set_ylim(numpy.log10(dan_lim))
#    ax.set_zlim(numpy.log10(so_lim))


#    sc = pyplot.scatter(dan[indx], ssigo[indx], marker='.', s=20, c=rchi2[indx],
#                        cmap='viridis', vmin=chi_lim[0], vmax=chi_lim[1])
#    sc = pyplot.scatter(snr[indx], ssigo[indx], marker='.', s=20, c=dan[indx],
#                        cmap='viridis', norm=colors.LogNorm(vmin=numpy.amin(dan[indx]), vmax=numpy.amax(dan[indx])))
#    sc = pyplot.scatter(signal[indx], dan[indx], marker='.', s=20, c=snr[indx],
#                        cmap='viridis', norm=colors.LogNorm(vmin=snr_lim[0], vmax=snr_lim[1]))
    sc = pyplot.scatter(snr[indx], dan[indx], marker='.', s=20, c=ssigo[indx],
                        cmap='viridis', norm=colors.LogNorm(vmin=so_lim[0], vmax=so_lim[1]))
#    sc = pyplot.scatter(dan[indx], ssigo[indx], marker='.', s=20, c=snr[indx],
#                        cmap='viridis', norm=colors.LogNorm(vmin=snr_lim[0], vmax=snr_lim[1]))
#    sc = pyplot.scatter(dtn[indx], dan[indx], marker='.', s=20, c=snr[indx],
#                        cmap='viridis', norm=colors.LogNorm(vmin=snr_lim[0], vmax=snr_lim[1]))
    cb = pyplot.colorbar(sc)
##    pyplot.xlim(s_lim)
    pyplot.ylim(dan_lim)
    pyplot.xlim(snr_lim)
    pyplot.xscale('log')
    pyplot.yscale('log')

    pyplot.show()
    exit()
    

    

def stellar_continuum_maps(plt, ifu, daptype, snr, r68, r99, rchi2, signal, a, da, an, dan,
                           gmr, t, dt, tn, dtn, svel, ssigo, ssigcor, ssigc, extent=None,
                           ofile=None):

    font = { 'size' : 6 }
    rc('font', **font)

    w,h = pyplot.figaspect(1)
    fig = pyplot.figure(figsize=(1.5*w,1.5*h))

#    Dx = (extent[0]-extent[1])*1.1
#    x_lim = (extent[0]+extent[1])/2 + Dx*numpy.array([1,-1])/2
#    Dy = (extent[2]-extent[3])*1.1
#    y_lim = (extent[2]+extent[3])/2 + Dy*numpy.array([-1,1])/2
#    ax.set_xlim(x_lim)
#    ax.set_ylim(y_lim)

    snr_lim = numpy.power(10., growth_lim(numpy.ma.log10(snr), 0.90, fac=1.05))
    snr_lim[0] = max(0.1, snr_lim[0])
    r68_lim = numpy.power(10., growth_lim(numpy.ma.log10(r68), 0.90, fac=1.05))
    r99_lim = numpy.power(10., growth_lim(numpy.ma.log10(r99), 0.90, fac=1.05))
    chi_lim = growth_lim(rchi2, 0.90, fac=1.05)

    s_lim = numpy.power(10., growth_lim(numpy.ma.log10(signal), 0.99, fac=1.05))
    a_lim = growth_lim(numpy.ma.log10(a), 0.99, fac=1.05)
    da_lim = growth_lim(numpy.ma.log10(da), 0.99, fac=1.05)
    an_lim = growth_lim(numpy.ma.log10(an), 0.99, fac=1.05)
    dan_lim = growth_lim(numpy.ma.log10(dan), 0.99, fac=1.05)

    gmr_lim = None if gmr is None else growth_lim(gmr, 0.95, fac=1.10)
    t_lim = growth_lim(numpy.ma.log10(t), 0.99, fac=1.05)
    dt_lim = growth_lim(numpy.ma.log10(dt), 0.99, fac=1.05)
    tn_lim = growth_lim(numpy.ma.log10(tn), 0.99, fac=1.05)
    dtn_lim = growth_lim(numpy.ma.log10(dtn), 0.99, fac=1.05)

    sv_lim = growth_lim(svel, 0.90, fac=1.2, midpoint=0)
    so_lim = numpy.power(10., growth_lim(numpy.ma.log10(ssigo), 0.90, fac=1.10))
    sc_lim = growth_lim(ssigcor, 0.90, fac=1.10)
    ss_lim = numpy.power(10., growth_lim(numpy.ma.log10(ssigc), 0.90, fac=1.10))

    so_lim = [ min(so_lim[0],ss_lim[0]), max(so_lim[1],ss_lim[1]) ]
    ss_lim = so_lim.copy()

#    so_lim = [10,400]
#    ss_lim = [10,400]

    # ------------------------------------------------------------------
    # Layout
    left = 0.035
    bott = 0.08
    imwd = 0.18
    hbuf = 0.06
    cbuf = 0.005
    cbwd = 0.01
    vbuf = 0.03
    # ------------------------------------------------------------------

    # ------------------------------------------------------------------
    # S/N
    i,j=0,3
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    img = ax.imshow(snr, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=snr_lim[0], vmax=snr_lim[1]), cmap='viridis',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')#, orientation='horizontal')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'S/N', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # 68th percentile of fractional residuals
    i,j=1,3
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(r68, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=r68_lim[0], vmax=r68_lim[1]), cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.2f')#, orientation='horizontal')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'68% Frac. Resid', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

#    ax.text(0.5, 1.2, '{0}-{1}'.format(plt, ifu), horizontalalignment='center',
#            verticalalignment='center', transform=ax.transAxes, fontsize=12)
#    ax.text(0.5, 1.08, daptype, horizontalalignment='center',
#            verticalalignment='center', transform=ax.transAxes, fontsize=12)

    # ------------------------------------------------------------------
    # 99th percentile of fractional residuals
    i,j=2,3
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(r99, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=r99_lim[0], vmax=r99_lim[1]), cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.2f')#, orientation='horizontal')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'99% Frac. Resid', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Reduced chi-square
    i,j=3,3
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(rchi2, origin='lower', interpolation='nearest', extent=extent,
                    vmin=chi_lim[0], vmax=chi_lim[1], cmap='viridis_r', zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.2f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\chi^2_\nu$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)


    # ------------------------------------------------------------------
    # Signal
    i,j=0,2
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    img = ax.imshow(signal, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=s_lim[0], vmax=s_lim[1]), cmap='viridis',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$I_g$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # A
    i,j=1,2
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(a), origin='lower', interpolation='nearest', extent=extent,
                    vmin=a_lim[0], vmax=a_lim[1], cmap='viridis', zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log A$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Delta A
    i,j=2,2
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(an), origin='lower', interpolation='nearest', extent=extent,
                    vmin=an_lim[0], vmax=an_lim[1], cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log A_n$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Delta A/Ig
    i,j=3,2
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(dan), origin='lower', interpolation='nearest',
                    extent=extent, vmin=dan_lim[0], vmax=dan_lim[1], cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log(\delta A_n)$', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    # ------------------------------------------------------------------
    # g-r Color
    i,j=0,1
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    img = ax.imshow(gmr, origin='lower', interpolation='nearest', extent=extent,
                    vmin=gmr_lim[0], vmax=gmr_lim[1], cmap='RdBu_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$g-r$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # T
    i,j=1,1
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(t), origin='lower', interpolation='nearest', extent=extent,
                    vmin=t_lim[0], vmax=t_lim[1], cmap='viridis', zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log T$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Delta T
    i,j=2,1
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(tn), origin='lower', interpolation='nearest', extent=extent,
                    vmin=tn_lim[0], vmax=tn_lim[1], cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log T_n$', horizontalalignment='left', verticalalignment='center',
            transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Delta T/Ig
    i,j=3,1
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(numpy.ma.log10(dtn), origin='lower', interpolation='nearest',
                    extent=extent, vmin=dtn_lim[0], vmax=dtn_lim[1], cmap='viridis_r',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.1f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\log \delta T_n$', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Stellar velocity
    i,j=0,0
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    img = ax.imshow(svel, origin='lower', interpolation='nearest', extent=extent,
                    vmin=sv_lim[0], vmax=sv_lim[1], cmap='RdBu_r', zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.0f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$V_\ast$ (km/s)', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Stellar sigma
    i,j=1,0
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(ssigo, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=so_lim[0], vmax=so_lim[1]), cmap='viridis',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.0f')#, orientation='horizontal')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\sigma_{\rm obs}$ (km/s)', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Sigma correction
    i,j=2,0
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(ssigcor, origin='lower', interpolation='nearest', extent=extent,
                    vmin=sc_lim[0], vmax=sc_lim[1], cmap='viridis', zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.0f')#, orientation='horizontal')
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\sigma_{\rm corr}$ (km/s)', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    # ------------------------------------------------------------------
    # Corrected stellar sigma 
    i,j=3,0
    ax = init_image_ax(fig, [left+i*(imwd+hbuf), bott+j*(imwd+vbuf), imwd, imwd ])
    cax = fig.add_axes([left+i*(imwd+hbuf)+imwd+cbuf, bott+j*(imwd+vbuf), cbwd, imwd ])
    ax.yaxis.set_major_formatter(NullFormatter())
    img = ax.imshow(ssigc, origin='lower', interpolation='nearest', extent=extent,
                    norm=colors.LogNorm(vmin=ss_lim[0], vmax=ss_lim[1]), cmap='viridis',
                    zorder=3)
    cb = fig.colorbar(img, cax=cax, format='%.0f')#, orientation='horizontal')
    cb.locator = LogLocator(base=10, subs=(1.,2.,4.,))
    cb.update_ticks()
    ax.add_patch(map_beam_patch(extent, ax, facecolor='0.7', edgecolor='k', zorder=4))
    ax.text(0.1, 0.95, r'$\sigma_\ast$ (km/s)', horizontalalignment='left',
            verticalalignment='center', transform=ax.transAxes)

    if ofile is None:
        pyplot.show()
    else:
        print('Writing: {0}'.format(ofile))
        fig.canvas.print_figure(ofile, bbox_inches='tight')
    fig.clear()
    pyplot.close(fig)


def gmr_data(plt, ifu, drpver, redux_path):
    # Get the g-r map from the data cube
    drp_cube_file = os.path.join(*DRPFits.default_paths(plt, ifu, 'CUBE', drpver=drpver,
                                                        redux_path=redux_path)
    if not os.path.isfile(drp_cube_file):
        raise FileNotFoundError('{0} does not exist!'.format(drp_cube_file))

    hdu = fits.open(drp_cube_file)
    gmr_map = -2.5*numpy.ma.log10(numpy.ma.MaskedArray(hdu['GIMG'].data,
                                                       mask=numpy.invert(hdu['GIMG'].data>0))
                                    / numpy.ma.MaskedArray(hdu['RIMG'].data,
                                                           mask=numpy.invert(hdu['RIMG'].data>0)))
    hdu.close()
    del hdu
    return gmr_map


def rdxqa_data(plt, ifu, plan, drpver, dapver, analysis_path):
    # Get the surface brightness and S/N maps from the
    # ReductionAssessments object
    rdxqa_file = os.path.join(*ReductionAssessment.default_paths(plt, ifu, plan['drpqa_key'],
                                                                 drpver=drpver, dapver=dapver,
                                                                 analysis_path=analysis_path))
    if not os.path.isfile(rdxqa_file):
        raise FileNotFoundError('{0} does not exist!'.format(rdxqa_file))

    hdu = fits.open(rdxqa_file)
    spatial_shape = (int(numpy.sqrt(hdu['SPECTRUM'].data['SNR'].size)),)*2
#    fgood_map = hdu['SPECTRUM'].data['FGOODPIX'].reshape(spatial_shape).T
    signal_map = numpy.ma.MaskedArray(hdu['SPECTRUM'].data['SIGNAL'].reshape(spatial_shape).T,
                                      mask=numpy.invert(fgood_map > 0))
    snr_map = numpy.ma.MaskedArray(hdu['SPECTRUM'].data['SNR'].reshape(spatial_shape).T,
                                   mask=numpy.invert(fgood_map > 0))
    hdu.close()
    del hdu
    return signal_map, snr_map

    
def continuum_component_data(plt, ifu, plan, drpver, dapver, analysis_path, signal_map=None):
    # Get the coefficient data from the StellarContinuumModel object
    sc_file = os.path.join(*StellarContinuumModel.default_paths(plt, ifu, plan['drpqa_key'],
                                                                plan['bin_key'],
                                                                plan['continuum_key'],
                                                                drpver=drpver, dapver=dapver,
                                                                analysis_path=analysis_path))
    hdu = fits.open(ifile)
    binid_map = hdu['BINID'].data.copy()

    if signal_map is None:
        signal = numpy.ones(hdu['PAR'].data['BINID_INDEX'].size, dtype=float)
    else:
        unique, unique_indx = numpy.unique(binid_map.ravel(), return_index=True)
        unique_indx = unique_indx[1:]
        signal = signal_map.ravel()[unique_indx][ hdu['PAR'].data['BINID_INDEX'] ]

    w = hdu['PAR'].data['TPLWGT'].copy()/tpl_flux_renorm[None,:]
    wn = w/signal[:,None]
#    t = numpy.sqrt(numpy.sum(numpy.square(w), axis=1))
    t = numpy.sum(numpy.absolute(w), axis=1)
    tn = numpy.sum(numpy.absolute(wn), axis=1)
#    dtw = numpy.median(w / numpy.sum(w, axis=1)[:,None], axis=0)
    dtw = numpy.ones(w.shape[1], dtype=float)
#    dtnw = numpy.median(wn / numpy.sum(wn, axis=1)[:,None], axis=0)
    dtnw = numpy.ones(w.shape[1], dtype=float)
    dt = numpy.ma.sqrt(numpy.sum(dtw[None,:]*numpy.square(w - numpy.ma.median(w, axis=0)[None,:]),
                            axis=1) / numpy.sum(dtw))
    dtn = numpy.ma.sqrt(numpy.sum(dtnw[None,:]*numpy.square(wn - numpy.ma.median(wn, axis=0)[None,:]),   
                            axis=1) / numpy.sum(dtnw))

    w = hdu['PAR'].data['ADDCOEF'].copy()
    wn = w/signal[:,None]
#    a = numpy.sqrt(numpy.sum(numpy.square(w), axis=1))
    a = numpy.sum(numpy.absolute(w), axis=1)
    an = numpy.sum(numpy.absolute(wn), axis=1)
#    daw = numpy.median(numpy.absolute(w)
#                        / numpy.sum(numpy.absolute(w), axis=1)[:,None], axis=0)
    daw = numpy.ones(w.shape[1], dtype=float)
#    danw = numpy.median(numpy.absolute(wn)
#                        / numpy.sum(numpy.absolute(wn), axis=1)[:,None], axis=0)
    danw = numpy.ones(w.shape[1], dtype=float)
    da = numpy.ma.sqrt(numpy.sum(daw[None,:]*numpy.square(w - numpy.ma.median(w, axis=0)[None,:]),
                            axis=1) / numpy.sum(w))
    dan = numpy.ma.sqrt(numpy.sum(danw[None,:]*numpy.square(wn - numpy.ma.median(wn, axis=0)[None,:]),
                            axis=1) / numpy.sum(danw))

    hdu.close()
    del hdu

    return binid_map, t, dt, tn, dtn, a, da, an, dan

    
def maps_data(plt, ifu, plan, drpver, dapver, analysis_path):
    method = default_dap_method(plan=plan)
    directory_path = default_dap_method_path(method, plate=plt, ifudesign=ifu, drpver=drpver,
                                             dapver=dapver, analysis_path=analysis_path)
    maps_file = default_dap_file_name(plt, ifud, method, mode='MAPS')
    
    hdu = fits.open(maps_file)

    mask = hdu['BINID'].data[1,:,:] < 0
    
    r68_map = numpy.ma.MaskedArray(hdu['STELLAR_CONT_FRESID'].data[0,:,:], mask=mask)
    r99_map = numpy.ma.MaskedArray(hdu['STELLAR_CONT_FRESID'].data[1,:,:], mask=mask)
    rchi2_map = numpy.ma.MaskedArray(hdu['STELLAR_CONT_RCHI2'].data, mask=mask)
    svel_map = numpy.ma.MaskedArray(hdu['STELLAR_VEL'].data[:,:], mask=mask)
    ssigo_map = numpy.ma.MaskedArray(hdu['STELLAR_SIGMA'].data[:,:], mask=mask)
    ssigcor_map = numpy.ma.MaskedArray(hdu['STELLAR_SIGMACORR'].data[1,:,:], mask=mask)
    ssigc_map = numpy.ma.sqrt( numpy.square(ssigo_map) - numpy.square(ssigcor_map) )

    extent = map_extent(hdu, 'SPX_MFLUX')

    return r68_map, r99_map, rchi2_map, svel_map, ssigo_map, ssigcor_map, ssigc_map, extent


def ppxffit_qa_plot(plt, ifu, plan, drpver=None, redux_path=None, dapver=None, analysis_path=None,
                    tpl_flux_renorm=None):

    # Set the redux and DRP directory paths
    _drpver = default_drp_version() if drpver is None else drpver
    _redux_path = default_redux_path(drpver=_drpver) if redux_path is None else redux_path
    if not os.path.isdir(_redux_path):
        raise NotADirectoryError('{0} is not a directory.'.format(_redux_path))

    # Set the analysis path
    _dapver = default_dap_version() if dapver is None else dapver
    _analysis_path = default_analysis_path(drpver=_drpver, dapver=_dapver) \
                            if analysis_path is None else analysis_path
    if not os.path.isdir(_analysis_path):
        raise NotADirectoryError('{0} is not a directory.'.format(_analysis_path))

    # Get the method, it's root directory, and the qa directories
    method = default_dap_method(plan=plan)
    method_dir = default_dap_method_path(method, plate=plt, ifudesign=ifu], drpver=_drpver,
                                         dapver=_dapver, analysis_path=_analysis_path)
    method_qa_dir = default_dap_method_path(method, plate=plt, ifudesign=ifu, qa=True,
                                            drpver=_drpver, dapver=_dapver,
                                            analysis_path=_analysis_path)
    # Check that the paths exists
    if not os.path.isdir(method_dir):
        raise NotADirectoryError('{0} is not a directory; run the DAP first!'.format(method_dir))
    if not os.path.isdir(method_qa_dir):
        os.makedirs(method_qa_dir)

    # Get the name of the output file
    ofile = os.path.join(method_qa_dir,
                         'manga-{0}-{1}-MAPS-{2}-ppxffit.png'.format(plate, ifu, method))

    # Get the g-r map
    gmr_map = gmr_data(plt, ifu, _drpver, _redux_path)

    # Get the reduction assessment data
    signal_map, snr_map = rdxqa_data(plt, ifu, plan, _drpver, _dapver, _analysis_path)

    # Get the template weights and additive-polynomial coefficients
    binid_map, t, dt, tn, dtn, a, da, an, dan \
            = continuum_component_data(plt, ifu, plan, _drpver, _dapver, _analysis_path,
                                       signal_map=signal_map)

    # Map the continuum component data
    t_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), t, quiet=True)
    t_map = numpy.ma.MaskedArray(t_map, mask=numpy.invert(t_map > 0))

    dt_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), dt, quiet=True)
    dt_map = numpy.ma.MaskedArray(dt_map, mask=numpy.invert(dt_map > 0)) #/t_map

    tn_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), tn, quiet=True)
    tn_map = numpy.ma.MaskedArray(tn_map, mask=numpy.invert(tn_map > 0))

    dtn_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), dtn, quiet=True)
    dtn_map = numpy.ma.MaskedArray(dtn_map, mask=numpy.invert(dtn_map > 0)) #/tn_map

    a_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), a, quiet=True)
    a_map = numpy.ma.MaskedArray(a_map, mask=numpy.invert(a_map > 0))

    da_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), da, quiet=True)
    da_map = numpy.ma.MaskedArray(da_map, mask=numpy.invert(da_map > 0)) #/a_map

    an_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), an, quiet=True)
    an_map = numpy.ma.MaskedArray(an_map, mask=numpy.invert(an_map > 0))

    dan_map = DAPFitsUtil.reconstruct_map(binid_map.shape, binid_map.ravel(), dan, quiet=True)
    dan_map = numpy.ma.MaskedArray(dan_map, mask=numpy.invert(dan_map > 0)) #/an_map

    # Get the remaining output maps from the MAPS file
    r68_map, r99_map, rchi2_map, svel_map, ssigo_map, ssigcor_map, ssigc_map, extent \
            = maps_data(plt, ifu, plan, _drpver, _dapver, _analysis_path)

#    if not os.path.isfile(ofile):
    stellar_continuum_maps(plt, ifu, method, snr_map, r68_map, r99_map, rchi2_map, signal_map,
                           a_map, da_map, an_map, dan_map, gmr_map, t_map, dt_map, tn_map, dtn_map,
                           svel_map, ssigo_map, ssigcor_map, ssigc_map, extent=extent, ofile=ofile)


#-----------------------------------------------------------------------------

if __name__ == '__main__':
    t = time.clock()

    parser = ArgumentParser()

    parser.add_argument('plate', type=int, help='plate ID to process')
    parser.add_argument('ifudesign', type=int, help='IFU design to process')

    parser.add_argument('--drpver', type=str, help='DRP version', default=None)
    parser.add_argument('--dapver', type=str, help='DAP version', default=None)
    parser.add_argument('--dap_src', type=str, help='Top-level directory with the DAP source code;'
                        ' defaults to $MANGADAP_DIR', default=None)
    parser.add_argument('--analysis_path', type=str, help='main DAP output path', default=None)

    parser.add_argument('--plan_file', type=str, help='parameter file with the MaNGA DAP '
                        'execution plan to use instead of the default' , default=None)

    parser.add_argument('--normal_backend', dest='bgagg', action='store_false', default=True)

    default_tpl_flux_file = os.path.join(os.environ['MANGADAP_DIR'], 'data', 'spectral_templates',
                                         'miles_cluster', 'mileshc_templates_fluxes.db')
    if not os.path.isfile(default_tpl_flux_file):
        default_tpl_flux_file = 'None'
    parser.add_argument('--template_flux_file', type=str, default=default_tpl_flux_file,
                        help='template renormalization flux file; can be set to None; '
                             'default is {0}'.format(default_tpl_flux_file))

    arg = parser.parse_args()

    if arg.bgagg:
        pyplot.switch_backend('agg')

    # Get the DAP method types to plot
    plan_file = default_dap_plan_file(drpver=arg.drpver, dapver=arg.dapver,
                                      analysis_path=arg.analysis_path) \
                                            if arg.plan_file is None else arg.plan_file
    analysisplan = AnalysisPlanSet.from_par_file(plan_file)

    # Set the template weight renormalization if a file is provided
    tpl_renorm_file = None if arg.template_flux_file == 'None' else arg.template_flux_file
    if tpl_renorm_file is not None:
        tpl_flux_db = numpy.genfromtxt(tpl_renorm_file, dtype=float)
        tpl_flux_renorm = tpl_flux_db[:,2].copy()
        del tpl_flux_db
    else:
        tpl_flux_renorm = None

    # Construct the plot for each analysis plan
    for plan in analysisplan:

        # Construct the plot
        ppxffit_qa_plot(arg.plate, arg.ifudesign, plan, drpver=arg.drpver,
                        redux_path=arg.redux_path, dapver=arg.dapver,
                        analysis_path=arg.analysis_path, tpl_renorm_file=tpl_renorm_file)


    print('Elapsed time: {0} seconds'.format(time.clock() - t))



